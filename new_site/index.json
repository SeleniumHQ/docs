[
{
	"uri": "https://seleniumhq.github.io/docs/new_site/get_started_with_webdriver/browsers/",
	"title": "Browsers",
	"tags": [],
	"description": "",
	"content": " Consumer browsers The Selenium framework officially supports the following browsers:\n   Browser Maintainer Versions Supported     Chromium Chromium All versions   Firefox Mozilla 54 and newer   Internet Explorer Selenium 6 and newer   Opera Opera Chromium / Presto 10.5 and newer   Safari Apple 10 and newer    Specialised browsers There is also a set of specialized browsers out there typically used in development environments. We can make use of some of these browsers for automation purposes also, and Selenium ties in support for the following specialized drivers:\n   Driver Name Purpose Maintainer     HtmlUnitDriver Headless browser emulator backed by Rhino Selenium project    "
},
{
	"uri": "https://seleniumhq.github.io/docs/new_site/getting_started/",
	"title": "Getting Started",
	"tags": [],
	"description": "",
	"content": " Getting Started If you are new to Selenium, we have a few resources that can help you get up to speed right away.\n Quick tour  WebDriver Remote Control IDE Grid HTML Runner   "
},
{
	"uri": "https://seleniumhq.github.io/docs/new_site/selenium_installation/installing_selenium_libraries/",
	"title": "Installing Selenium libraries",
	"tags": [],
	"description": "",
	"content": " Installing Selenium libraries First you need to install the Selenium bindings for your automation project. The installation process for libraries depends on the language you choose to use.\nJava Installation of Selenium libraries for Java can be done using Maven. Add the selenium-java dependency in your project pom.xml:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.X\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; The selenium-java dependency supports running your automation project with all Selenium supported browsers. If you want to run tests only in a specific browser, you can add the dependency for that browser in your pom.xml file. For example, you should add following dependency in your pom.xml file to run your tests only in Firefox:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-firefox-driver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.X\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; In a similar manner, if you want to run tests only in Chrome, you should add the following dependency:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-chrome-driver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.X\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Python Installation of Selenium libraries for Python can be done using pip:\npip install selenium Alternatively you can download the PyPI source archive (selenium-x.x.x.tar.gz) and install it using setup.py:\npython setup.py install C Installation of Selenium libraries for C# can be done using NuGet:\n# Using package manager Install-Package Selenium.WebDriver # or using .Net CLI dotnet add package Selenium.WebDriver Ruby Installation of Selenium libraries for Ruby can be done using gem:\ngem install selenium-webdriver JavaScript Installation of Selenium libraries for JavaScript can be done using npm:\nnpm install selenium-webdriver"
},
{
	"uri": "https://seleniumhq.github.io/docs/new_site/introduction/the_selenium_project_and_tools/",
	"title": "The Selenium project and tools",
	"tags": [],
	"description": "",
	"content": " Selenium controls web browsers Selenium is many things, but at its core it\u0026rsquo;s a toolset for web browser automation that uses the best techniques available to remotely control browser instances and emulate a user\u0026rsquo;s interaction with the browser.\nIt allows users to simulate common activities performed by end-users; entering text into fields, selecting drop-down values and checking boxes, and clicking links in documents. It also provides many other controls such as mouse movement, arbitrary JavaScript execution, and much more.\nAlthough used primarily for front-end testing of websites, Selenium is at its core a browser user agent library. The interfaces are ubiquitous to their application, which encourages composition with other libraries to suit your purpose.\nOne interface to rule them all One of the project\u0026rsquo;s guiding principles is to support a common interface for all (major) browser technologies. Web browsers are incredibly complex, highly engineered applications, performing their operations in completely different ways but which frequently look the same while doing so. Even though the text is rendered in the same fonts, the images are displayed in the same place and the links take you to the same destination. What is happening underneath is as different as night and day. Selenium “abstracts” these differences, hiding their details and intricacies from the person writing the code. This allows you to write several lines of code to perform a complicated workflow, but these same lines will execute on Firefox, Internet Explorer, Chrome, and all other supported browsers.\nTools and support Selenium\u0026rsquo;s minimalist design approach gives it versatility to be included as a component in bigger applications. The surrounding infrastructure provided under the Selenium umbrella gives you the tools to put together your own grid of browsers so tests can be run on different browsers and multiple operating systems across a range of machines.\nImagine a bank of computers in your server room or data centre all firing up browsers at the same time hitting your site\u0026rsquo;s links, forms, and tables\u0026mdash;testing your application 24 hours a day. Through the simple programming interface provided for the most common languages, these tests will run tirelessly in parallel, reporting back to you when errors occur.\nIt\u0026rsquo;s an aim to help make this a reality for you, by providing users with tools and documentation to not only control browsers, but to make it easy to scale and deploy such grids.\nWho uses Selenium Many of the most important companies in the world have adopted Selenium for their browser-based testing, often replacing years-long efforts involving other proprietary tools. As it has grown in popularity, so have its requirements and challenges multiplied.\nAs the web becomes more complicated and new technologies are added to websites, it\u0026rsquo;s the mission of this project to keep up with them where possible. Being an open source project, this support is provided through the generous donation of time from many volunteers, every one of which has a “day job”.\nAnother mission of the project is to encourage more volunteers to partake in this effort, and build a strong community so that the project can continue to keep up with emerging technologies and remain a dominant platform for functional test automation.\nHistory When Selenium 1 was released in 2004, it was out of the necessity to reduce time spent manually verifying consistent behaviour in the front-end of a web application. It made use of what tools were available at the time, and relied heavily on the injection of JavaScript to the web page under test to emulate a user\u0026rsquo;s interaction.\nWhilst JavaScript is a good tool to let you introspect the properties of the DOM and to do certain client-side observations that you would otherwise not be able to do, it falls short on the ability to naturally replicate a user\u0026rsquo;s interactions as if the mouse and keyboard are being used.\nSince then, Selenium has grown and matured a lot, into a tool widely used by many\u0026mdash;if not most\u0026mdash;of the largest organisations around the world. Selenium has gone from a homebrewed test automation toolkit developed at Thoughtworks for a niché audience and a specific use case, to the world\u0026rsquo;s de facto browser automation library.\nJust as Selenium RC made use of the tools of the trade available at the time, Selenium WebDriver drives that tradition on by taking the browser interaction part to the browser vendor\u0026rsquo;s home turf, and asking them to take responsibility of the backend, browser-facing implementations. Recently this work has evolved into a W3C standardisation process where the goal is to turn the WebDriver component in Selenium into the du jeur remote control library for user agents.\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/new_site/selenium_installation/installing_webdriver_binaries/",
	"title": "Installing WebDriver binaries",
	"tags": [],
	"description": "",
	"content": " Installing WebDriver binaries To execute your project and control browser you need to have browser-specific WebDriver binaries installed.\nDownload the WebDriver binary supported by your browser and place it in the System PATH.\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/new_site/introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": " Introduction Selenium is an umbrella project for a range of tools and libraries that enable and support the automation of web browsers.\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/new_site/introduction/on_test_automation/",
	"title": "On test automation",
	"tags": [],
	"description": "",
	"content": " First, start by asking yourself whether or not you really need to use a browser. Odds are good that, at some point, if you\u0026rsquo;re working on a complex web application, you will need to open a browser and actually test it.\nFunctional end-user tests such as Selenium tests are expensive to run, however. Furthermore, they typically require substantial infrastructure to be in place to be run effectively. It\u0026rsquo;s a good rule to always ask yourself if what you want to test can be done using more lightweight test approaches such as unit tests or with a lower-level approach.\nOnce you have made the determination that you\u0026rsquo;re in the web browser testing business, and you have your Selenium environment ready to begin writing tests, you will generally perform some combination of three steps:\n Set up the data Perform a discrete set of actions Evaluate the results  You will want to keep these steps as short as possible; one to two operations should be enough much of the time. Browser automation has the reputation of being “flaky”, but in reality that is because users frequently demand too much of it. In later chapters, we will return to techniques you can use to mitigate apparent intermittent problems in tests, in particular on how to overcome race conditions between the browser and WebDriver.\nBy keeping your tests short and using the web browser only when you have absolutely no alternative, you can have many tests with minimal flake.\nA distinct advantage of Selenium tests are their inherent ability to test all components of the application, from backend to frontend, from a user\u0026rsquo;s perspective. So in other words, whilst functional tests may be expensive to run, they also encompass large business-critical portions at one time.\nTesting requirements As mentioned before, Selenium tests can be expensive to run. To what extent depends on the browser you\u0026rsquo;re running the tests against, but historically browsers\u0026rsquo; behaviour has varied so much that it has often been a stated goal to cross-test against multiple browsers.\nSelenium allows you to run the same instructions against multiple browsers on multiple operating systems, but the enumeration of all the possible browsers, their different versions, and the many operating systems they run on will quickly become a non-trivial undertaking.\nLet’s start with an example Larry has written a web site which allows users to order their own custom unicorns.\nThe general workflow (what we\u0026rsquo;ll call the “happy path”) is something like this:\n Create an account Configure their unicorn Add her to the shopping cart Check out and pay Give feedback about their unicorn  It would be tempting to write one grand Selenium script to perform all these operations–many will try. Resist the temptation! Doing so will result in a test that a) takes a long time, b) will be subject to some common issues around page rendering timing issues, and c) is such that if it fails, it won\u0026rsquo;t give you a concise, “glanceable” method for diagnosing what went wrong.\nThe preferred strategy for testing this scenario would be to break it down to a series of independent, speedy tests, each of which has one “reason” to exist.\nLet\u0026rsquo;s pretend you want to test the second step: Configuring your unicorn. It will perform the following actions:\n Create an account Configure a unicorn  Note that we\u0026rsquo;re skipping the rest of these steps, we will test the rest of the workflow in other small, discrete test cases, after we\u0026rsquo;re done with this one.\nTo start off, you need to create an account. Here you have some choices to make:\n Do you want to use an existing account? Do you want to create a new account? Are there any special properties of such a user that need to be taken into account before configuration begins?  Regardless of how you answer this question, the solution is to make it part of the \u0026ldquo;set up the data\u0026rdquo; portion of the test– if Larry has exposed an API which enables you (or anyone) to create and update user accounts, be sure to use that to answer this question– if possible, you want to launch the browser only after you have a user \u0026ldquo;in hand\u0026rdquo;, whose credentials you can just log in with.\nIf each test for each workflow begins with the creation of a user account, many seconds will be added to the execution of each test. Calling an API and talking to a database are quick, “headless” operations that don\u0026rsquo;t require the expensive process of opening a browser, navigating to the right pages, clicking and waiting for the forms to be submitted, etc.\nIdeally, you can address this set-up phase in one line of code, which will execute before any browser is launched:\nJava Python C# Ruby JavaScript // Create a user who has read-only permissions--they can configure a unicorn, // but they do not have payment information set up, nor do they have // administrative privileges. At the time the user is created, its email // address and password are randomly generated--you don\u0026#39;t even need to // know them. User user = UserFactory.createCommonUser(); //This method is defined elsewhere.  // Log in as this user. // Logging in on this site takes you to your personal \u0026#34;My Account\u0026#34; page, so the // AccountPage object is returned by the loginAs method, allowing you to then // perform actions from the AccountPage. AccountPage accountPage = loginAs(user.getEmail(), user.getPassword());   # Create a user who has read-only permissions--they can configure a unicorn, # but they do not have payment information set up, nor do they have # administrative privileges. At the time the user is created, its email # address and password are randomly generated--you don\u0026#39;t even need to # know them. user = user_factory.create_common_user() #This method is defined elsewhere. # Log in as this user. # Logging in on this site takes you to your personal \u0026#34;My Account\u0026#34; page, so the # AccountPage object is returned by the loginAs method, allowing you to then # perform actions from the AccountPage. account_page = login_as(user.get_email(), user.get_password())   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR      As you can imagine, the UserFactory can be extended to provide methods such as createAdminUser(), and createUserWithPayment(). The point is, these two lines of code do not distract you from the ultimate purpose of this test: configuring a unicorn.\nThe intricacies of the Page Object model will be discussed in later chapters, but we will introduce the concept here:\nYour tests should be composed of actions, performed from the user\u0026rsquo;s point of view, within the context of pages in the site. These pages are stored as objects, which will contain specific information about how the web page is composed and how actions are performed– very little of which should concern you as a tester.\nWhat kind of unicorn do you want? You might want pink, but not necessarily. Purple has been quite popular lately. Does she need sunglasses? Star tattoos? These choices, while difficult, are your primary concern as a tester– you need to ensure that your order fulfillment center sends out the right unicorn to the right person, and that starts with these choices.\nNotice that nowhere in that paragraph do we talk about buttons, fields, drop-downs, radio buttons, or web forms. Neither should your tests! You want to write your code like the user trying to solve their problem. Here is one way of doing this (continuing from the previous example):\nJava Python C# Ruby JavaScript // The Unicorn is a top-level Object--it has attributes, which are set here. // This only stores the values; it does not fill out any web forms or interact // with the browser in any way. Unicorn sparkles = new Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS); // Since we\u0026#39;re already \u0026#34;on\u0026#34; the account page, we have to use it to get to the // actual place where you configure unicorns. Calling the \u0026#34;Add Unicorn\u0026#34; method // takes us there. AddUnicornPage addUnicornPage = accountPage.addUnicorn(); // Now that we\u0026#39;re on the AddUnicornPage, we will pass the \u0026#34;sparkles\u0026#34; object to // its createUnicorn() method. This method will take Sparkles\u0026#39; attributes, // fill out the form, and click submit. UnicornConfirmationPage unicornConfirmationPage = addUnicornPage.createUnicorn(sparkles);   # The Unicorn is a top-level Object--it has attributes, which are set here. # This only stores the values; it does not fill out any web forms or interact # with the browser in any way. sparkles = Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS) # Since we\u0026#39;re already \u0026#34;on\u0026#34; the account page, we have to use it to get to the # actual place where you configure unicorns. Calling the \u0026#34;Add Unicorn\u0026#34; method # takes us there. add_unicorn_page = account_page.add_unicorn() # Now that we\u0026#39;re on the AddUnicornPage, we will pass the \u0026#34;sparkles\u0026#34; object to # its createUnicorn() method. This method will take Sparkles\u0026#39; attributes, # fill out the form, and click submit. unicorn_confirmation_page = add_unicorn_page.create_unicorn(sparkles)   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR      Now that you\u0026rsquo;ve configured your unicorn, you need to move on to step 3: making sure it actually worked.\nJava Python C# Ruby JavaScript // The exists() method from UnicornConfirmationPage will take the Sparkles // object--a specification of the attributes you want to see, and compare // them with the fields on the page. Assert.assertTrue(\u0026#34;Sparkles should have been created, with all attributes intact\u0026#34;, unicornConfirmationPage.exists(sparkles));   # The exists() method from UnicornConfirmationPage will take the Sparkles # object--a specification of the attributes you want to see, and compare # them with the fields on the page. assert unicorn_confirmation_page.exists(sparkles), \u0026#34;Sparkles should have been created, with all attributes intact\u0026#34;   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR      Note that the tester still hasn\u0026rsquo;t done anything but talk about unicorns in this code– no buttons, no locators, no browser controls. This method of modelling the application allows you to keep these test-level commands in place and unchanging, even if Larry decides next week that he no longer likes Ruby-on-Rails and decides to re-implement the entire site in the latest Haskell bindings with a Fortran front-end.\nYour page objects will require some small maintenance in order to conform to the site redesign, but these tests will remain the same. Taking this basic design, you will want to keep going through your workflows with the fewest browser-facing steps possible. Your next workflow will involve adding a unicorn to the shopping cart. You will probably want many iterations of this test in order to make sure the cart is keeping its state properly: Is there more than one unicorn in the cart before you start? How many can fit in the shopping cart? If you create more than one with the same name and/or features, will it break? Will it only keep the existing one or will it add another?\nEach time you move through the workflow, you want to try to avoid having to create an account, login as the user, and configure the unicorn. Ideally, you\u0026rsquo;ll be able to create an account and pre-configure a unicorn via the API or database. Then all you have to do is log in as the user, locate Sparkles, and add her to the cart.\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/new_site/get_started_with_webdriver/third_party_drivers_and_plugins/",
	"title": "Third party drivers and plugins",
	"tags": [],
	"description": "",
	"content": "Selenium can be extended through the use of plugins. Here are a number of plugins created and maintained by third parties. For more information on how to create your own plugin or have it listed, consult the docs.\nPlease note that these plugins are not supported, maintained, hosted, or endorsed by the Selenium project. In addition, be advised that the plugins listed below are not necessarily licensed under the Apache License v.2.0. Some of the plugins are available under another free and open source software license; others are only available under a proprietary license. Any questions about plugins and their license of distribution need to be raised with their respective developer(s).\n   Browser Latest version Changelog Issues Wiki     Google ChromeDriver 2.29 changelog issues wiki    "
},
{
	"uri": "https://seleniumhq.github.io/docs/new_site/selenium_installation/installing_standalone_server/",
	"title": "Installing Standalone server",
	"tags": [],
	"description": "",
	"content": " Installing Standalone server If you plan to use Grid then you should download the selenium-server-standalone JAR file. The selenium-server-standalone jar is never uploaded, but all the components are available via selenium-server. The standalone JAR contains everything, including the remote Selenium server and the client-side bindings. This means that if you use the selenium-server-standalone jar in your project, then you don\u0026rsquo;t have to add selenium-java or a browser specific jar.\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-server\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.X\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;"
},
{
	"uri": "https://seleniumhq.github.io/docs/new_site/get_started_with_webdriver/locating_elements/",
	"title": "Locating elements",
	"tags": [],
	"description": "",
	"content": " Locating one element One of the most fundamental techniques to learn when using WebDriver is how to find elements on the page. WebDriver offers a number of built-in selector types, amongst them finding an element by its ID attribute:\nJava Python C# Ruby JavaScript WebElement cheese = driver.findElement(By.id(\u0026#34;cheese\u0026#34;));   driver.find_element_by_id(\u0026#34;cheese\u0026#34;)   IWebElement element = driver.FindElement(By.Id(\u0026#34;cheese\u0026#34;));   driver.find_element(id: \u0026#34;cheese\u0026#34;)   const cheese = await driver.findElement(By.id(\u0026#39;cheese\u0026#39;));     As seen in the example, locating elements in WebDriver is done on the WebDriver instance object. The findElement(By) method returns another fundamental object type, the WebElement.\n WebDriver represents the browser WebElement represents a particular DOM node (a control, e.g. a link or input field, etc.)  Once you have a reference to a web element that\u0026rsquo;s been “found”, you can narrow the scope of your search by using the same call on that object instance:\nJava Python C# Ruby JavaScript WebElement cheese = driver.findElement(By.id(\u0026#34;cheese\u0026#34;)); WebElement cheddar = cheese.findElement(By.id(\u0026#34;cheddar\u0026#34;));   cheese = driver.find_element_by_id(\u0026#34;cheese\u0026#34;) cheddar = cheese.find_elements_by_id(\u0026#34;cheddar\u0026#34;)   IWebElement cheese = driver.FindElement(By.Id(\u0026#34;cheese\u0026#34;)); IWebElement cheddar = cheese.FindElement(By.Id(\u0026#34;cheddar\u0026#34;));   cheese = driver.find_element(id: \u0026#34;cheese\u0026#34;) cheddar = cheese.find_elements(id: \u0026#34;cheddar\u0026#34;)   const cheese = await driver.findElement(By.id(\u0026#39;cheese\u0026#39;)); const cheddar = await cheese.findElement(By.id(\u0026#39;cheddar\u0026#39;));     You can do this because both the WebDriver and WebElement types implement the SearchContext interface. In WebDriver, this is known as a role-based interface. Role-based interfaces allow you to determine whether a particular driver implementation supports a given feature. These interfaces are clearly defined and try to adhere to having only a single role of responsibility. You can read more about WebDriver\u0026rsquo;s design and what roles are supported in which drivers in the Some Other Section Which Must Be Named. Consequently, the By interface used above also supports a number of additional locator strategies. A nested lookup might not be the most effective cheese location strategy since it requires two separate commands to be issued to the browser; first searching the DOM for an element with ID “cheese”, then a search for “cheddar” in a narrowed context.\nTo improve the performance slightly, we should try to use a more specific locator: WebDriver supports looking up elements by CSS locators, allowing us to combine the two previous locators into one search:\nJava Python C# Ruby JavaScript driver.findElement(By.cssSelector(\u0026#34;#cheese #cheddar\u0026#34;));   cheddar = driver.find_element_by_css_selector(\u0026#34;#cheese #cheddar\u0026#34;)   driver.FindElement(By.CssSelector(\u0026#34;#cheese #cheddar\u0026#34;));   mucho_cheese = driver.find_elements(css: \u0026#34;#cheese #cheddar\u0026#34;)   const cheddar = await driver.findElement(By.css(\u0026#39;#cheese #cheddar\u0026#39;));     Locating multiple elements It\u0026rsquo;s possible that the document we are working with may turn out to have an ordered list of the cheese we like the best:\n\u0026lt;ol id=cheese\u0026gt; \u0026lt;li id=cheddar\u0026gt;… \u0026lt;li id=brie\u0026gt;… \u0026lt;li id=rochefort\u0026gt;… \u0026lt;li id=camembert\u0026gt;… \u0026lt;/ul\u0026gt; Since more cheese is undisputably better, and it would be cumbersome to have to retrieve each of the items individually, a superior technique for retrieving cheese is to make use of the pluralized version findElements(By). This method returns a collection of web elements. If only one element is found, it will still return a collection (of one element). If no elements match the locator, an empty list will be returned.\nJava Python C# Ruby JavaScript List\u0026lt;WebElement\u0026gt; muchoCheese = driver.findElements(By.cssSelector(\u0026#34;#cheese li\u0026#34;));   mucho_cheese = driver.find_elements_by_css_selector(\u0026#34;#cheese li\u0026#34;)   IReadOnlyList\u0026lt;IWebElement\u0026gt; muchoCheese = driver.FindElements(By.CssSelector(“#cheese li”));   mucho_cheese = driver.find_elements(css: \u0026#34;#cheese li\u0026#34;)   const muchoCheese = await driver.findElements(By.css(\u0026#39;#cheese li\u0026#39;));     Element selection strategies There are eight different built-in element location strategies in WebDriver:\n   Locator Description     class name Locates elements whose class name contains the search value (compound class names are not permitted)   css selector Locates elements matching a CSS selector   id Locates elements whose ID attribute matches the search value   name Locates elements whose NAME attribute matches the search value   link text Locates anchor elements whose visible text matches the search value   partial link text Locates anchor elements whose visible text matches the search value   tag name Locates elements whose tag name matches the search value   xpath Locates elements matching an XPath expression    Tips on using selectors In general, if HTML IDs are available, unique, and consistently predictable, they are the preferred method for locating an element on a page. They tend to work very quickly, and forego much processing that comes with complicated DOM traversals.\nIf unique IDs are unavailable, a well-written CSS selector is the preferred method of locating an element. XPath works as well as CSS selectors, but the syntax is complicated and frequently difficult to debug. Though XPath selectors are very flexible, they\u0026rsquo;re typically not performance tested by browser vendors and tend to be quite slow.\nSelection strategies based on link text and partial link text have drawbacks in that they only work on link elements. Additionally, they call down to XPath selectors internally in WebDriver.\nTag name can be a dangerous way to locate elements. There are frequently multiple elements of the same tag present on the page. This is mostly useful when calling the findElements(By) method which returns a collection of elements.\nThe recommendation is to keep your locators as compact and readable as possible. Asking WebDriver to traverse the DOM structure is an expensive operation, and the more you can narrow the scope of your search, the better.\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/new_site/selenium_installation/",
	"title": "Selenium installation",
	"tags": [],
	"description": "",
	"content": " Selenium Installation Selenium setup is quite different from the setup of other commercial tools. To use Selenium in your automation project you need to install the language bindings libraries for your language of choice. In addition you will need WebDriver binaries for the browsers you want to automate and run test on.\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/new_site/introduction/types_of_testing/",
	"title": "Types of testing",
	"tags": [],
	"description": "",
	"content": "TODO: Add paragraphs about acceptance testing, performance testing, load testing, regression testing, test driven development, and/or behavior-driven development (JBehave, Capybara, \u0026amp; Robot Framework), with how they relate to Selenium.\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/new_site/introduction/about_this_documentation/",
	"title": "About this documentation",
	"tags": [],
	"description": "",
	"content": "These docs, like the code itself, are maintained 100% by volunteers within the Selenium community. Many have been using it since its inception, but many more have only been using it for a short while, and have given their time to help improve the on-boarding experience for new users.\nIf there is an issue with the documentation, we want to know! The best way to communicate an issue is to visit https://github.com/seleniumhq/docs/issues and search to see whether or not the issue has been filed already. If not, feel free to open one!\nMany members of the community frequent the #selenium IRC channel at irc.freenode.net. Feel free to drop in and ask questions and if you get help which you think could be of use within these documents, be sure to add your contribution! We can update these documents, but it\u0026rsquo;s much easier for everyone when we get contributions from outside the normal committers.\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/new_site/get_started_with_webdriver/performing_actions_on_the_aut/",
	"title": "Performing actions on the AUT*",
	"tags": [],
	"description": "",
	"content": " You can set an element\u0026rsquo;s text using the sendKeys method as follows:\nJava Python C# Ruby JavaScript String name = \u0026#34;Charles\u0026#34;; driver.findElement(By.name(\u0026#34;name\u0026#34;)).sendKeys(name);   name = \u0026#34;Charles\u0026#34; driver.find_element_by_name(\u0026#34;name\u0026#34;).send_keys(name)   string name = \u0026#34;Charles\u0026#34;; driver.FindElement(By.Name(\u0026#34;name\u0026#34;)).SendKeys(name);   name = \u0026#34;Charles\u0026#34; driver.find_element(name: \u0026#34;name\u0026#34;).send_keys(name)   const name = \u0026#34;Charles\u0026#34;; await driver.findElement(By.name(\u0026#39;name\u0026#39;)).sendKeys(name);     Some web applications use JavaScript libraries to add drag-and-drop functionality. The following is a basic example of dragging one element onto another element:\nJava Python C# Ruby JavaScript WebElement source = driver.findElement(By.id(\u0026#34;source\u0026#34;)); WebElement target = driver.findElement(By.id(\u0026#34;target\u0026#34;)); new Actions(driver).dragAndDrop(source, target).build().perform();   source = driver.find_element_by_id(\u0026#34;source\u0026#34;) target = driver.find_element_by_id(\u0026#34;target\u0026#34;) ActionChains(driver).drag_and_drop(source, target).perform()   IWebElement source = driver.FindElement(By.Id(\u0026#34;source\u0026#34;)); IWebElement target = driver.FindElement(By.Id(\u0026#34;target\u0026#34;)); new Actions(driver).DragAndDrop(source, target).Build().Perform();   source = driver.find_element(id: \u0026#34;source\u0026#34;) target = driver.find_element(id: \u0026#34;target\u0026#34;) driver.action.drag_and_drop(source, target).perform   const actions = driver.actions({bridge: true}); const source = await driver.findElement(By.id(\u0026#39;source\u0026#39;)); const target = await driver.findElement(By.id(\u0026#39;target\u0026#39;)); await actions.dragAndDrop(source, target).perform();     Clicking on an element You can click on an element using the click method:\nJava Python C# Ruby JavaScript driver.findElement(By.cssSelector(\u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;)).click();   driver.find_element_by_css_selector(\u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;).click()   driver.FindElement(By.CssSelector(\u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;)).Click();   driver.find_element(css: \u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;).click   await driver.findElement(By.css(\u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;)).click();     *AUT: Application under test\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/new_site/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://seleniumhq.github.io/docs/new_site/get_started_with_webdriver/",
	"title": "Get started with WebDriver",
	"tags": [],
	"description": "",
	"content": " Get started with WebDriver Selenium supports automation of all the major browsers in the market through the use of WebDriver. WebDriver is an API and protocol that defines a language-neutral interface for controlling the behaviour of web browsers. Each browser is backed by a specific WebDriver implementation, called a driver. The driver is the component responsible for delegating down to the browser, and handles communication to and from Selenium and the browser.\nThis separation is part of a conscious effort to have browser vendors take responsibility for the implementation for their browsers. Selenium makes use of these third party drivers where possible, but also provides its own drivers maintained by the project for the cases when this is not a reality.\nThe Selenium framework ties all of these pieces together through a user-facing interface that enables the different browser backends to be used transparently, enabling cross-browser and cross-platform automation.\nMore details about drivers can be found in Driver Idiosyncrasies.\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/new_site/getting_started/quick/",
	"title": "Quick Tour",
	"tags": [],
	"description": "",
	"content": " Selenium is not just one tool or API but it composes many tools.\nWebDriver WebDriver is also known as Selenium 2. If you are beginning with desktop website test automation then you are going to be using WebDriver APIs. WebDriver uses browser automation APIs provided by browser vendors to control browser and run tests. This is as if a real user is operating the browser. Since WebDriver does not require its API to be compiled with application code, it is not intrusive in nature. Hence, you are testing the same application which you push live.\nRemote Control Remote Control is also known as Selenium 1. Selenium RC was the most prominent Selenium tool before the advent of Selenium WebDriver. Selenium RC would use a proxy server and inject JavaScript into a browser to be able to control it. Given the intrusive nature Selenium RC had on a browser, you could never be sure if what you were testing was the same as the application you wanted to push live. Selenium 2 APIs yet contain Selenium RC APIs but Selenium 3 would completely get rid of Selenium RC APIs. If you are still using Selenium RC then you must migrate to Selenium WebDriver.\nIDE IDE is a Firefox plugin which can be used to record test steps in Firefox itself. Selenium IDE can be used to generate quick and dirty test code in a variety of programming languages (i.e. C#, Java, Python, and Ruby). Given the maintainability of code generated through Selenium IDE, it is not recommended to use it for anything more than getting acquainted with element locators or generating throw away code. We\u0026rsquo;re sure that once you get used to the WebDriver API, you will never use Selenium IDE.\nGrid Soon after development of WebDriver tests, you may face a need of running your tests on multiple browser and operating system combinations. This is where Grid comes to the rescue.\nHTML Runner This tool allows you to run Test Suites from the command line. Test Suites are HTML exports from Selenium IDE or compatible tools. HTML Runner\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/new_site/",
	"title": "Selenium Documentation",
	"tags": [],
	"description": "",
	"content": " The Selenium Browser Automation Project Selenium is an umbrella project for a range of tools and libraries that enable and support the automation of web browsers.\nIt provides extensions to emulate user interaction with browsers, a distribution server for scaling browser allocation, and the infrastructure for implementations of the W3C WebDriver specification that lets you write interchangeable code for all major web browsers.\nThis project is made possible by volunteer contributors who have put in thousands of hours of their own time, and made the source code freely available for anyone to use, enjoy, and improve.\nSelenium brings together browser vendors, engineers, and enthusiasts to further an open discussion around automation of the web platform. The project organises an annual conference to teach and nurture the community.\nAt the core of Selenium is WebDriver, an interface to write instruction sets that can be run interchangeably in many browsers. Here is one of the simplest instructions you can make:\nJava Python C# Ruby JavaScript import org.openqa.selenium.By; import org.openqa.selenium.Keys; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.firefox.FirefoxDriver; import org.openqa.selenium.support.ui.WebDriverWait; import static org.openqa.selenium.support.ui.ExpectedConditions.presenceOfElementLocated; public class HelloSelenium { public static void main(String[] args) { WebDriver driver = new FirefoxDriver(); WebDriverWait wait = new WebDriverWait(driver, 10); try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;); driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;cheese\u0026#34; + Keys.ENTER); WebElement firstResult = wait.until(presenceOfElementLocated(By.cssSelector(\u0026#34;h3\u0026gt;a\u0026#34;))); System.out.println(firstResult.getText()); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.common.keys import Keys from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support.expected_conditions import presence_of_element_located #This example requires Selenium WebDriver 3.13 or newer with webdriver.Firefox() as driver: wait = WebDriverWait(driver, 10) driver.get(\u0026#34;https://google.com/ncr\u0026#34;) driver.find_element_by_name(\u0026#34;q\u0026#34;).send_keys(\u0026#34;cheese\u0026#34; + Keys.RETURN) first_result = wait.until(presence_of_element_located((By.CSS_SELECTOR, \u0026#34;h3\u0026gt;a\u0026#34;))) print(first_result.text)   using System; using OpenQA.Selenium; using OpenQA.Selenium.Firefox; using OpenQA.Selenium.Support.UI; using SeleniumExtras.WaitHelpers; class HelloSelenium { static void Main() { using (IWebDriver driver = new FirefoxDriver()) { WebDriverWait wait = new WebDriverWait(driver, TimeSpan.FromSeconds(10)); driver.Navigate().GoToUrl(\u0026#34;https://www.google.com/ncr\u0026#34;); driver.FindElement(By.Name(\u0026#34;q\u0026#34;)).SendKeys(\u0026#34;cheese\u0026#34; + Keys.Enter); IWebElement firstResult = wait.Until(ExpectedConditions.ElementExists(By.CssSelector(\u0026#34;h3\u0026gt;a\u0026#34;))); Console.WriteLine(firstResult.Text); } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox wait = Selenium::WebDriver::Wait.new(timeout: 10) begin driver.get \u0026#39;https://google.com/ncr\u0026#39; driver.find_element(name: \u0026#39;q\u0026#39;).send_keys \u0026#39;cheese\u0026#39;, :return first_result = wait.until { driver.find_element(css: \u0026#39;h3\u0026gt;a\u0026#39;) } puts first_result.text ensure driver.quit end   const {Builder, By, Key, until} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); try { await driver.get(\u0026#39;https://www.google.com/ncr\u0026#39;); await driver.findElement(By.name(\u0026#39;q\u0026#39;)).sendKeys(\u0026#39;cheese\u0026#39;, Key.RETURN); let firstResult = await driver.wait(until.elementLocated(By.css(\u0026#39;h3\u0026gt;a\u0026#39;)),10000); console.log(await firstResult.getText()); } finally { await driver.quit(); } })();     See the Quick Tour for a full explanation of what goes on behind the scenes when you run this code. You should continue on to the narrative documentation to understand how you can install and successfully use Selenium as a test automation tool, and scaling simple tests like this to run in large, distributed environments on multiple browsers, on several different operating systems.\nGetting started If you are new to Selenium, we have a few resources that can help you get up to speed right away.\n Quick tour  WebDriver Remote Control IDE Grid HTML Runner   "
},
{
	"uri": "https://seleniumhq.github.io/docs/new_site/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]