[
{
	"uri": "https://seleniumhq.github.io/docs/new_site/getting_started_with_webdriver/browsers/",
	"title": "Browsers",
	"tags": [],
	"description": "",
	"content": " Consumer browsers The Selenium framework officially supports the following browsers:\n   Browser Maintainer Versions Supported     Chromium Chromium All versions   Firefox Mozilla 54 and newer   Internet Explorer Selenium 6 and newer   Opera Opera Chromium / Presto 10.5 and newer   Safari Apple 10 and newer    Specialised browsers There is also a set of specialized browsers out there typically used in development environments. We can make use of some of these browsers for automation purposes also, and Selenium ties in support for the following specialized drivers:\n   Driver Name Purpose Maintainer     HtmlUnitDriver Headless browser emulator backed by Rhino Selenium project    "
},
{
	"uri": "https://seleniumhq.github.io/docs/new_site/getting_started/",
	"title": "Getting Started",
	"tags": [],
	"description": "",
	"content": " Getting Started If you are new to Selenium, we have a few resources that can help you get up to speed right away.\n Quick tour  WebDriver Remote Control IDE Grid HTML Runner   "
},
{
	"uri": "https://seleniumhq.github.io/docs/new_site/selenium_installation/installing_selenium_libraries/",
	"title": "Installing Selenium libraries",
	"tags": [],
	"description": "",
	"content": " Installing Selenium libraries First you need to install the Selenium bindings for your automation project. The installation process for libraries depends on the language you choose to use.\nJava Installation of Selenium libraries for Java can be done using Maven. Add the selenium-java dependency in your project pom.xml:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.X\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; The selenium-java dependency supports running your automation project with all Selenium supported browsers. If you want to run tests only in a specific browser, you can add the dependency for that browser in your pom.xml file. For example, you should add following dependency in your pom.xml file to run your tests only in Firefox:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-firefox-driver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.X\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; In a similar manner, if you want to run tests only in Chrome, you should add the following dependency:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-chrome-driver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.X\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Python Installation of Selenium libraries for Python can be done using pip:\npip install selenium Alternatively you can download the PyPI source archive (selenium-x.x.x.tar.gz) and install it using setup.py:\npython setup.py install C Installation of Selenium libraries for C# can be done using NuGet:\n# Using package manager Install-Package Selenium.WebDriver # or using .Net CLI dotnet add package Selenium.WebDriver Ruby Installation of Selenium libraries for Ruby can be done using gem:\ngem install selenium-webdriver JavaScript Installation of Selenium libraries for JavaScript can be done using npm:\nnpm install selenium-webdriver"
},
{
	"uri": "https://seleniumhq.github.io/docs/new_site/introduction/the_selenium_project_and_tools/",
	"title": "The Selenium project and tools",
	"tags": [],
	"description": "",
	"content": " Selenium controls web browsers Selenium is many things, but at its core it\u0026rsquo;s a toolset for web browser automation that uses the best techniques available to remotely control browser instances and emulate a user\u0026rsquo;s interaction with the browser.\nIt allows users to simulate common activities performed by end-users; entering text into fields, selecting drop-down values and checking boxes, and clicking links in documents. It also provides many other controls such as mouse movement, arbitrary JavaScript execution, and much more.\nAlthough used primarily for front-end testing of websites, Selenium is at its core a browser user agent library. The interfaces are ubiquitous to their application, which encourages composition with other libraries to suit your purpose.\nOne interface to rule them all One of the project\u0026rsquo;s guiding principles is to support a common interface for all (major) browser technologies. Web browsers are incredibly complex, highly engineered applications, performing their operations in completely different ways but which frequently look the same while doing so. Even though the text is rendered in the same fonts, the images are displayed in the same place and the links take you to the same destination. What is happening underneath is as different as night and day. Selenium “abstracts” these differences, hiding their details and intricacies from the person writing the code. This allows you to write several lines of code to perform a complicated workflow, but these same lines will execute on Firefox, Internet Explorer, Chrome, and all other supported browsers.\nTools and support Selenium\u0026rsquo;s minimalist design approach gives it versatility to be included as a component in bigger applications. The surrounding infrastructure provided under the Selenium umbrella gives you the tools to put together your own grid of browsers so tests can be run on different browsers and multiple operating systems across a range of machines.\nImagine a bank of computers in your server room or data centre all firing up browsers at the same time hitting your site\u0026rsquo;s links, forms, and tables\u0026mdash;testing your application 24 hours a day. Through the simple programming interface provided for the most common languages, these tests will run tirelessly in parallel, reporting back to you when errors occur.\nIt\u0026rsquo;s an aim to help make this a reality for you, by providing users with tools and documentation to not only control browsers, but to make it easy to scale and deploy such grids.\nWho uses Selenium Many of the most important companies in the world have adopted Selenium for their browser-based testing, often replacing years-long efforts involving other proprietary tools. As it has grown in popularity, so have its requirements and challenges multiplied.\nAs the web becomes more complicated and new technologies are added to websites, it\u0026rsquo;s the mission of this project to keep up with them where possible. Being an open source project, this support is provided through the generous donation of time from many volunteers, every one of which has a “day job”.\nAnother mission of the project is to encourage more volunteers to partake in this effort, and build a strong community so that the project can continue to keep up with emerging technologies and remain a dominant platform for functional test automation.\nHistory When Selenium 1 was released in 2004, it was out of the necessity to reduce time spent manually verifying consistent behaviour in the front-end of a web application. It made use of what tools were available at the time, and relied heavily on the injection of JavaScript to the web page under test to emulate a user\u0026rsquo;s interaction.\nWhilst JavaScript is a good tool to let you introspect the properties of the DOM and to do certain client-side observations that you would otherwise not be able to do, it falls short on the ability to naturally replicate a user\u0026rsquo;s interactions as if the mouse and keyboard are being used.\nSince then, Selenium has grown and matured a lot, into a tool widely used by many\u0026mdash;if not most\u0026mdash;of the largest organisations around the world. Selenium has gone from a homebrewed test automation toolkit developed at Thoughtworks for a niché audience and a specific use case, to the world\u0026rsquo;s de facto browser automation library.\nJust as Selenium RC made use of the tools of the trade available at the time, Selenium WebDriver drives that tradition on by taking the browser interaction part to the browser vendor\u0026rsquo;s home turf, and asking them to take responsibility of the backend, browser-facing implementations. Recently this work has evolved into a W3C standardisation process where the goal is to turn the WebDriver component in Selenium into the du jeur remote control library for user agents.\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/new_site/webdriver/understanding_the_componets/",
	"title": "Understanding the componets",
	"tags": [],
	"description": "",
	"content": " Building a test suite using WebDriver will require you to understand and effectively use a number of different components. As with everything in software, different people use different terms for the same idea. Below is a breakdown of how terms are used in this description.\nTerminology  API: Application Programming Interface. This is the set of \u0026ldquo;commands\u0026rdquo; you use to manipulate WebDriver. Library: A code module which contains the APIs and the code necessary to implement them. Libraries are specific to each language binding, eg .jar files for Java, .dll files for .NET, etc. Driver: Responsible for controlling the actual browser. Most drivers are created by the browser vendors themselves. Drivers are generally executable modules that run on the system with the browser itself, not on the system executing the test suite. (Although those may be the same system.) NOTE: Some people refer to the drivers as proxies. Framework: An additional library used as a support for WebDriver suites. These frameworks may be test frameworks such as JUnit or NUnit. They may also be frameworks supporting natural language features such as Cucumber or Robotium. Frameworks may also be written and used for things such as manipulating or configuring the system under test, data creation, test oracles, etc.  The Parts and Pieces At its minimum, WebDriver talks to a browser through a driver. Communication is two way: WebDriver passes commands to the browser through the driver, and receives information back via the same route.\nThe driver is specific to the browser, such as ChromeDriver for Google\u0026rsquo;s Chrome/Chromium, GeckoDriver for Mozilla\u0026rsquo;s Firefox, etc. The driver runs on the same system as the browser. This may, or may not be, the same system where the tests themselves are executing.\nThis simple example above is direct communication. Communication to the browser may also be remote communication through Selenium Server or RemoteWebDriver. RemoteWebDriver runs on the same system as the driver and the browser.\nRemote communication can also take place using Selenium Server or Selenium Grid, both of which in turn talk to the driver on the host system\nWhere Frameworks fit in WebDriver has one job and one job only: communicate with the browser via any of the methods above. WebDriver doesn\u0026rsquo;t know a thing about testing: it doesn\u0026rsquo;t know how to compare things, assert pass or fail, and it certainly doesn\u0026rsquo;t know a thing about reporting or Given/When/Then grammar.\nThis is where various frameworks come in to play. At a minimum you\u0026rsquo;ll need a test framework that matches the language bindings, eg NUnit for .NET, JUnit for Java, RSpec for Ruby, etc.\nThe test framework is responsible for running and executing your WebDriver and related steps in your tests. As such, you can think of it looking akin to the following image.\nNatural language frameworks/tools such as Cucumber may exist as part of that Test Framework box in the figure above, or they may wrap the Test Framework entirely in their own implementation.\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/new_site/webdriver/driver_requirements/",
	"title": "Driver requirements",
	"tags": [],
	"description": "",
	"content": " Through WebDriver, Selenium supports all major browsers on the market such as Chrom(ium), Firefox, Internet Explorer, Opera, and Safari. Where possible, WebDriver drives the browser using the browser\u0026rsquo;s built-in support for automation, although not all browsers have official support for remote control.\nWebDriver\u0026rsquo;s aim is to emulate a real user\u0026rsquo;s interaction with the browser as closely as possible. This is possible at varying levels in different browsers. For more details on the different driver idiosyncracies, please see Driver Idiosyncracies.\nEven though all the drivers share a single user-facing interface for controlling the browser, they have slightly different ways of setting up browser sessions. Since many of the driver implementations are provided by third parties, they are not included in the standard Selenium distribution.\nDriver instantiation, profile management, and various browser specific settings are examples of parameters that have different requirements depending on the browser. This section explains the basic requirements for getting you started with the different browsers.\nAdding Executables to your PATH Most drivers require an extra executable for Selenium to communicate with the browser. You can manually specify where the executable lives before starting WebDriver, but this can make your tests less portable, as the executables will need to be in the same place on every machine, or included within your test code repository.\nBy adding a folder containing WebDriver\u0026rsquo;s binaries to your system\u0026rsquo;s path, Selenium will be able to locate the additional binaries without requiring your test code to locate the exact location of the driver.\n Create a directory to place the executables in, like C:\\WebDriver\\bin or /opt/WebDriver/bin Add the directory to your PATH:  On Windows - Open a command prompt as administrator and the run the following command to permanently add the directory to your path for all users on your machine:   setx /m path \u0026#34;%path%;C:\\WebDriver\\bin\\\u0026#34;  Bash users on macOS and Linux - In a terminal:  export PATH=$PATH:/opt/WebDriver/bin \u0026gt;\u0026gt; ~/.profile  You are now ready to test your changes. Close all open command prompts and open a new one. Type out the name of one of the binaries in the folder you created in the previous step, e.g:  chromedriver  If your PATH is configured correctly, you will see some some output relating to the startup of the driver:  Starting ChromeDriver 2.25.426935 (820a95b0b81d33e42712f9198c215f703412e1a1) on port 9515 Only local connections are allowed. You can regain control of your command prompt by pressing Ctrl + C\nQuick reference    Browser Supported OS Maintained by Download Issue Tracker     Chromium/Chrome Windows/macOS/Linux Google Downloads Issues   Firefox Windows/macOS/Linux Mozilla Downloads Issues   Edge Windows 10 Microsoft Downloads Issues   Internet Explorer Windows Selenium Project Downloads Issues   Safari macOS El Capitan and newer Apple Built in Issues   Opera Windows/macOS/Linux Opera Downloads Issues    Chromium/Chrome To drive Chrome or Chromium, you have to download chromedriver and put it in a folder that is on your system\u0026rsquo;s path.\nOn Linux or macOS, this means modifying the PATH environmental variable. You can see what directories, separated by a colon, make up your system\u0026rsquo;s path by executing the following command:\n$ echo $PATH /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin To include chromedriver on the path if it isn\u0026rsquo;t already, make sure you include the chromedriver binary\u0026rsquo;s parent directory. The following line will set the PATH environmental variable its current content, plus an additional path added after the colon:\n$ export PATH=\u0026#34;$PATH:/path/to/chromedriver\u0026#34; When chromedriver is available on your path, you should be able to execute the chromedriver executable from any directory.\nTo instantiate a Chrome/Chromium session, you can do the following:\nJava Python C# Ruby JavaScript import org.openqa.selenium.WebDriver; import org.openqa.selenium.chrome.ChromeDriver; WebDriver driver = new ChromeDriver();   #Simple assignment from selenium.webdriver import Chrome driver = Chrome() #Or use the context manager from selenium.webdriver import Chrome with Chrome() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; IWebDriver driver = new ChromeDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :chrome   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); const chrome = require(\u0026#39;selenium-webdriver/chrome\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); //your code inside this block })();     Remember that you have to set the path to the chromedriver executable. This is possible using the following line:\nJava Python C# Ruby JavaScript System.setProperty(\u0026#34;webdriver.chrome.driver\u0026#34;, \u0026#34;/path/to/chromedriver\u0026#34;);   Chrome(executable_path=\u0026#39;/path/to/chromedriver\u0026#39;)   new ChromeDriver(\u0026#34;/path/to/chromedriver\u0026#34;);   Selenium::WebDriver::Chrome.driver_path = \u0026#34;/path/to/chromedriver\u0026#34;   chrome.setDefaultService(new chrome.ServiceBuilder(\u0026#39;path/to/chromedriver\u0026#39;).build());     The chromedriver is implemented as a WebDriver remote server that by exposing Chrome\u0026rsquo;s internal automation proxy interface instructs the browser what to do.\nFirefox Starting with Selenium 3, Mozilla has taken over implementation of Firefox Driver, with geckodriver. The new driver for Firefox is called geckodriver and works with Firefox 48 and newer. Since the Firefox WebDriver is under development, the newer the Firefox version the better the support.\nAs geckodriver is the new default way of launching Firefox, you can instantiate Firefox in the same way as Selenium 2:\nJava Python C# Ruby JavaScript import org.openqa.selenium.WebDriver; import org.openqa.selenium.Firefox.FirefoxDriver; WebDriver driver = new FirefoxDriver();   #Simple assignment from selenium.webdriver import Firefox driver = Firefox() #Or use the context manager from selenium.webdriver import Firefox with Firefox() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.Firefox; IWebDriver driver = new FirefoxDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :firefox   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); //your code inside this block })();     If you prefer not to set geckodriver\u0026rsquo;s location using PATH, set the geckodriver binary location programmatically:\nJava Python C# Ruby JavaScript System.setProperty(\u0026#34;webdriver.gecko.driver\u0026#34;, \u0026#34;/path/to/geckodriver\u0026#34;);   Firefox(executable_path=\u0026#39;/path/to/geckodriver\u0026#39;)   new FirefoxDriver(\u0026#34;/path/to/geckodriver\u0026#34;);   Selenium::WebDriver::Firefox.driver_path = \u0026#34;/path/to/geckodriver\u0026#34;   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR      It is also possible to set the property at run time:\nmvn test -Dwebdriver.gecko.driver=/path/to/geckodriver It is currently possible to revert to the older, more feature complete Firefox driver, by installing Firefox 47.0.1 or 45 ESR and specifying a desired capability of marionette as false. Later releases of Firefox are no longer compatible.\nEdge Edge is Microsoft\u0026rsquo;s newest browser, included with Windows 10 and Server 2016. Updates to Edge are bundled with major Windows updates, so you\u0026rsquo;ll need to download a binary which matches the build number of your currently installed build of Windows. The Edge Developer site contains links to all the available binaries. Bugs against the EdgeDriver implementation can be raised with Microsoft. If you\u0026rsquo;d like to run tests against Edge, but aren\u0026rsquo;t running Windows 10, Microsoft offer free VMs for testers on the Edge Developer site.\nJava Python C# Ruby JavaScript import org.openqa.selenium.WebDriver; import org.openqa.selenium.edge.EdgeDriver; WebDriver driver = new EdgeDriver();   #Simple assignment from selenium.webdriver import Edge driver = Edge() #Or use the context manager from selenium.webdriver import Edge with Edge() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.Edge; IWebDriver driver = new EdgeDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :edge   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;MicrosoftEdge\u0026#39;).build(); //your code inside this block })();     If Edge driver is not present in your path, you can set the path using the following line:\nJava Python C# Ruby JavaScript System.setProperty(\u0026#34;webdriver.edge.driver\u0026#34;, \u0026#34;C:/path/to/MicrosoftWebDriver.exe\u0026#34;);   Edge(executable_path=\u0026#39;/path/to/MicrosoftWebDriver.exe\u0026#39;)   new EdgeDriver(\u0026#34;/path/to/MicrosoftWebDriver.exe\u0026#34;);   Selenium::WebDriver::Edge.driver_path = \u0026#34;C:\\path\\to\\MicrosoftWebDriver.exe\u0026#34;   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR      Internet Explorer Internet Explorer was Microsoft\u0026rsquo;s default browser until Windows 10, although it is still included in Windows 10. Internet Explorer Driver is the only driver The Selenium project aims to support the same releases Microsoft considers current. Older releases may work, but will be unsupported.\nWhile the Selenium project provides binaries for both the 32-bit and 64-bit versions of Internet Explorer, there are some limitations with Internet Explorer 10 \u0026amp; 11 with the 64-bit driver, but using the 32-bit driver continues to work well. It should be noted that as Internet Explorer preferences are saved against the logged in user\u0026rsquo;s account, some additional setup is required.\nJava Python C# Ruby JavaScript import org.openqa.selenium.WebDriver; import org.openqa.selenium.ie.InternetExplorerDriver; WebDriver driver = new InternetExplorerDriver();   #Simple assignment from selenium.webdriver import Ie driver = Ie() #Or use the context manager from selenium.webdriver import Ie with Ie() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.IE; IWebDriver driver = new InternetExplorerDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :internet_explorer   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;internet explorer\u0026#39;).build(); //your code inside this block })();     If Internet Explorer driver is not present in your path, you can set the path using the following line:\nJava Python C# Ruby JavaScript System.setProperty(\u0026#34;webdriver.ie.driver\u0026#34;, \u0026#34;C:/path/to/IEDriver.exe\u0026#34;);   Ie(executable_path=\u0026#39;/path/to/IEDriverServer.exe\u0026#39;)   new InternetExplorerDriver(\u0026#34;/path/to/geckodriver\u0026#34;);   Selenium::WebDriver::IE.driver_path = \u0026#34;C:\\path\\to\\IEDriver.exe\u0026#34;   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR      Microsoft also offer a WebDriver binary for Internet Explorer 11 on Windows 7 \u0026amp; 8.1. It has not been updated since 2014 and is based of a draft version of the W3 specification. Jim Evans has an excellent writeup on Microsoft\u0026rsquo;s implementation.\nOpera Current releases of Opera are built on top of the Chromium engine, and WebDriver is now supported via the closed-source Opera Chromium Driver, which can be added to your PATH or as a system property.\nInstantiating a driver session is similar to Firefox and Chromium:\nJava Python C# Ruby JavaScript import org.openqa.selenium.WebDriver; import org.openqa.selenium.opera.OperaDriver; WebDriver driver = new OperaDriver();   #Simple assignment from selenium.webdriver import Opera driver = Opera() #Or use the context manager from selenium.webdriver import Opera with Opera() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.Opera; IWebDriver driver = new OperaDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :opera   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR      Safari Starting with Safari 10 on macOS El Capitan and Sierra, WebDriver support is included with each release of the browser. To enable support:\n Enable the Developer menu from Safari preferences Check the Allow Remote Automation option from with the Develop menu Run the following command from the terminal for the first time and type your password at the prompt to authorise WebDriver  /usr/bin/safaridriver -p 1337\u0026lt;/ You can then start a driver session using:\nJava Python C# Ruby JavaScript import org.openqa.selenium.WebDriver; import org.openqa.selenium.safari.SafariDriver; WebDriver driver = new SafariDriver();   #Simple assignment from selenium.webdriver import Safari driver = Safari() #Or use the context manager from selenium.webdriver import Safari with Safari() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.Safari; IWebDriver driver = new SafariDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :safari   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;safari\u0026#39;).build(); //your code inside this block })();     Those looking to automate Safari on iOS should look to the Appium project. Whilst Safari was previously available for Windows, Apple has long since dropped support, making it a poor choice of test platform.\nMock browsers HtmlUnit HtmlUnit is a \u0026ldquo;GUI-Less browser for Java programs\u0026rdquo;. It models HTML documents and provides an API that allows you to invoke pages, fill out forms, click links, etc. It has JavaScript support and is able to work with AJAX libraries, simulating Chrome, Firefox or Internet Explorer depending on the configuration used. It has been moved to a new location. The source is maintained on svn.\nPhantomJS PhantomJS is a headless browser based on Webkit, albeit a version much older than that used by Google Chrome or Safari. Whilst historically a popular choice, it would now be wise to avoid PhantomJS. The project has been unmaintained since the 5th of August, so whilst the web will continue to change, PhantomJS will not be updated. This was after Google announced the ability to run Chrome headlessly, something also now offered by Mozilla\u0026rsquo;s Firefox.\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/new_site/selenium_installation/installing_webdriver_binaries/",
	"title": "Installing WebDriver binaries",
	"tags": [],
	"description": "",
	"content": " Installing WebDriver binaries To execute your project and control browser you need to have browser-specific WebDriver binaries installed.\nDownload the WebDriver binary supported by your browser and place it in the System PATH.\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/new_site/introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": " Introduction Selenium is an umbrella project for a range of tools and libraries that enable and support the automation of web browsers.\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/new_site/introduction/on_test_automation/",
	"title": "On test automation",
	"tags": [],
	"description": "",
	"content": " First, start by asking yourself whether or not you really need to use a browser. Odds are good that, at some point, if you\u0026rsquo;re working on a complex web application, you will need to open a browser and actually test it.\nFunctional end-user tests such as Selenium tests are expensive to run, however. Furthermore, they typically require substantial infrastructure to be in place to be run effectively. It\u0026rsquo;s a good rule to always ask yourself if what you want to test can be done using more lightweight test approaches such as unit tests or with a lower-level approach.\nOnce you have made the determination that you\u0026rsquo;re in the web browser testing business, and you have your Selenium environment ready to begin writing tests, you will generally perform some combination of three steps:\n Set up the data Perform a discrete set of actions Evaluate the results  You will want to keep these steps as short as possible; one to two operations should be enough much of the time. Browser automation has the reputation of being “flaky”, but in reality that is because users frequently demand too much of it. In later chapters, we will return to techniques you can use to mitigate apparent intermittent problems in tests, in particular on how to overcome race conditions between the browser and WebDriver.\nBy keeping your tests short and using the web browser only when you have absolutely no alternative, you can have many tests with minimal flake.\nA distinct advantage of Selenium tests are their inherent ability to test all components of the application, from backend to frontend, from a user\u0026rsquo;s perspective. So in other words, whilst functional tests may be expensive to run, they also encompass large business-critical portions at one time.\nTesting requirements As mentioned before, Selenium tests can be expensive to run. To what extent depends on the browser you\u0026rsquo;re running the tests against, but historically browsers\u0026rsquo; behaviour has varied so much that it has often been a stated goal to cross-test against multiple browsers.\nSelenium allows you to run the same instructions against multiple browsers on multiple operating systems, but the enumeration of all the possible browsers, their different versions, and the many operating systems they run on will quickly become a non-trivial undertaking.\nLet’s start with an example Larry has written a web site which allows users to order their own custom unicorns.\nThe general workflow (what we\u0026rsquo;ll call the “happy path”) is something like this:\n Create an account Configure their unicorn Add her to the shopping cart Check out and pay Give feedback about their unicorn  It would be tempting to write one grand Selenium script to perform all these operations–many will try. Resist the temptation! Doing so will result in a test that a) takes a long time, b) will be subject to some common issues around page rendering timing issues, and c) is such that if it fails, it won\u0026rsquo;t give you a concise, “glanceable” method for diagnosing what went wrong.\nThe preferred strategy for testing this scenario would be to break it down to a series of independent, speedy tests, each of which has one “reason” to exist.\nLet\u0026rsquo;s pretend you want to test the second step: Configuring your unicorn. It will perform the following actions:\n Create an account Configure a unicorn  Note that we\u0026rsquo;re skipping the rest of these steps, we will test the rest of the workflow in other small, discrete test cases, after we\u0026rsquo;re done with this one.\nTo start off, you need to create an account. Here you have some choices to make:\n Do you want to use an existing account? Do you want to create a new account? Are there any special properties of such a user that need to be taken into account before configuration begins?  Regardless of how you answer this question, the solution is to make it part of the \u0026ldquo;set up the data\u0026rdquo; portion of the test– if Larry has exposed an API which enables you (or anyone) to create and update user accounts, be sure to use that to answer this question– if possible, you want to launch the browser only after you have a user \u0026ldquo;in hand\u0026rdquo;, whose credentials you can just log in with.\nIf each test for each workflow begins with the creation of a user account, many seconds will be added to the execution of each test. Calling an API and talking to a database are quick, “headless” operations that don\u0026rsquo;t require the expensive process of opening a browser, navigating to the right pages, clicking and waiting for the forms to be submitted, etc.\nIdeally, you can address this set-up phase in one line of code, which will execute before any browser is launched:\nJava Python C# Ruby JavaScript // Create a user who has read-only permissions--they can configure a unicorn, // but they do not have payment information set up, nor do they have // administrative privileges. At the time the user is created, its email // address and password are randomly generated--you don\u0026#39;t even need to // know them. User user = UserFactory.createCommonUser(); //This method is defined elsewhere.  // Log in as this user. // Logging in on this site takes you to your personal \u0026#34;My Account\u0026#34; page, so the // AccountPage object is returned by the loginAs method, allowing you to then // perform actions from the AccountPage. AccountPage accountPage = loginAs(user.getEmail(), user.getPassword());   # Create a user who has read-only permissions--they can configure a unicorn, # but they do not have payment information set up, nor do they have # administrative privileges. At the time the user is created, its email # address and password are randomly generated--you don\u0026#39;t even need to # know them. user = user_factory.create_common_user() #This method is defined elsewhere. # Log in as this user. # Logging in on this site takes you to your personal \u0026#34;My Account\u0026#34; page, so the # AccountPage object is returned by the loginAs method, allowing you to then # perform actions from the AccountPage. account_page = login_as(user.get_email(), user.get_password())   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR      As you can imagine, the UserFactory can be extended to provide methods such as createAdminUser(), and createUserWithPayment(). The point is, these two lines of code do not distract you from the ultimate purpose of this test: configuring a unicorn.\nThe intricacies of the Page Object model will be discussed in later chapters, but we will introduce the concept here:\nYour tests should be composed of actions, performed from the user\u0026rsquo;s point of view, within the context of pages in the site. These pages are stored as objects, which will contain specific information about how the web page is composed and how actions are performed– very little of which should concern you as a tester.\nWhat kind of unicorn do you want? You might want pink, but not necessarily. Purple has been quite popular lately. Does she need sunglasses? Star tattoos? These choices, while difficult, are your primary concern as a tester– you need to ensure that your order fulfillment center sends out the right unicorn to the right person, and that starts with these choices.\nNotice that nowhere in that paragraph do we talk about buttons, fields, drop-downs, radio buttons, or web forms. Neither should your tests! You want to write your code like the user trying to solve their problem. Here is one way of doing this (continuing from the previous example):\nJava Python C# Ruby JavaScript // The Unicorn is a top-level Object--it has attributes, which are set here. // This only stores the values; it does not fill out any web forms or interact // with the browser in any way. Unicorn sparkles = new Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS); // Since we\u0026#39;re already \u0026#34;on\u0026#34; the account page, we have to use it to get to the // actual place where you configure unicorns. Calling the \u0026#34;Add Unicorn\u0026#34; method // takes us there. AddUnicornPage addUnicornPage = accountPage.addUnicorn(); // Now that we\u0026#39;re on the AddUnicornPage, we will pass the \u0026#34;sparkles\u0026#34; object to // its createUnicorn() method. This method will take Sparkles\u0026#39; attributes, // fill out the form, and click submit. UnicornConfirmationPage unicornConfirmationPage = addUnicornPage.createUnicorn(sparkles);   # The Unicorn is a top-level Object--it has attributes, which are set here. # This only stores the values; it does not fill out any web forms or interact # with the browser in any way. sparkles = Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS) # Since we\u0026#39;re already \u0026#34;on\u0026#34; the account page, we have to use it to get to the # actual place where you configure unicorns. Calling the \u0026#34;Add Unicorn\u0026#34; method # takes us there. add_unicorn_page = account_page.add_unicorn() # Now that we\u0026#39;re on the AddUnicornPage, we will pass the \u0026#34;sparkles\u0026#34; object to # its createUnicorn() method. This method will take Sparkles\u0026#39; attributes, # fill out the form, and click submit. unicorn_confirmation_page = add_unicorn_page.create_unicorn(sparkles)   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR      Now that you\u0026rsquo;ve configured your unicorn, you need to move on to step 3: making sure it actually worked.\nJava Python C# Ruby JavaScript // The exists() method from UnicornConfirmationPage will take the Sparkles // object--a specification of the attributes you want to see, and compare // them with the fields on the page. Assert.assertTrue(\u0026#34;Sparkles should have been created, with all attributes intact\u0026#34;, unicornConfirmationPage.exists(sparkles));   # The exists() method from UnicornConfirmationPage will take the Sparkles # object--a specification of the attributes you want to see, and compare # them with the fields on the page. assert unicorn_confirmation_page.exists(sparkles), \u0026#34;Sparkles should have been created, with all attributes intact\u0026#34;   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR      Note that the tester still hasn\u0026rsquo;t done anything but talk about unicorns in this code– no buttons, no locators, no browser controls. This method of modelling the application allows you to keep these test-level commands in place and unchanging, even if Larry decides next week that he no longer likes Ruby-on-Rails and decides to re-implement the entire site in the latest Haskell bindings with a Fortran front-end.\nYour page objects will require some small maintenance in order to conform to the site redesign, but these tests will remain the same. Taking this basic design, you will want to keep going through your workflows with the fewest browser-facing steps possible. Your next workflow will involve adding a unicorn to the shopping cart. You will probably want many iterations of this test in order to make sure the cart is keeping its state properly: Is there more than one unicorn in the cart before you start? How many can fit in the shopping cart? If you create more than one with the same name and/or features, will it break? Will it only keep the existing one or will it add another?\nEach time you move through the workflow, you want to try to avoid having to create an account, login as the user, and configure the unicorn. Ideally, you\u0026rsquo;ll be able to create an account and pre-configure a unicorn via the API or database. Then all you have to do is log in as the user, locate Sparkles, and add her to the cart.\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/new_site/getting_started_with_webdriver/third_party_drivers_and_plugins/",
	"title": "Third party drivers and plugins",
	"tags": [],
	"description": "",
	"content": "Selenium can be extended through the use of plugins. Here are a number of plugins created and maintained by third parties. For more information on how to create your own plugin or have it listed, consult the docs.\nPlease note that these plugins are not supported, maintained, hosted, or endorsed by the Selenium project. In addition, be advised that the plugins listed below are not necessarily licensed under the Apache License v.2.0. Some of the plugins are available under another free and open source software license; others are only available under a proprietary license. Any questions about plugins and their license of distribution need to be raised with their respective developer(s).\n   Browser Latest version Changelog Issues Wiki     Google ChromeDriver 2.29 changelog issues wiki    "
},
{
	"uri": "https://seleniumhq.github.io/docs/new_site/webdriver/browser_manipulation/",
	"title": "Browser manipulation",
	"tags": [],
	"description": "",
	"content": " Ruby Ruby is not installed by default on Windows. Download the latest version and run the installer. You can leave all settings at default values, except at the Installation Destination and Optional Tasks screen check Add Ruby executables to your PATH checkbox. To drive any browser, you have to install selenium-webdriver Ruby gem. To install it, open command prompt and type this:\ngem install selenium-webdriver Or, if you use Bundler, add this line to your application\u0026rsquo;s Gemfile:\ngem \u0026#34;selenium-webdriver\u0026#34; And then execute the following command in prompt:\nbundle install Internet Explorer Internet Explorer is installed by default on Windows, so no installation is needed. To drive Internet Explorer on Windows, you have to download the latest Internet Explorer Driver and put the file into a folder that is in PATH. To find out which directories are in PATH, type echo %PATH% in command prompt.\n$ echo %PATH% C:\\Ruby200\\bin;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem C:\\Ruby200\\bin looks like a good place. Unzip IEDriverServer file and move IEDriverServer.exe there.\nThis should open a new Internet Explorer window:\nrequire \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :internet_explorer Browser navigation Navigate to The first thing you will want to do after launching a browser is to open your website. This can be achieved in a single line:\nJava Python C# Ruby JavaScript //Convenient driver.get(\u0026#34;https://www.seleniumhq.org\u0026#34;); //Longer way driver.navigate().to(\u0026#34;https://seleniumhq.github.io/docs/\u0026#34;);   driver.get(\u0026#34;https://www.seleniumhq.org\u0026#34;)   driver.Navigate().GoToUrl(@\u0026#34;http://google.com\u0026#34;);   # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR   await driver.get(\u0026#39;https://seleniumhq.github.io/docs/\u0026#39;);     Get current URL You can read the current URL from the browser\u0026rsquo;s address bar using:\nJava Python C# Ruby JavaScript driver.getCurrentUrl();  driver.current_url  driver.Url;   driver.current_url  await driver.getCurrentUrl();     Back Pressing the browser\u0026rsquo;s back button:\nJava Python C# Ruby JavaScript driver.navigate().back();  driver.back()  driver.Navigate().Back();   driver.navigate.back  await driver.navigate().back();     Forward Pressing the browser\u0026rsquo;s forward button:\nJava Python C# Ruby JavaScript driver.navigate().forward();  driver.forward()  driver.Navigate().Forward();   driver.navigate.forward  await driver.navigate().forward();     Refresh Refresh the current page:\nJava Python C# Ruby JavaScript driver.navigate().refresh();  driver.refresh()  driver.Navigate().Refresh();   driver.navigate.refresh  await driver.navigate().refresh();     Get title You can read the current page title from the browser:\nJava Python C# Ruby JavaScript driver.getTitle();  driver.title  driver.Title;   driver.title  await driver.getTitle();     Windows and tabs WebDriver doesn\u0026rsquo;t make the distinction between windows and tabs. If your site opens a new tab or window, Selenium will let you work with it using a window handle. Each window has a unique identifier which remains persistent in a single session. You can get the window handle of the current window by using:\nJava Python C# Ruby JavaScript driver.getWindowHandle();  driver.current_window_handle  driver.CurrentWindowHandle;   driver.window_handle  await driver.getWindowHandle();     Switching windows or tabs Clicking a link which opens in a new window will focus the new window or tab on screen, but WebDriver will not know which window the Operating System considers active. To work with the new window you will need to switch to it. If you have only two tabs or windows open, and you know which window you start with, by the process of elimination you can loop over both windows or tabs that WebDriver can see, and switch to the one which is not the original.\nJava Python C# Ruby JavaScript //Store the ID of the original window String originalWindow = driver.getWindowHandle(); //Check we don\u0026#39;t have other windows open already assert driver.getWindowHandles().size() == 1; //Click the link which opens in a new window driver.findElement(By.linkText(\u0026#34;new window\u0026#34;)).click(); //Wait for the new window or tab wait.until(numberOfWindowsToBe(2)); //Loop through until we find a new window handle for (String windowHandle : driver.getWindowHandles()) { if(!originalWindow.contentEquals(windowHandle)) { driver.switchTo().window(windowHandle); break; } } //Wait for the new tab to finish loading content wait.until(titleIs(\u0026#34;Selenium documentation\u0026#34;));   from selenium import webdriver from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC # Start the driver with webdriver.Firefox() as driver: # Open URL driver.get(\u0026#34;https://seleniumhq.github.io/docs/wd.html\u0026#34;) # Setup wait for later wait = WebDriverWait(driver, 10) # Store the ID of the original window original_window = driver.current_window_handle # Check we don\u0026#39;t have other windows open already assert len(driver.window_handles) == 1 # Click the link which opens in a new window driver.find_element_by_link_text(\u0026#34;new window\u0026#34;).click() # Wait for the new window or tab wait.until(EC.number_of_windows_to_be(2)) # Loop through until we find a new window handle for window_handle in driver.window_handles: if window_handle != original_window: driver.switch_to.window(window_handle) break # Wait for the new tab to finish loading content wait.until(EC.title_is(\u0026#34;Selenium documentation\u0026#34;))   //Store the ID of the original window string originalWindow = driver.CurrentWindowHandle; //Check we don\u0026#39;t have other windows open already Assert.AreEqual(driver.WindowHandles.Count, 1); //Click the link which opens in a new window driver.FindElement(By.LinkText(\u0026#34;new window\u0026#34;)).Click(); //Wait for the new window or tab wait.Until(wd =\u0026gt; wd.WindowHandles.Count == 2); //Loop through until we find a new window handle foreach(string window in driver.WindowHandles) { if(originalWindow != window) { driver.SwitchTo().Window(window); break; } } //Wait for the new tab to finish loading content wait.Until(wd =\u0026gt; wd.Title == \u0026#34;Selenium documentation\u0026#34;);   #Store the ID of the original window original_window = driver.window_handle #Check we don\u0026#39;t have other windows open already assert(driver.window_handles.length == 1, \u0026#39;Expected one window\u0026#39;) #Click the link which opens in a new window driver.find_element(link: \u0026#39;new window\u0026#39;).click #Wait for the new window or tab wait.until { driver.window_handles.length == 2 } #Loop through until we find a new window handle driver.window_handles.each do |handle| if handle != original_window driver.switch_to.window handle break end end #Wait for the new tab to finish loading content wait.until { driver.title == \u0026#39;Selenium documentation\u0026#39;}   //Store the ID of the original window const originalWindow = await driver.getWindowHandle(); //Check we don\u0026#39;t have other windows open already assert((await driver.getAllWindowHandles()).length === 1); //Click the link which opens in a new window await driver.findElement(By.linkText(\u0026#39;new window\u0026#39;)).click(); //Wait for the new window or tab await driver.wait( async () =\u0026gt; (await driver.getAllWindowHandles()).length === 2, 10000 ); //Loop through until we find a new window handle const windows = await driver.getAllWindowHandles(); windows.forEach(async handle =\u0026gt; { if (handle !== originalWindow) { await driver.switchTo().window(handle); } }); //Wait for the new tab to finish loading content await driver.wait(until.titleIs(\u0026#39;Selenium documentation\u0026#39;), 10000);     Closing a window or tab When you are finished with a window or tab and it is not the last window or tab open in your browser, you should close it and switch back to the window you were using previously. Assuming you followed the code sample in the previous section you will have the previous window handle stored in a variable. Put this together and you will get:\nJava Python C# Ruby JavaScript //Close the tab or window driver.close(); //Switch back to the old tab or window driver.switchTo().window(originalWindow);   #Close the tab or window driver.close() #Switch back to the old tab or window driver.switch_to.window(original_window)   //Close the tab or window driver.Close(); //Switch back to the old tab or window driver.SwitchTo().Window(originalWindow);   #Close the tab or window driver.close #Switch back to the old tab or window driver.switch_to.window original_window   //Close the tab or window await driver.close(); //Switch back to the old tab or window await driver.switchTo().window(originalWindow);     Forgetting to switch back to another window handle after closing a window will leave WebDriver executing on the now closed page, and will trigger a No Such Window Exception. You must switch back to a valid window handle in order to continue execution.\nQuitting the browser at the end of a session When you are finished with the browser session you should call quit, instead of close:\nJava Python C# Ruby JavaScript driver.quit();  driver.quit()  driver.Quit();   driver.quit  await driver.quit();      Quit will:  Close all the windows and tabs associated with that WebDriver session The browser process The background driver process Notify Selenium Grid that the browser is no longer in use so it can be used by another session (if you are using Selenium Grid)   Failure to call quit will leave extra background processes and ports running on your machine which could cause you problems later.\nSome test frameworks offer methods and annotations which you can hook into to tear down at the end of a test.\nJava Python C# Ruby JavaScript /** * Example using JUnit * https://junit.org/junit5/docs/current/api/org/junit/jupiter/api/AfterAll.html */ @AfterAll public static void tearDown() { driver.quit(); }   # We don\u0026#39;t have a Python code sample yet - Help us out and raise a PR    /* Example using Visual Studio\u0026#39;s UnitTesting https://msdn.microsoft.com/en-us/library/microsoft.visualstudio.testtools.unittesting.aspx */ [TestCleanup] public void TearDown() { driver.Quit(); }   # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    /** * Example using Mocha * https://mochajs.org/#hooks */ after(\u0026#39;Tear down\u0026#39;, async function () { await driver.quit(); });     If not running WebDriver in a test context, you may consider using try / finally which is offered by most languages so that an exception will still clean up the WebDriver session.\nJava Python C# Ruby JavaScript try { //WebDriver code here... } finally { driver.quit(); }   try: #WebDriver code here... finally: driver.quit()   try { #WebDriver code here... } finally { driver.Quit(); }   begin #WebDriver code here... ensure driver.quit end   try { //WebDriver code here... } finally { await driver.quit(); }     Python\u0026rsquo;s WebDriver now supports the python context manager, which when using the with keyword can automatically quit the driver at the end of execution.\nwith webdriver.Firefox() as driver: # WebDriver code here... # WebDriver will automatically quit after indentation Frames and Iframes Frames are a now deprecated means of building a site layout from multiple documents on the same domain. You are unlikely to work with them unless you are working with an pre HTML5 webapp. Iframes allow the insertion of a document from an entirely different domain, and are still commonly used.\nIf you need to work with frames or iframes, Webdriver allows you to work with them in the same way. Consider a button within an iframe. If we inspect the element using the browser development tools, we might see the following:\n\u0026lt;div id=\u0026#34;modal\u0026#34;\u0026gt; \u0026lt;iframe id=\u0026#34;buttonframe\u0026#34; name=\u0026#34;myframe\u0026#34; src=\u0026#34;https://seleniumhq.github.io/docs/iframe.html\u0026#34;\u0026gt; \u0026lt;button\u0026gt;Click here\u0026lt;/button\u0026gt; \u0026lt;/iframe\u0026gt; \u0026lt;/div\u0026gt; If it wasn\u0026rsquo;t for the iframe we would expect to click on the button using something like:\nJava Python C# Ruby JavaScript //This won\u0026#39;t work driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click();   # We don\u0026#39;t have a Python code sample yet - Help us out and raise a PR    //This won\u0026#39;t work driver.FindElement(By.TagName(\u0026#34;button\u0026#34;)).Click();   # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    // This won\u0026#39;t work await driver.findElement(By.css(\u0026#39;button\u0026#39;)).click();     However, if there are no buttons outside of the iframe, you might instead get a no such element error. This happens because Selenium is only aware of the elements in the top level document. To interact with the button, we will need to first switch to the frame, in a similar way to how we switch windows. WebDriver offers three ways of switching to a frame.\nUsing a WebElement Switching using a WebElement is the most flexible option. You can find the frame using your preferred selector and switch to it.\nJava Python C# Ruby JavaScript //Store the web element WebElement iframe = driver.findElement(By.cssSelector(\u0026#34;#modal\u0026gt;iframe\u0026#34;)); //Switch to the frame driver.switchTo().frame(iframe); //Now we can click the button driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click();   # We don\u0026#39;t have a Python code sample yet - Help us out and raise a PR    //Store the web element IWebElement iframe = driver.FindElement(By.CssSelector(\u0026#34;#modal\u0026gt;iframe\u0026#34;)); //Switch to the frame driver.SwitchTo().Frame(iframe); //Now we can click the button driver.FindElement(By.TagName(\u0026#34;button\u0026#34;)).Click();   # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    // Store the web element const iframe = await driver.findElement(By.css(\u0026#39;#modal \u0026gt; iframe\u0026#39;)); // Switch to the frame await driver.switchTo().frame(iframe); // Now we can click the button await driver.findElement(By.css(\u0026#39;button\u0026#39;)).click();     Using a name or ID If your frame or iframe has an id or name attribute, this can be used instead. If the name or ID is not unique on the page, then the first one found will be switched to.\nJava Python C# Ruby JavaScript //Using the ID driver.switchTo().frame(\u0026#34;buttonframe\u0026#34;); //Or using the name instead driver.switchTo().frame(\u0026#34;myframe\u0026#34;); //Now we can click the button driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click();   # We don\u0026#39;t have a Python code sample yet - Help us out and raise a PR    //Using the ID driver.SwitchTo().Frame(\u0026#34;buttonframe\u0026#34;); //Or using the name instead driver.SwitchTo().Frame(\u0026#34;myframe\u0026#34;); //Now we can click the button driver.FindElement(By.TagName(\u0026#34;button\u0026#34;)).Click();   # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    // Using the ID await driver.switchTo().frame(\u0026#39;buttonframe\u0026#39;); // Or using the name instead await driver.switchTo().frame(\u0026#39;myframe\u0026#39;); // Now we can click the button await driver.findElement(By.css(\u0026#39;button\u0026#39;)).click();     Using an index It is also possible to use the index of the frame, such as can be queried using window.frames in JavaScript.\nJava Python C# Ruby JavaScript // Switches to the second frame driver.switchTo().frame(1);   # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    // Switches to the second frame driver.SwitchTo().Frame(1);   # We don\u0026#39;t have a Python code sample yet - Help us out and raise a PR    // Switches to the second frame await driver.switchTo().frame(1);     Leaving a frame To leave an iframe or frameset, switch back to the default content like so:\nJava Python C# Ruby JavaScript // Return to the top level driver.switchTo().defaultContent();   # We don\u0026#39;t have a Python code sample yet - Help us out and raise a PR    // Return to the top level driver.SwitchTo().DefaultContent();   # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    // Return to the top level await driver.switchTo().defaultContent();     Window management Screen resolution can impact how your web application renders, so WebDriver provides mechanisms for moving and resizing the browser window.\nGet window size Fetches the size of the browser window in pixels.\nJava Python C# Ruby JavaScript //Access each dimension individually int width = driver.manage().window().getSize().getWidth(); int height = driver.manage().window().getSize().getHeight(); //Or store the dimensions and query them later Dimension size = driver.manage().window().getSize(); int width1 = size.getWidth(); int height1 = size.getHeight();   //Access each dimension individually width = driver.get_window_size().get(\u0026#34;width\u0026#34;) height = driver.get_window_size().get(\u0026#34;height\u0026#34;) //Or store the dimensions and query them later size = driver.get_window_size() width1 = size.get(\u0026#34;width\u0026#34;) height1 = size.get(\u0026#34;height\u0026#34;)   //Access each dimension individually int width = driver.Manage().Window.Size.Width; int height = driver.Manage().Window.Size.Height; //Or store the dimensions and query them later System.Drawing.Size size = driver.Manage().Window.Size; int width1 = size.Width; int height1 = size.Height;   # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    // Access each dimension individually const { width, height } = await driver.manage().window().getRect(); // Or store the dimensions and query them later const rect = await driver.manage().window().getRect(); const width1 = rect.width; const height1 = rect.height;     Set window size Restores the window and sets the window size. Java Python C# Ruby JavaScript driver.manage().window().setSize(new Dimension(1024, 768));  driver.set_window_size(1024, 768)  driver.Manage().Window.Size = new Size(1024, 768);   driver.set_window_size(1024,768)  await driver.manage().window().setRect({ width: 1024, height: 768 });    \nGet window position Fetches the coordinates of the top left coordinate of the browser window.\nJava Python C# Ruby JavaScript // Access each dimension individually int x = driver.manage().window().getPosition().getX(); int y = driver.manage().window().getPosition().getY(); // Or store the dimensions and query them later Point position = driver.manage().window().getPosition(); int x1 = position.getX(); int y1 = position.getY();   // Access each dimension individually x = driver.get_window_position().get(\u0026#39;x\u0026#39;) y = driver.get_window_position().get(\u0026#39;y\u0026#39;) // Or store the dimensions and query them later position = driver.get_window_position() x1 = position.get(\u0026#39;x\u0026#39;) y1 = position.get(\u0026#39;y\u0026#39;)   //Access each dimension individually int x = driver.Manage().Window.Position.X; int y = driver.Manage().Window.Position.Y; //Or store the dimensions and query them later Point position = driver.Manage().Window.Position; int x1 = position.X; int y1 = position.Y;   # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    // Access each dimension individually const { x, y } = await driver.manage().window().getRect(); // Or store the dimensions and query them later const rect = await driver.manage().window().getRect(); const x1 = rect.x; const y1 = rect.y;     Set window position Moves the window to the chosen position.\nJava Python C# Ruby JavaScript // Move the window to the top left of the primary monitor driver.manage().window().setPosition(new Point(0, 0));   // Move the window to the top left of the primary monitor driver.set_window_position(0, 0)   // Move the window to the top left of the primary monitor driver.Manage().Window.Position = new Point(0, 0);   # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    // Move the window to the top left of the primary monitor await driver.manage().window().setRect({ x: 0, y: 0 });     Maximise window Enlarges the window. For most operating systems, the window will fill the screen, without blocking the operating system\u0026rsquo;s own menus and toolbars.\nJava Python C# Ruby JavaScript driver.manage().window().maximize();  driver.maximize_window()  driver.Manage().Window.Maximize();   # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    await driver.manage().window().maximize();     Fullscreen window Fills the entire screen, similar to pressing F11 in most browsers.\nJava Python C# Ruby JavaScript driver.manage().window().fullscreen();  driver.fullscreen_window()  driver.Manage().Window.FullScreen();   # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    await driver.manage().window().fullscreen();     "
},
{
	"uri": "https://seleniumhq.github.io/docs/new_site/selenium_installation/installing_standalone_server/",
	"title": "Installing Standalone server",
	"tags": [],
	"description": "",
	"content": " Installing Standalone server If you plan to use Grid then you should download the selenium-server-standalone JAR file. The selenium-server-standalone jar is never uploaded, but all the components are available via selenium-server. The standalone JAR contains everything, including the remote Selenium server and the client-side bindings. This means that if you use the selenium-server-standalone jar in your project, then you don\u0026rsquo;t have to add selenium-java or a browser specific jar.\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-server\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.X\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;"
},
{
	"uri": "https://seleniumhq.github.io/docs/new_site/getting_started_with_webdriver/locating_elements/",
	"title": "Locating elements",
	"tags": [],
	"description": "",
	"content": " Locating one element One of the most fundamental techniques to learn when using WebDriver is how to find elements on the page. WebDriver offers a number of built-in selector types, amongst them finding an element by its ID attribute:\nJava Python C# Ruby JavaScript WebElement cheese = driver.findElement(By.id(\u0026#34;cheese\u0026#34;));   driver.find_element_by_id(\u0026#34;cheese\u0026#34;)   IWebElement element = driver.FindElement(By.Id(\u0026#34;cheese\u0026#34;));   driver.find_element(id: \u0026#34;cheese\u0026#34;)   const cheese = await driver.findElement(By.id(\u0026#39;cheese\u0026#39;));     As seen in the example, locating elements in WebDriver is done on the WebDriver instance object. The findElement(By) method returns another fundamental object type, the WebElement.\n WebDriver represents the browser WebElement represents a particular DOM node (a control, e.g. a link or input field, etc.)  Once you have a reference to a web element that\u0026rsquo;s been “found”, you can narrow the scope of your search by using the same call on that object instance:\nJava Python C# Ruby JavaScript WebElement cheese = driver.findElement(By.id(\u0026#34;cheese\u0026#34;)); WebElement cheddar = cheese.findElement(By.id(\u0026#34;cheddar\u0026#34;));   cheese = driver.find_element_by_id(\u0026#34;cheese\u0026#34;) cheddar = cheese.find_elements_by_id(\u0026#34;cheddar\u0026#34;)   IWebElement cheese = driver.FindElement(By.Id(\u0026#34;cheese\u0026#34;)); IWebElement cheddar = cheese.FindElement(By.Id(\u0026#34;cheddar\u0026#34;));   cheese = driver.find_element(id: \u0026#34;cheese\u0026#34;) cheddar = cheese.find_elements(id: \u0026#34;cheddar\u0026#34;)   const cheese = await driver.findElement(By.id(\u0026#39;cheese\u0026#39;)); const cheddar = await cheese.findElement(By.id(\u0026#39;cheddar\u0026#39;));     You can do this because both the WebDriver and WebElement types implement the SearchContext interface. In WebDriver, this is known as a role-based interface. Role-based interfaces allow you to determine whether a particular driver implementation supports a given feature. These interfaces are clearly defined and try to adhere to having only a single role of responsibility. You can read more about WebDriver\u0026rsquo;s design and what roles are supported in which drivers in the Some Other Section Which Must Be Named. Consequently, the By interface used above also supports a number of additional locator strategies. A nested lookup might not be the most effective cheese location strategy since it requires two separate commands to be issued to the browser; first searching the DOM for an element with ID “cheese”, then a search for “cheddar” in a narrowed context.\nTo improve the performance slightly, we should try to use a more specific locator: WebDriver supports looking up elements by CSS locators, allowing us to combine the two previous locators into one search:\nJava Python C# Ruby JavaScript driver.findElement(By.cssSelector(\u0026#34;#cheese #cheddar\u0026#34;));   cheddar = driver.find_element_by_css_selector(\u0026#34;#cheese #cheddar\u0026#34;)   driver.FindElement(By.CssSelector(\u0026#34;#cheese #cheddar\u0026#34;));   mucho_cheese = driver.find_elements(css: \u0026#34;#cheese #cheddar\u0026#34;)   const cheddar = await driver.findElement(By.css(\u0026#39;#cheese #cheddar\u0026#39;));     Locating multiple elements It\u0026rsquo;s possible that the document we are working with may turn out to have an ordered list of the cheese we like the best:\n\u0026lt;ol id=cheese\u0026gt; \u0026lt;li id=cheddar\u0026gt;… \u0026lt;li id=brie\u0026gt;… \u0026lt;li id=rochefort\u0026gt;… \u0026lt;li id=camembert\u0026gt;… \u0026lt;/ul\u0026gt; Since more cheese is undisputably better, and it would be cumbersome to have to retrieve each of the items individually, a superior technique for retrieving cheese is to make use of the pluralized version findElements(By). This method returns a collection of web elements. If only one element is found, it will still return a collection (of one element). If no elements match the locator, an empty list will be returned.\nJava Python C# Ruby JavaScript List\u0026lt;WebElement\u0026gt; muchoCheese = driver.findElements(By.cssSelector(\u0026#34;#cheese li\u0026#34;));   mucho_cheese = driver.find_elements_by_css_selector(\u0026#34;#cheese li\u0026#34;)   IReadOnlyList\u0026lt;IWebElement\u0026gt; muchoCheese = driver.FindElements(By.CssSelector(“#cheese li”));   mucho_cheese = driver.find_elements(css: \u0026#34;#cheese li\u0026#34;)   const muchoCheese = await driver.findElements(By.css(\u0026#39;#cheese li\u0026#39;));     Element selection strategies There are eight different built-in element location strategies in WebDriver:\n   Locator Description     class name Locates elements whose class name contains the search value (compound class names are not permitted)   css selector Locates elements matching a CSS selector   id Locates elements whose ID attribute matches the search value   name Locates elements whose NAME attribute matches the search value   link text Locates anchor elements whose visible text matches the search value   partial link text Locates anchor elements whose visible text matches the search value   tag name Locates elements whose tag name matches the search value   xpath Locates elements matching an XPath expression    Tips on using selectors In general, if HTML IDs are available, unique, and consistently predictable, they are the preferred method for locating an element on a page. They tend to work very quickly, and forego much processing that comes with complicated DOM traversals.\nIf unique IDs are unavailable, a well-written CSS selector is the preferred method of locating an element. XPath works as well as CSS selectors, but the syntax is complicated and frequently difficult to debug. Though XPath selectors are very flexible, they\u0026rsquo;re typically not performance tested by browser vendors and tend to be quite slow.\nSelection strategies based on link text and partial link text have drawbacks in that they only work on link elements. Additionally, they call down to XPath selectors internally in WebDriver.\nTag name can be a dangerous way to locate elements. There are frequently multiple elements of the same tag present on the page. This is mostly useful when calling the findElements(By) method which returns a collection of elements.\nThe recommendation is to keep your locators as compact and readable as possible. Asking WebDriver to traverse the DOM structure is an expensive operation, and the more you can narrow the scope of your search, the better.\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/new_site/selenium_installation/",
	"title": "Selenium installation",
	"tags": [],
	"description": "",
	"content": " Selenium Installation Selenium setup is quite different from the setup of other commercial tools. To use Selenium in your automation project you need to install the language bindings libraries for your language of choice. In addition you will need WebDriver binaries for the browsers you want to automate and run test on.\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/new_site/introduction/types_of_testing/",
	"title": "Types of testing",
	"tags": [],
	"description": "",
	"content": "TODO: Add paragraphs about acceptance testing, performance testing, load testing, regression testing, test driven development, and/or behavior-driven development (JBehave, Capybara, \u0026amp; Robot Framework), with how they relate to Selenium.\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/new_site/introduction/about_this_documentation/",
	"title": "About this documentation",
	"tags": [],
	"description": "",
	"content": "These docs, like the code itself, are maintained 100% by volunteers within the Selenium community. Many have been using it since its inception, but many more have only been using it for a short while, and have given their time to help improve the on-boarding experience for new users.\nIf there is an issue with the documentation, we want to know! The best way to communicate an issue is to visit https://github.com/seleniumhq/docs/issues and search to see whether or not the issue has been filed already. If not, feel free to open one!\nMany members of the community frequent the #selenium IRC channel at irc.freenode.net. Feel free to drop in and ask questions and if you get help which you think could be of use within these documents, be sure to add your contribution! We can update these documents, but it\u0026rsquo;s much easier for everyone when we get contributions from outside the normal committers.\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/new_site/getting_started_with_webdriver/",
	"title": "Getting started with WebDriver",
	"tags": [],
	"description": "",
	"content": " Getting started with WebDriver Selenium supports automation of all the major browsers in the market through the use of WebDriver. WebDriver is an API and protocol that defines a language-neutral interface for controlling the behaviour of web browsers. Each browser is backed by a specific WebDriver implementation, called a driver. The driver is the component responsible for delegating down to the browser, and handles communication to and from Selenium and the browser.\nThis separation is part of a conscious effort to have browser vendors take responsibility for the implementation for their browsers. Selenium makes use of these third party drivers where possible, but also provides its own drivers maintained by the project for the cases when this is not a reality.\nThe Selenium framework ties all of these pieces together through a user-facing interface that enables the different browser backends to be used transparently, enabling cross-browser and cross-platform automation.\nMore details about drivers can be found in Driver Idiosyncrasies.\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/new_site/getting_started_with_webdriver/performing_actions_on_the_aut/",
	"title": "Performing actions on the AUT*",
	"tags": [],
	"description": "",
	"content": " You can set an element\u0026rsquo;s text using the sendKeys method as follows:\nJava Python C# Ruby JavaScript String name = \u0026#34;Charles\u0026#34;; driver.findElement(By.name(\u0026#34;name\u0026#34;)).sendKeys(name);   name = \u0026#34;Charles\u0026#34; driver.find_element_by_name(\u0026#34;name\u0026#34;).send_keys(name)   string name = \u0026#34;Charles\u0026#34;; driver.FindElement(By.Name(\u0026#34;name\u0026#34;)).SendKeys(name);   name = \u0026#34;Charles\u0026#34; driver.find_element(name: \u0026#34;name\u0026#34;).send_keys(name)   const name = \u0026#34;Charles\u0026#34;; await driver.findElement(By.name(\u0026#39;name\u0026#39;)).sendKeys(name);     Some web applications use JavaScript libraries to add drag-and-drop functionality. The following is a basic example of dragging one element onto another element:\nJava Python C# Ruby JavaScript WebElement source = driver.findElement(By.id(\u0026#34;source\u0026#34;)); WebElement target = driver.findElement(By.id(\u0026#34;target\u0026#34;)); new Actions(driver).dragAndDrop(source, target).build().perform();   source = driver.find_element_by_id(\u0026#34;source\u0026#34;) target = driver.find_element_by_id(\u0026#34;target\u0026#34;) ActionChains(driver).drag_and_drop(source, target).perform()   IWebElement source = driver.FindElement(By.Id(\u0026#34;source\u0026#34;)); IWebElement target = driver.FindElement(By.Id(\u0026#34;target\u0026#34;)); new Actions(driver).DragAndDrop(source, target).Build().Perform();   source = driver.find_element(id: \u0026#34;source\u0026#34;) target = driver.find_element(id: \u0026#34;target\u0026#34;) driver.action.drag_and_drop(source, target).perform   const actions = driver.actions({bridge: true}); const source = await driver.findElement(By.id(\u0026#39;source\u0026#39;)); const target = await driver.findElement(By.id(\u0026#39;target\u0026#39;)); await actions.dragAndDrop(source, target).perform();     Clicking on an element You can click on an element using the click method:\nJava Python C# Ruby JavaScript driver.findElement(By.cssSelector(\u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;)).click();   driver.find_element_by_css_selector(\u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;).click()   driver.FindElement(By.CssSelector(\u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;)).Click();   driver.find_element(css: \u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;).click   await driver.findElement(By.css(\u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;)).click();     *AUT: Application under test\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/new_site/webdriver/",
	"title": "WebDriver",
	"tags": [],
	"description": "",
	"content": " WebDriver The biggest change in Selenium recently has been the inclusion of the WebDriver API. Driving a browser natively as a user would either locally or on a remote machine using the Selenium server, it marks a leap forward in terms of browser automation.\nSelenium WebDriver fits in the same role as RC did, and has incorporated the original 1.x bindings. It refers to both the language bindings and the implementations of the individual browser controlling code. This is commonly referred to as just WebDriver or sometimes as Selenium 2.\nSelenium 1.0 + WebDriver = Selenium 2.0\n WebDriver is designed in a simpler and more concise programming interface along with addressing some limitations in the Selenium-RC API.\n WebDriver is a compact object-oriented API when compared to Selenium 1.0.\n It drives the browser much more effectively and overcomes the limitations of Selenium 1 that affected our functional test coverage, like the file upload or download, pop-ups, and dialogs barrier.\n WebDriver overcomes the limitation of Selenium RC\u0026rsquo;s single-host origin policy.\n  "
},
{
	"uri": "https://seleniumhq.github.io/docs/new_site/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://seleniumhq.github.io/docs/new_site/getting_started/quick/",
	"title": "Quick Tour",
	"tags": [],
	"description": "",
	"content": " Selenium is not just one tool or API but it composes many tools.\nWebDriver WebDriver is also known as Selenium 2. If you are beginning with desktop website test automation then you are going to be using WebDriver APIs. WebDriver uses browser automation APIs provided by browser vendors to control browser and run tests. This is as if a real user is operating the browser. Since WebDriver does not require its API to be compiled with application code, it is not intrusive in nature. Hence, you are testing the same application which you push live.\nRemote Control Remote Control is also known as Selenium 1. Selenium RC was the most prominent Selenium tool before the advent of Selenium WebDriver. Selenium RC would use a proxy server and inject JavaScript into a browser to be able to control it. Given the intrusive nature Selenium RC had on a browser, you could never be sure if what you were testing was the same as the application you wanted to push live. Selenium 2 APIs yet contain Selenium RC APIs but Selenium 3 would completely get rid of Selenium RC APIs. If you are still using Selenium RC then you must migrate to Selenium WebDriver.\nIDE IDE is a Firefox plugin which can be used to record test steps in Firefox itself. Selenium IDE can be used to generate quick and dirty test code in a variety of programming languages (i.e. C#, Java, Python, and Ruby). Given the maintainability of code generated through Selenium IDE, it is not recommended to use it for anything more than getting acquainted with element locators or generating throw away code. We\u0026rsquo;re sure that once you get used to the WebDriver API, you will never use Selenium IDE.\nGrid Soon after development of WebDriver tests, you may face a need of running your tests on multiple browser and operating system combinations. This is where Grid comes to the rescue.\nHTML Runner This tool allows you to run Test Suites from the command line. Test Suites are HTML exports from Selenium IDE or compatible tools. HTML Runner\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/new_site/",
	"title": "Selenium Documentation",
	"tags": [],
	"description": "",
	"content": " The Selenium Browser Automation Project Selenium is an umbrella project for a range of tools and libraries that enable and support the automation of web browsers.\nIt provides extensions to emulate user interaction with browsers, a distribution server for scaling browser allocation, and the infrastructure for implementations of the W3C WebDriver specification that lets you write interchangeable code for all major web browsers.\nThis project is made possible by volunteer contributors who have put in thousands of hours of their own time, and made the source code freely available for anyone to use, enjoy, and improve.\nSelenium brings together browser vendors, engineers, and enthusiasts to further an open discussion around automation of the web platform. The project organises an annual conference to teach and nurture the community.\nAt the core of Selenium is WebDriver, an interface to write instruction sets that can be run interchangeably in many browsers. Here is one of the simplest instructions you can make:\nJava Python C# Ruby JavaScript import org.openqa.selenium.By; import org.openqa.selenium.Keys; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.firefox.FirefoxDriver; import org.openqa.selenium.support.ui.WebDriverWait; import static org.openqa.selenium.support.ui.ExpectedConditions.presenceOfElementLocated; public class HelloSelenium { public static void main(String[] args) { WebDriver driver = new FirefoxDriver(); WebDriverWait wait = new WebDriverWait(driver, 10); try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;); driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;cheese\u0026#34; + Keys.ENTER); WebElement firstResult = wait.until(presenceOfElementLocated(By.cssSelector(\u0026#34;h3\u0026gt;a\u0026#34;))); System.out.println(firstResult.getText()); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.common.keys import Keys from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support.expected_conditions import presence_of_element_located #This example requires Selenium WebDriver 3.13 or newer with webdriver.Firefox() as driver: wait = WebDriverWait(driver, 10) driver.get(\u0026#34;https://google.com/ncr\u0026#34;) driver.find_element_by_name(\u0026#34;q\u0026#34;).send_keys(\u0026#34;cheese\u0026#34; + Keys.RETURN) first_result = wait.until(presence_of_element_located((By.CSS_SELECTOR, \u0026#34;h3\u0026gt;a\u0026#34;))) print(first_result.text)   using System; using OpenQA.Selenium; using OpenQA.Selenium.Firefox; using OpenQA.Selenium.Support.UI; using SeleniumExtras.WaitHelpers; class HelloSelenium { static void Main() { using (IWebDriver driver = new FirefoxDriver()) { WebDriverWait wait = new WebDriverWait(driver, TimeSpan.FromSeconds(10)); driver.Navigate().GoToUrl(\u0026#34;https://www.google.com/ncr\u0026#34;); driver.FindElement(By.Name(\u0026#34;q\u0026#34;)).SendKeys(\u0026#34;cheese\u0026#34; + Keys.Enter); IWebElement firstResult = wait.Until(ExpectedConditions.ElementExists(By.CssSelector(\u0026#34;h3\u0026gt;a\u0026#34;))); Console.WriteLine(firstResult.Text); } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox wait = Selenium::WebDriver::Wait.new(timeout: 10) begin driver.get \u0026#39;https://google.com/ncr\u0026#39; driver.find_element(name: \u0026#39;q\u0026#39;).send_keys \u0026#39;cheese\u0026#39;, :return first_result = wait.until { driver.find_element(css: \u0026#39;h3\u0026gt;a\u0026#39;) } puts first_result.text ensure driver.quit end   const {Builder, By, Key, until} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); try { await driver.get(\u0026#39;https://www.google.com/ncr\u0026#39;); await driver.findElement(By.name(\u0026#39;q\u0026#39;)).sendKeys(\u0026#39;cheese\u0026#39;, Key.RETURN); let firstResult = await driver.wait(until.elementLocated(By.css(\u0026#39;h3\u0026gt;a\u0026#39;)),10000); console.log(await firstResult.getText()); } finally { await driver.quit(); } })();     See the Quick Tour for a full explanation of what goes on behind the scenes when you run this code. You should continue on to the narrative documentation to understand how you can install and successfully use Selenium as a test automation tool, and scaling simple tests like this to run in large, distributed environments on multiple browsers, on several different operating systems.\nGetting started If you are new to Selenium, we have a few resources that can help you get up to speed right away.\n Quick tour  WebDriver Remote Control IDE Grid HTML Runner   "
},
{
	"uri": "https://seleniumhq.github.io/docs/new_site/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]