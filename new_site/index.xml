<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Selenium Documentation</title>
    <link>https://seleniumhq.github.io/docs/new_site/</link>
    <description>Recent content on Selenium Documentation</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <copyright>2013-{year}</copyright>
    
	<atom:link href="https://seleniumhq.github.io/docs/new_site/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Browsers</title>
      <link>https://seleniumhq.github.io/docs/new_site/getting_started_with_webdriver/browsers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://seleniumhq.github.io/docs/new_site/getting_started_with_webdriver/browsers/</guid>
      <description>Consumer browsers The Selenium framework officially supports the following browsers:
   Browser Maintainer Versions Supported     Chromium Chromium All versions   Firefox Mozilla 54 and newer   Internet Explorer Selenium 6 and newer   Opera Opera Chromium / Presto 10.5 and newer   Safari Apple 10 and newer    Specialised browsers There is also a set of specialized browsers out there typically used in development environments.</description>
    </item>
    
    <item>
      <title>Captchas</title>
      <link>https://seleniumhq.github.io/docs/new_site/worst_practices/captchas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://seleniumhq.github.io/docs/new_site/worst_practices/captchas/</guid>
      <description>CAPTCHA, short for Completely Automated Public Turing test to tell Computers and Humans Apart, is explicitly designed to prevent automation, so don’t try! There are two primary strategies to get around CAPTCHA checks:
 Disable CAPTCHAs in your test environment Add a hook to allow tests to bypass the CAPTCHA  </description>
    </item>
    
    <item>
      <title>Installing Selenium libraries</title>
      <link>https://seleniumhq.github.io/docs/new_site/selenium_installation/installing_selenium_libraries/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://seleniumhq.github.io/docs/new_site/selenium_installation/installing_selenium_libraries/</guid>
      <description>Installing Selenium libraries First you need to install the Selenium bindings for your automation project. The installation process for libraries depends on the language you choose to use.
Java Installation of Selenium libraries for Java can be done using Maven. Add the selenium-java dependency in your project pom.xml:
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.seleniumhq.selenium&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;selenium-java&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.X&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; The selenium-java dependency supports running your automation project with all Selenium supported browsers. If you want to run tests only in a specific browser, you can add the dependency for that browser in your pom.</description>
    </item>
    
    <item>
      <title>Page object models</title>
      <link>https://seleniumhq.github.io/docs/new_site/guidelines_and_recommendations/page_object_models/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://seleniumhq.github.io/docs/new_site/guidelines_and_recommendations/page_object_models/</guid>
      <description>Page Object is a Design Pattern which has become popular in test automation for enhancing test maintenance and reducing code duplication. A page object is an object-oriented class that serves as an interface to a page of your AUT. The tests then use the methods of this page object class whenever they need to interact with that page of the UI. The benefit is that if the UI changes for the page, the tests themselves don’t need to change; only the code within the page object needs to change.</description>
    </item>
    
    <item>
      <title>Purposes and main functionalities</title>
      <link>https://seleniumhq.github.io/docs/new_site/grid/purposes_and_main_functionalities/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://seleniumhq.github.io/docs/new_site/grid/purposes_and_main_functionalities/</guid>
      <description> Central entry point for all tests Management and control of the nodes / environment where the browsers run on Scaling Running tests in parallel Cross platform testing Load balancing  </description>
    </item>
    
    <item>
      <title>Remote WebDriver server</title>
      <link>https://seleniumhq.github.io/docs/new_site/remote_webdriver/remote_webdriver_server/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://seleniumhq.github.io/docs/new_site/remote_webdriver/remote_webdriver_server/</guid>
      <description>The server will always run on the machine with the browser you want to test. The server can be used either from the command line or through code configuration.
Starting the server from the command line Once you have downloaded selenium-server-standalone-{VERSION}.jar, place it on the computer with the browser you want to test. Then, from the directory with the jar, run the following:
java -jar selenium-server-standalone-{VERSION}.jar Considerations for running the server The caller is expected to terminate each session properly, calling either Selenium#stop() or WebDriver#quit.</description>
    </item>
    
    <item>
      <title>The Selenium project and tools</title>
      <link>https://seleniumhq.github.io/docs/new_site/introduction/the_selenium_project_and_tools/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://seleniumhq.github.io/docs/new_site/introduction/the_selenium_project_and_tools/</guid>
      <description>Selenium controls web browsers Selenium is many things, but at its core it&amp;rsquo;s a toolset for web browser automation that uses the best techniques available to remotely control browser instances and emulate a user&amp;rsquo;s interaction with the browser.
It allows users to simulate common activities performed by end-users; entering text into fields, selecting drop-down values and checking boxes, and clicking links in documents. It also provides many other controls such as mouse movement, arbitrary JavaScript execution, and much more.</description>
    </item>
    
    <item>
      <title>Understanding the componets</title>
      <link>https://seleniumhq.github.io/docs/new_site/webdriver/understanding_the_componets/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://seleniumhq.github.io/docs/new_site/webdriver/understanding_the_componets/</guid>
      <description>Building a test suite using WebDriver will require you to understand and effectively use a number of different components. As with everything in software, different people use different terms for the same idea. Below is a breakdown of how terms are used in this description.
Terminology  API: Application Programming Interface. This is the set of &amp;ldquo;commands&amp;rdquo; you use to manipulate WebDriver. Library: A code module which contains the APIs and the code necessary to implement them.</description>
    </item>
    
    <item>
      <title>Components of a Grid</title>
      <link>https://seleniumhq.github.io/docs/new_site/grid/components_of_a_grid/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://seleniumhq.github.io/docs/new_site/grid/components_of_a_grid/</guid>
      <description>Hub  Intermediary and manager Accepts requests to run tests Takes instructions from client and executes them remotely on the nodes Manages threads  A Hub is a central point where all your tests are sent to. Each Selenium Grid consists of exactly one hub. The hub needs to be reachable from the respective clients (i.e. CI server, Developer machine etc.) The hub will connect one or more nodes that tests will be delegated to.</description>
    </item>
    
    <item>
      <title>Domain specific language</title>
      <link>https://seleniumhq.github.io/docs/new_site/guidelines_and_recommendations/domain_specific_language/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://seleniumhq.github.io/docs/new_site/guidelines_and_recommendations/domain_specific_language/</guid>
      <description>A domain specific language (DSL) is a system which provides the user with an expressive means of solving a problem. It allows a user to interact with the system on their terms – not just programmer-speak.
Your users, in general, don&amp;rsquo;t care how your site looks. They don&amp;rsquo;t care about the decoration, animations, or graphics. They want to use your system to push their new employees through the process with minimal difficulty.</description>
    </item>
    
    <item>
      <title>Driver requirements</title>
      <link>https://seleniumhq.github.io/docs/new_site/webdriver/driver_requirements/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://seleniumhq.github.io/docs/new_site/webdriver/driver_requirements/</guid>
      <description>Through WebDriver, Selenium supports all major browsers on the market such as Chrom(ium), Firefox, Internet Explorer, Opera, and Safari. Where possible, WebDriver drives the browser using the browser&amp;rsquo;s built-in support for automation, although not all browsers have official support for remote control.
WebDriver&amp;rsquo;s aim is to emulate a real user&amp;rsquo;s interaction with the browser as closely as possible. This is possible at varying levels in different browsers. For more details on the different driver idiosyncracies, please see Driver Idiosyncracies.</description>
    </item>
    
    <item>
      <title>File downloads</title>
      <link>https://seleniumhq.github.io/docs/new_site/worst_practices/file_downloads/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://seleniumhq.github.io/docs/new_site/worst_practices/file_downloads/</guid>
      <description>Whilst it is possible to start a download by clicking a link with a browser under Selenium&amp;rsquo;s control, the API does not expose download progress, making it less than ideal for testing downloaded files. This is because downloading files is not considered an important aspect of emulating user interaction with the web platform. Instead, find the link using Selenium (and any required cookies) and pass it to a HTTP request library like libcurl.</description>
    </item>
    
    <item>
      <title>Installing WebDriver binaries</title>
      <link>https://seleniumhq.github.io/docs/new_site/selenium_installation/installing_webdriver_binaries/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://seleniumhq.github.io/docs/new_site/selenium_installation/installing_webdriver_binaries/</guid>
      <description>Installing WebDriver binaries To execute your project and control browser you need to have browser-specific WebDriver binaries installed.
Download the WebDriver binary supported by your browser and place it in the System PATH.</description>
    </item>
    
    <item>
      <title>On test automation</title>
      <link>https://seleniumhq.github.io/docs/new_site/introduction/on_test_automation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://seleniumhq.github.io/docs/new_site/introduction/on_test_automation/</guid>
      <description>First, start by asking yourself whether or not you really need to use a browser. Odds are good that, at some point, if you&amp;rsquo;re working on a complex web application, you will need to open a browser and actually test it.
Functional end-user tests such as Selenium tests are expensive to run, however. Furthermore, they typically require substantial infrastructure to be in place to be run effectively. It&amp;rsquo;s a good rule to always ask yourself if what you want to test can be done using more lightweight test approaches such as unit tests or with a lower-level approach.</description>
    </item>
    
    <item>
      <title>Remote WebDriver client</title>
      <link>https://seleniumhq.github.io/docs/new_site/remote_webdriver/remote_webdriver_client/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://seleniumhq.github.io/docs/new_site/remote_webdriver/remote_webdriver_client/</guid>
      <description>First, we need to connect to the RemoteWebDriver. We do this by pointing the URL to the address of the server running our tests. In order to customize our configuration, we set desired capabilities. Below is an example of instantiating a remote WebDriver object pointing to our remote web server, www.example.com, running our tests on Firefox.
Java Python C# Ruby JavaScript FirefoxOptions firefoxOptions = new FirefoxOptions(); WebDriver driver = new RemoteWebDriver(new URL(&amp;#34;http://www.</description>
    </item>
    
    <item>
      <title>Third party drivers and plugins</title>
      <link>https://seleniumhq.github.io/docs/new_site/getting_started_with_webdriver/third_party_drivers_and_plugins/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://seleniumhq.github.io/docs/new_site/getting_started_with_webdriver/third_party_drivers_and_plugins/</guid>
      <description>Selenium can be extended through the use of plugins. Here are a number of plugins created and maintained by third parties. For more information on how to create your own plugin or have it listed, consult the docs.
Please note that these plugins are not supported, maintained, hosted, or endorsed by the Selenium project. In addition, be advised that the plugins listed below are not necessarily licensed under the Apache License v.</description>
    </item>
    
    <item>
      <title>Browser manipulation</title>
      <link>https://seleniumhq.github.io/docs/new_site/webdriver/browser_manipulation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://seleniumhq.github.io/docs/new_site/webdriver/browser_manipulation/</guid>
      <description>Ruby Ruby is not installed by default on Windows. Download the latest version and run the installer. You can leave all settings at default values, except at the Installation Destination and Optional Tasks screen check Add Ruby executables to your PATH checkbox. To drive any browser, you have to install selenium-webdriver Ruby gem. To install it, open command prompt and type this:
gem install selenium-webdriver Or, if you use Bundler, add this line to your application&amp;rsquo;s Gemfile:</description>
    </item>
    
    <item>
      <title>Generating application state</title>
      <link>https://seleniumhq.github.io/docs/new_site/guidelines_and_recommendations/generating_application_state/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://seleniumhq.github.io/docs/new_site/guidelines_and_recommendations/generating_application_state/</guid>
      <description>Selenium should not be used to prepare a test case. All repetitive actions, and preparation for a test case, should be done through other methods. For example, most web UIs have authentication (e.g. a login form). Eliminating logging in via web browser before every test will improve both the speed and stability of the test. A method should be created to gain access to the AUT (e.g. using an API to login and set a cookie).</description>
    </item>
    
    <item>
      <title>HTTP response codes</title>
      <link>https://seleniumhq.github.io/docs/new_site/worst_practices/http_response_codes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://seleniumhq.github.io/docs/new_site/worst_practices/http_response_codes/</guid>
      <description>For some browser configurations in Selenium RC, Selenium acted as a proxy between the browser and the site being automated. This meant that all browser traffic passed through Selenium could be captured or manipulated. The captureNetworkTraffic() method purported to capture all of the network traffic between the browser and the site being automated, including HTTP response codes.
Selenium WebDriver is a completely different approach to browser automation, preferring to act more like a user and this is represented in the way you write tests with WebDriver.</description>
    </item>
    
    <item>
      <title>Installing Standalone server</title>
      <link>https://seleniumhq.github.io/docs/new_site/selenium_installation/installing_standalone_server/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://seleniumhq.github.io/docs/new_site/selenium_installation/installing_standalone_server/</guid>
      <description>Installing Standalone server If you plan to use Grid then you should download the selenium-server-standalone JAR file. The selenium-server-standalone jar is never uploaded, but all the components are available via selenium-server. The standalone JAR contains everything, including the remote Selenium server and the client-side bindings. This means that if you use the selenium-server-standalone jar in your project, then you don&amp;rsquo;t have to add selenium-java or a browser specific jar.</description>
    </item>
    
    <item>
      <title>Locating elements</title>
      <link>https://seleniumhq.github.io/docs/new_site/getting_started_with_webdriver/locating_elements/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://seleniumhq.github.io/docs/new_site/getting_started_with_webdriver/locating_elements/</guid>
      <description>Locating one element One of the most fundamental techniques to learn when using WebDriver is how to find elements on the page. WebDriver offers a number of built-in selector types, amongst them finding an element by its ID attribute:
Java Python C# Ruby JavaScript WebElement cheese = driver.findElement(By.id(&amp;#34;cheese&amp;#34;));   driver.find_element_by_id(&amp;#34;cheese&amp;#34;)   IWebElement element = driver.FindElement(By.Id(&amp;#34;cheese&amp;#34;));   driver.find_element(id: &amp;#34;cheese&amp;#34;)   const cheese = await driver.findElement(By.id(&amp;#39;cheese&amp;#39;));     As seen in the example, locating elements in WebDriver is done on the WebDriver instance object.</description>
    </item>
    
    <item>
      <title>Setting up your own Grid</title>
      <link>https://seleniumhq.github.io/docs/new_site/grid/setting_up_your_own_grid/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://seleniumhq.github.io/docs/new_site/grid/setting_up_your_own_grid/</guid>
      <description>To use Selenium Grid, you need to maintain your own infrastructure for the nodes. As this can be a cumbersome and time intense effort, many organizations use IaaS providers such as Amazon EC2 and Google Compute to provide this infrastructure.
Other options include using providers such as Sauce Labs or Testing Bot who provide a Selenium Grid as a service in the cloud. It is certainly possible to also run nodes on your own hardware.</description>
    </item>
    
    <item>
      <title>Types of testing</title>
      <link>https://seleniumhq.github.io/docs/new_site/introduction/types_of_testing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://seleniumhq.github.io/docs/new_site/introduction/types_of_testing/</guid>
      <description>TODO: Add paragraphs about acceptance testing, performance testing, load testing, regression testing, test driven development, and/or behavior-driven development (JBehave, Capybara, &amp;amp; Robot Framework), with how they relate to Selenium.</description>
    </item>
    
    <item>
      <title>About this documentation</title>
      <link>https://seleniumhq.github.io/docs/new_site/introduction/about_this_documentation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://seleniumhq.github.io/docs/new_site/introduction/about_this_documentation/</guid>
      <description>These docs, like the code itself, are maintained 100% by volunteers within the Selenium community. Many have been using it since its inception, but many more have only been using it for a short while, and have given their time to help improve the on-boarding experience for new users.
If there is an issue with the documentation, we want to know! The best way to communicate an issue is to visit https://github.</description>
    </item>
    
    <item>
      <title>Gmail, email and Facebook logins</title>
      <link>https://seleniumhq.github.io/docs/new_site/worst_practices/gmail_email_and_facebook_logins/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://seleniumhq.github.io/docs/new_site/worst_practices/gmail_email_and_facebook_logins/</guid>
      <description>For multiple reasons, logging into sites like Gmail and Facebook using WebDriver is not recommended. Aside from being against the usage terms for these sites (where you risk having the account shut down), it is slow and unreliable.
The ideal practice is to use the APIs that email providers offer, or in the case of Facebook the developer tools service which exposes an API for creating test accounts, friends and so forth.</description>
    </item>
    
    <item>
      <title>Mock external services</title>
      <link>https://seleniumhq.github.io/docs/new_site/guidelines_and_recommendations/mock_external_services/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://seleniumhq.github.io/docs/new_site/guidelines_and_recommendations/mock_external_services/</guid>
      <description>Eliminating the dependencies on external services will greatly improve the speed and stability of your tests.</description>
    </item>
    
    <item>
      <title>Performing actions on the AUT*</title>
      <link>https://seleniumhq.github.io/docs/new_site/getting_started_with_webdriver/performing_actions_on_the_aut/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://seleniumhq.github.io/docs/new_site/getting_started_with_webdriver/performing_actions_on_the_aut/</guid>
      <description>You can set an element&amp;rsquo;s text using the sendKeys method as follows:
Java Python C# Ruby JavaScript String name = &amp;#34;Charles&amp;#34;; driver.findElement(By.name(&amp;#34;name&amp;#34;)).sendKeys(name);   name = &amp;#34;Charles&amp;#34; driver.find_element_by_name(&amp;#34;name&amp;#34;).send_keys(name)   string name = &amp;#34;Charles&amp;#34;; driver.FindElement(By.Name(&amp;#34;name&amp;#34;)).SendKeys(name);   name = &amp;#34;Charles&amp;#34; driver.find_element(name: &amp;#34;name&amp;#34;).send_keys(name)   const name = &amp;#34;Charles&amp;#34;; await driver.findElement(By.name(&amp;#39;name&amp;#39;)).sendKeys(name);     Some web applications use JavaScript libraries to add drag-and-drop functionality. The following is a basic example of dragging one element onto another element:</description>
    </item>
    
    <item>
      <title>Waits</title>
      <link>https://seleniumhq.github.io/docs/new_site/webdriver/waits/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://seleniumhq.github.io/docs/new_site/webdriver/waits/</guid>
      <description>WebDriver can generally be said to have a blocking API. Because it is an out-of-process library that instructs the browser what to do, and because the web platform has an intrinsically asynchronous nature, WebDriver doesn&amp;rsquo;t track the active, real-time state of the DOM. This comes with some challenges that we will discuss here.
From experience, most intermittents that arise from use of Selenium and WebDriver are connected to race conditions that occur between the browser and the user&amp;rsquo;s instructions.</description>
    </item>
    
    <item>
      <title>Improved reporting</title>
      <link>https://seleniumhq.github.io/docs/new_site/guidelines_and_recommendations/improved_reporting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://seleniumhq.github.io/docs/new_site/guidelines_and_recommendations/improved_reporting/</guid>
      <description>Selenium is not designed to report on the status of test cases run. Taking advantage of the built-in reporting capabilities of unit test frameworks is a good start. Most unit test frameworks have reports that can generate xUnit or HTML formatted reports. xUnit reports are popular for importing results to a Continuous Integration (CI) server like Jenkins, Travis, Bamboo, etc. Here are some links for more information regarding report outputs for several languages.</description>
    </item>
    
    <item>
      <title>Support classes</title>
      <link>https://seleniumhq.github.io/docs/new_site/webdriver/support_classes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://seleniumhq.github.io/docs/new_site/webdriver/support_classes/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Test dependency</title>
      <link>https://seleniumhq.github.io/docs/new_site/worst_practices/test_dependency/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://seleniumhq.github.io/docs/new_site/worst_practices/test_dependency/</guid>
      <description>A common idea and misconception about automated testing is regarding a specific test order. Your tests should be able to run in any order, and not rely on other tests to complete in order to be successful.</description>
    </item>
    
    <item>
      <title>Avoid sharing state</title>
      <link>https://seleniumhq.github.io/docs/new_site/guidelines_and_recommendations/avoid_sharing_state/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://seleniumhq.github.io/docs/new_site/guidelines_and_recommendations/avoid_sharing_state/</guid>
      <description>Although mentioned in several places it is worth mentioning again. Ensure tests are isolated from one another.
Don&amp;rsquo;t share test data. Imagine several tests that each query the database for valid orders before picking one to perform an action on. Should two tests pick up the same order you are likely to get unexpected behaviour.
Clean up stale data in the application that might be picked up by another test e.</description>
    </item>
    
    <item>
      <title>JavaScript alerts, prompts and confirmations</title>
      <link>https://seleniumhq.github.io/docs/new_site/webdriver/js_alerts_prompts_and_confirmations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://seleniumhq.github.io/docs/new_site/webdriver/js_alerts_prompts_and_confirmations/</guid>
      <description>WebDriver provides an API for working with the three types of native popup message offered by JavaScript. These popups are styled by the browser and offer limited customisation.
Alerts The simplest of these is referred to as an alert, which shows a custom message, and a single button which dismisses the alert, labelled in most browsers as OK. It can also be dismissed in most browsers by pressing the close button, but this will always do the same thing as the OK button.</description>
    </item>
    
    <item>
      <title>Performance testing</title>
      <link>https://seleniumhq.github.io/docs/new_site/worst_practices/performance_testing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://seleniumhq.github.io/docs/new_site/worst_practices/performance_testing/</guid>
      <description>Performance testing using Selenium and WebDriver is generally not advised. Not because it is incapable but because it is not optimised for the job and you are unlikely to get good results.
It may seem ideal to performance test in the context of the user but a suite of WebDriver tests are subjected to many points of external and internal fragility which are beyond your control; for example browser startup speed, speed of HTTP servers, response of third party servers that host JavaScript or CSS, and the instrumentation penalty of the WebDriver implementation itself.</description>
    </item>
    
    <item>
      <title>Http proxies</title>
      <link>https://seleniumhq.github.io/docs/new_site/webdriver/http_proxies/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://seleniumhq.github.io/docs/new_site/webdriver/http_proxies/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Link spidering</title>
      <link>https://seleniumhq.github.io/docs/new_site/worst_practices/link_spidering/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://seleniumhq.github.io/docs/new_site/worst_practices/link_spidering/</guid>
      <description>Using WebDriver to spider through links is not a recommended practice not because it cannot be done, but because it’s definitely not the most ideal tool. WebDriver needs time to start up, and can take several seconds up to a minute depending on how your test is written, just to get to the page and traverse through the DOM.
Instead of using WebDriver for this, you could save a ton of time by executing a curl command, or using a library such as BeautifulSoup since these methods don’t rely on creating a browser and navigating to a page.</description>
    </item>
    
    <item>
      <title>Test independency</title>
      <link>https://seleniumhq.github.io/docs/new_site/guidelines_and_recommendations/test_independency/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://seleniumhq.github.io/docs/new_site/guidelines_and_recommendations/test_independency/</guid>
      <description>Write each test as its own unit. Write the tests in a way that won&amp;rsquo;t be reliant on other tests to complete:
Let&amp;rsquo;s say there is a content management system with which you can create some custom content which then appears on your website as a module after publishing, and it may take some time to sync between the CMS and the application.
A wrong way of testing your module is that the content is created and published in one test, and then checking the module in another test.</description>
    </item>
    
    <item>
      <title>Consider using a fluent API</title>
      <link>https://seleniumhq.github.io/docs/new_site/guidelines_and_recommendations/consider_using_a_fluent_api/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://seleniumhq.github.io/docs/new_site/guidelines_and_recommendations/consider_using_a_fluent_api/</guid>
      <description>Martin Fowler coined the term &amp;ldquo;Fluent API&amp;rdquo;. Selenium already implements something like this in their FluentWait class which is meant as an alternative to the standard Wait class. You could enable the Fluent API design pattern in your page object and then query the Google search page with a code snippet like this one:
driver.get( &amp;#34;http://www.google.com/webhp?hl=en&amp;amp;amp;tab=ww&amp;#34; ); GoogleSearchPage gsp = new GoogleSearchPage(); gsp.withFluent().setSearchString().clickSearchButton(); The Google page object class with this fluent behavior might look like this:</description>
    </item>
    
    <item>
      <title>Page loading strategy</title>
      <link>https://seleniumhq.github.io/docs/new_site/webdriver/page_loading_strategy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://seleniumhq.github.io/docs/new_site/webdriver/page_loading_strategy/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Fresh browser per test</title>
      <link>https://seleniumhq.github.io/docs/new_site/guidelines_and_recommendations/fresh_browser_per_test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://seleniumhq.github.io/docs/new_site/guidelines_and_recommendations/fresh_browser_per_test/</guid>
      <description>Start each test from a clean known state. Ideally, spin up a new virtual machine for each test. If spinning up a new virtual machine is not practical, at least start a new WebDriver for each test. For Firefox, start a WebDriver with your known profile.
FirefoxProfile profile = new FirefoxProfile(new File(&amp;#34;pathToFirefoxProfile&amp;#34;)); WebDriver driver = new FirefoxDriver(profile);</description>
    </item>
    
    <item>
      <title>Web element</title>
      <link>https://seleniumhq.github.io/docs/new_site/webdriver/web_element/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://seleniumhq.github.io/docs/new_site/webdriver/web_element/</guid>
      <description>Represents a DOM element. WebElements can be found by searching from the document root using a WebDriver instance, or by searching under another WebElement:
Java Python C# Ruby JavaScript WebDriver driver = new FirefoxDriver(); driver.get(&amp;#34;http://www.google.com&amp;#34;); WebElement searchForm = driver.findElement(By.tagName(&amp;#34;form&amp;#34;)); WebElement searchbox = driver.findElement(By.name(&amp;#34;q&amp;#34;)); searchbox.sendKeys(&amp;#34;webdriver&amp;#34;);   driver = Firefox() driver.get(&amp;#34;http://www.google.com&amp;#34;) search_form = driver.find_element_by_tag_name(&amp;#34;form&amp;#34;) search_box = search_form.find_element_by_name(&amp;#34;q&amp;#34;) search_box.send_keys(&amp;#34;webdriver&amp;#34;)   // We don&amp;#39;t have a C# code sample yet - Help us out and raise a PR    # We don&amp;#39;t have a Ruby code sample yet - Help us out and raise a PR    driver.</description>
    </item>
    
    <item>
      <title>Keyboard</title>
      <link>https://seleniumhq.github.io/docs/new_site/webdriver/keyboard/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://seleniumhq.github.io/docs/new_site/webdriver/keyboard/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Mouse</title>
      <link>https://seleniumhq.github.io/docs/new_site/webdriver/mouse/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://seleniumhq.github.io/docs/new_site/webdriver/mouse/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Quick Tour</title>
      <link>https://seleniumhq.github.io/docs/new_site/getting_started/quick/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://seleniumhq.github.io/docs/new_site/getting_started/quick/</guid>
      <description>Selenium is not just one tool or API but it composes many tools.
WebDriver WebDriver is also known as Selenium 2. If you are beginning with desktop website test automation then you are going to be using WebDriver APIs. WebDriver uses browser automation APIs provided by browser vendors to control browser and run tests. This is as if a real user is operating the browser. Since WebDriver does not require its API to be compiled with application code, it is not intrusive in nature.</description>
    </item>
    
  </channel>
</rss>