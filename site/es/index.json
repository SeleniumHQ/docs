[
{
	"uri": "https://seleniumhq.github.io/docs/site/es/driver_idiosyncrasies/shared_capabilities/",
	"title": "Capacidades compartidas",
	"tags": [],
	"description": "",
	"content": " Estrategia de carga de la página (pageLoadStrategy) Al navegar a una nueva página a través de URL, por defecto Selenium esperará hasta que la página se haya cargado completamente antes de responder. Esto funciona bien para principiantes, pero puede causar largos tiempos de espera en páginas que cargan una gran cantidad de recursos de terceros. El uso de una estrategia no predeterminada puede hacer que la ejecución de la prueba sea más rápida en casos como este, pero también puede introducir inestabilidad donde los elementos en la página cambian de posición a medida que los elementos se cargan y cambian de tamaño.\nLa estrategia de carga de la página consulta el document.readyState como se describe en la tabla a continuación:\n   Estrategia Ready State Notas     normal complete Usado por defecto, espera a que se descarguen todos los recursos   eager interactive El acceso DOM está listo, pero otros recursos como las imágenes aún pueden estar cargando   none Any No bloquea WebDriver en absoluto    "
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/worst_practices/captchas/",
	"title": "Captchas",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n CAPTCHA, short for Completely Automated Public Turing test to tell Computers and Humans Apart, is explicitly designed to prevent automation, so don’t try! There are two primary strategies to get around CAPTCHA checks:\n Disable CAPTCHAs in your test environment Add a hook to allow tests to bypass the CAPTCHA  "
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/front_matter/copyright_and_attributions/",
	"title": "Derechos de autor y atribuciones",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n The Documentation of Selenium Copyright \u0026copy; 2013-2019 , Software Freedom Conservancy.\nEvery effort has been made to make this documentation as complete and as accurate as possible, but no warranty or fitness is implied. The information provided is on an “as-is” basis. The authors and the publisher shall have neither liability nor responsibility to any person or entity with respect to any loss or damages arising from the information contained in this book. No patent liability is assumed with respect to the use of the information contained herein.\nAttributions Thanks to: Documentation .ghContributors { display: flex; flex-flow: wrap; align-content: flex-start; } .ghContributors \u0026gt; div { width: 50%; display: inline-flex; margin-bottom: 5px; } .ghContributors \u0026gt; div label { padding-left: 4px; } .ghContributors \u0026gt; div span { font-size: x-small; padding-left: 4px; }  @andreastt197 commits \n@selenium-ci82 commits \n@diemol50 commits \n@hazmeister31 commits \n@santiycr27 commits \n@AlexAndradeSan25 commits \n@lukeis21 commits \n@ddavison16 commits \n@davehunt12 commits \n@manoj978812 commits \n@orieken12 commits \n@djangofan12 commits \n@Harsha5098 commits \n@liushilive8 commits \n@User2534897 commits \n@jimholmes6 commits \n@imba-tjd6 commits \n@mmerrell6 commits \n@shs96c6 commits \n@picimako5 commits \n@vijay445 commits \n@xrobotika5 commits \n@cambiph5 commits \n@jesanmar14 commits \n@nvonop4 commits \n@rivlinp4 commits \n@sheg4 commits \n@detro3 commits \n@Ardesco3 commits \n@TheTestLynx3 commits \n@Bredda2 commits \n@juperala2 commits \n@lmtierney2 commits \n@systemboogie2 commits \n@palotas2 commits \n@sri852 commits \n@hoanluu2 commits \n@paul-barton2 commits \n@sourabhkt2 commits \n@adithyab941 commits \n@p0deje1 commits \n@AJ-721 commits \n@abotalov1 commits \n@bhardin1 commits \n@chamiz1 commits \n@dennybiasiolli1 commits \n@donhuvy1 commits \n@nicegraham1 commits \n@JakimLi1 commits \n@austenjt1 commits \n@kmcgon1 commits \n@MartinDelille1 commits \n@michael-coleman1 commits \n@miekof1 commits \n@MilanMasek1 commits \n@rakib-amin1 commits \n@NRezek1 commits \n@nikai3d1 commits \n@OndraM1 commits \n@whhone1 commits \n@yarix1 commits \n@ZbigniewZabost1 commits \n@agmen1 commits \n@hking-shutterfly1 commits \n@jimevans1 commits \n@marilyn1 commits \n@riccione1 commits \n@tungla1 commits \n@zeljkofilipin1 commits \n\nSelenium Main Repo .ghContributors { display: flex; flex-flow: wrap; align-content: flex-start; } .ghContributors \u0026gt; div { width: 50%; display: inline-flex; margin-bottom: 5px; } .ghContributors \u0026gt; div label { padding-left: 4px; } .ghContributors \u0026gt; div span { font-size: x-small; padding-left: 4px; }  @shs96c4318 commits \n@barancev2611 commits \n@jimevans2258 commits \n@jleyba1464 commits \n@jarib1298 commits \n@dfabulich1175 commits \n@illicitonion1162 commits \n@AutomatedTester759 commits \n@lukeis599 commits \n@eranmes473 commits \n@mdub326 commits \n@p0deje320 commits \n@titusfortner308 commits \n@andreastt289 commits \n@krosenvold225 commits \n@hugs205 commits \n@davehunt200 commits \n@hbchai191 commits \n@lmtierney179 commits \n@ph7147 commits \n@freynaud138 commits \n@samitbadle137 commits \n@nirvdrum133 commits \n@sevaseva115 commits \n@gigix109 commits \n@juangj108 commits \n@aslakhellesoy94 commits \n@alex-savchuk90 commits \n@andrashatvani66 commits \n@ajayk63 commits \n@asashour48 commits \n@twalpole47 commits \n@mikemelia46 commits \n@jherault44 commits \n@tebeka44 commits \n@santiycr41 commits \n@mach636 commits \n@ddavison31 commits \n@joshbruning29 commits \n@mikebroberts28 commits \n@valfirst23 commits \n@diemol21 commits \n@bret20 commits \n@cgoldberg20 commits \n@by-example19 commits \n@rbri16 commits \n@JohnChen015 commits \n@alb-i98614 commits \n@krmahadevan14 commits \n@bayandin12 commits \n@jayakumarc12 commits \n@carlosgcampos11 commits \n@43081j11 commits \n@detro10 commits \n@josephg10 commits \n@redsquirrel9 commits \n@RustyNail9 commits \n@InstyleVII8 commits \n@tourdedave8 commits \n@glib-briia7 commits \n@llaskin7 commits \n@DrMarcII7 commits \n@mmerrell7 commits \n@User2534897 commits \n@corevo7 commits \n@dima-groupon6 commits \n@nikolas6 commits \n@dratler6 commits \n@Herst5 commits \n@Dude-X5 commits \n@jimvm5 commits \n@JohanLorenzo5 commits \n@oddui5 commits \n@adiohana5 commits \n@luke-hill5 commits \n@Zitrax4 commits \n@dbo4 commits \n@sangaline4 commits \n@Ardesco4 commits \n@klepikov4 commits \n@tobli4 commits \n@yizeng4 commits \n@abotalov4 commits \n@dylanlive4 commits \n@JasnoWa4 commits \n@mcharsley4 commits \n@GQAssurance4 commits \n@mojwang4 commits \n@alexhenrie3 commits \n@chrisblock3 commits \n@Marketionist3 commits \n@epall3 commits \n@thorn03 commits \n@johnjbarton3 commits \n@zch3 commits \n@Dominator0083 commits \n@nschonni3 commits \n@olleolleolle3 commits \n@chandrap3 commits \n@livioc3 commits \n\nDocker Selenium .ghContributors { display: flex; flex-flow: wrap; align-content: flex-start; } .ghContributors \u0026gt; div { width: 50%; display: inline-flex; margin-bottom: 5px; } .ghContributors \u0026gt; div label { padding-left: 4px; } .ghContributors \u0026gt; div span { font-size: x-small; padding-left: 4px; }  @diemol198 commits \n@ddavison133 commits \n@mtscout653 commits \n@kayabendroth50 commits \n@elgalu24 commits \n@WillAbides8 commits \n@marten-cz5 commits \n@MacCracken5 commits \n@jsa345 commits \n@garagepoort4 commits \n@METAJIJI4 commits \n@manoj97884 commits \n@ZainabSalameh4 commits \n@vasikarla4 commits \n@niQo4 commits \n@testphreak4 commits \n@Remi-p3 commits \n@tnguyen143 commits \n@alexgibson3 commits \n@jeff-jk3 commits \n@pabloFuente3 commits \n@chuckg2 commits \n@davehunt2 commits \n@glib-briia2 commits \n@joaoluizjoaquim2 commits \n@mathieu-pousse2 commits \n@phensley2 commits \n@ryneeverett2 commits \n@wheleph2 commits \n@schmunk422 commits \n@chenrui3332 commits \n@a-k-g1 commits \n@alexkogon1 commits \n@deviantintegral1 commits \n@anto-ac1 commits \n@ay0o1 commits \n@gensc0041 commits \n@budtmo1 commits \n@charford1 commits \n@cyrille-leclerc1 commits \n@deiwin1 commits \n@enolan1 commits \n@evertones1 commits \n@hnryjms1 commits \n@doublemarket1 commits \n@hazmeister1 commits \n@McGriddle1 commits \n@jamesottaway1 commits \n@jarspi1 commits \n@BeyondEvil1 commits \n@ja8zyjits1 commits \n@jwhitlock1 commits \n@jonaseicher1 commits \n@CaffeinatedCM1 commits \n@karel19801 commits \n@kmala1 commits \n@lcnja1 commits \n@lmtierney1 commits \n@lukeis1 commits \n@m15o1 commits \n@michallepicki1 commits \n@mikewrighton1 commits \n@meeroslaph1 commits \n@nicolaiparlog1 commits \n@double161 commits \n@remcorakers1 commits \n@rjatkins1 commits \n@scottturley1 commits \n@sethuster1 commits \n@smccarthy1 commits \n@stigkj1 commits \n@tadashi07131 commits \n@gitter-badger1 commits \n@graingert1 commits \n@ThomasMeschke1 commits \n@cvakiitho1 commits \n@torstenwalter1 commits \n@victor-catalyst1 commits \n@vv-p1 commits \n@wesmcouch1 commits \n@reegnz1 commits \n@eitany1 commits \n@miyajan1 commits \n@mgingras1 commits \n@mirkotschaeni1 commits \n@mkrei1 commits \n@neben1 commits \n@oleg-filiutsich1 commits \n@wildloop1 commits \n\nThird-Party software used by Selenium documentation project:    Software Version License     Hugo v0.55.6 Apache 2.0   Hugo Learn Theme v2.3.0 MIT   Code Tabs Style \u0026mdash; MIT    HTML version and source code An HTML version of this documentation is freely available from https://seleniumhq.github.io/docs.\nThe source code for the examples included, and for the book itself is available from the Selenium documentation repository at https://seleniumhq.github.io/docs. See instructions on how to check out the code via git at https://help.github.com/articles/fetching-a-remote/.\nLicense All code and documentation originating from the Selenium project is licensed under the Apache 2.0 license, with the Software Freedom Conservancy as the copyright holder.\nThe license is included here for convenience, but you can also find it on the Apache Foundation\u0026rsquo;s websites:\nApache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION 1. Definitions. \u0026#34;License\u0026#34; shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \u0026#34;Licensor\u0026#34; shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \u0026#34;Legal Entity\u0026#34; shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \u0026#34;control\u0026#34; means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \u0026#34;You\u0026#34; (or \u0026#34;Your\u0026#34;) shall mean an individual or Legal Entity exercising permissions granted by this License. \u0026#34;Source\u0026#34; form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \u0026#34;Object\u0026#34; form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \u0026#34;Work\u0026#34; shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \u0026#34;Derivative Works\u0026#34; shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \u0026#34;Contribution\u0026#34; shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \u0026#34;submitted\u0026#34; means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \u0026#34;Not a Contribution.\u0026#34; \u0026#34;Contributor\u0026#34; shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. 2. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. 3. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. 4. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and (c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \u0026#34;NOTICE\u0026#34; text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. 5. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. 6. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. 7. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \u0026#34;AS IS\u0026#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. 8. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. 9. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS APPENDIX: How to apply the Apache License to your work. To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets \u0026#34;[]\u0026#34; replaced with your own identifying information. (Don\u0026#39;t include the brackets!) The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \u0026#34;printed page\u0026#34; as the copyright notice for easier identification within third-party archives. Copyright [yyyy] [name of copyright owner] Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License."
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/introduction/the_selenium_project_and_tools/",
	"title": "El proyecto Selenium y herramientas",
	"tags": [],
	"description": "",
	"content": " Selenium controla navegadores web Selenium es muchas cosas, pero en esencia es un conjunto de herramientas para la automatización del navegador web que utiliza las mejores técnicas disponibles para controlar de forma remota las instancias del navegador y emular la interacción de un usuario con el navegador.\nPermite a los testers simular actividades comunes realizadas por los usuarios finales; ingresar texto en los campos, seleccionar valores desplegables y casillas de verificación, y hacer clic en los enlaces de los documentos. También proporciona muchos otros controles, como el movimiento del mouse, la ejecución arbitraria de JavaScript y mucho más.\nAunque se utiliza principalmente para la prueba de front-end de sitios web, Selenium es en esencia una Librería de agente de usuario de navegador. Las interfaces son ubicuas a la aplicación, lo que fomenta la relación con otras librerías para adaptarse a su necesidad.\nUna interfaz para gobernarlos a todos Uno de los principios rectores del proyecto es admitir una interfaz común para los principales navegadores web. Los navegadores web son aplicaciones increíblemente complejas y de alta ingeniería, que realizan sus operaciones de formas completamente diferentes, pero que con frecuencia se ven iguales al hacerlo. Aunque el texto se representa en las mismas fuentes, las imágenes se muestran en el mismo lugar y los enlaces lo llevan al mismo destino. Lo que sucede debajo es tan diferente como la noche y el día. Selenium \u0026ldquo;resume\u0026rdquo; estas diferencias, ocultando sus detalles y complejidades a la persona que escribe el código. Esto le permite escribir varias líneas de código para realizar un flujo de trabajo complicado, pero estas mismas líneas se ejecutarán en Firefox, Internet Explorer, Chrome y todos los demás navegadores compatibles.\nHerramientas y soporte El enfoque de diseño minimalista de Selenium le da versatilidad para ser incluido como componente en aplicaciones más grandes. La infraestructura circundante proporcionada bajo Selenium le brinda las herramientas para armar su propia Grid de navegadores o grid para que las pruebas se puedan ejecutar en diferentes navegadores y múltiples sistemas operativos en una amplia gama de máquinas.\nImagine un banco de computadoras en la sala de servidores o en el centro de datos que activan todos los navegadores al mismo tiempo que hacen clic en los enlaces, formularios y tablas de su sitio, probando su aplicación las 24 horas del día. A través de la interfaz de programación simple provista para los lenguajes más comunes, estas pruebas se ejecutarán incansablemente en paralelo y le informarán cuando ocurran errores.\nEs un objetivo ayudar a que esto sea una realidad para usted, proporcionando a los usuarios herramientas y documentación para controlar no solo los navegadores, sino también para facilitar la ejecución a gran escala y la implementación de dichas Grids.\nQuién usa Selenium Muchas de las compañías más importantes del mundo han adoptado Selenium para sus pruebas basadas en navegadores, a menudo reemplazando los esfuerzos de años que involucran otras herramientas propietarias. A medida que ha crecido en popularidad, también se han multiplicado sus requisitos y desafíos.\nA medida que la web se vuelve más complicada y se agregan nuevas tecnologías a los sitios web, la misión de este proyecto es mantenerse al día con ellos siempre que sea posible. Al ser un proyecto de código abierto, este apoyo se brinda a través de la generosa donación de tiempo de muchos voluntarios, cada uno de los cuales tiene un \u0026ldquo;trabajo diario\u0026rdquo;.\nOtra misión del proyecto es alentar a más voluntarios a participar en este esfuerzo, y construir una comunidad fuerte para que el proyecto pueda seguir el ritmo de las tecnologías emergentes y seguir siendo una plataforma dominante para la automatización de pruebas funcionales.\nHistoria Cuando Selenium 1 se lanzó en 2004, la necesidad era reducir el tiempo dedicado a verificar manualmente el comportamiento consistente en el front-end de una aplicación web. Se hizo uso de las herramientas disponibles en ese momento y se basó en gran medida en la inyección de JavaScript en la página web bajo prueba para emular la interacción de un usuario. Si bien JavaScript es una buena herramienta para permitirle introspectar las propiedades del DOM y hacer ciertas observaciones del lado del cliente que de otro modo no podría hacer, no tiene la capacidad de replicar de forma natural las interacciones de un usuario como el uso del teclado y ratón.\nDesde entonces, Selenium ha crecido y madurado mucho, convirtiéndose en una herramienta ampliamente utilizada por muchas, si no la mayoría, de las organizaciones más grandes del mundo. Selenium ha pasado de ser un kit de herramientas de automatización de pruebas de fabricación casera desarrollado en Thoughtworks para un público especial y un caso de uso específico, a la librería de automatización del navegador de facto en el mundo.\nDel mismo modo que Selenium RC hizo uso de las herramientas del mercado disponibles en ese momento, Selenium WebDriver impulsa esa tradición al llevar la parte de interacción del navegador al territorio del desarrollador del navegador y pedirles que se responsabilicen de las implementaciones de back-end orientadas al navegador. Recientemente, este trabajo se ha convertido en un proceso de estandarización W3C donde el objetivo es convertir el componente WebDriver en Selenium en la libería de control remoto de uso cumún para las simulaciones de agentes de usuario.\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/webdriver/understanding_the_components/",
	"title": "Entendiendo los componentes",
	"tags": [],
	"description": "",
	"content": " Construir una suite de test usando WebDriver requerirá que entiendas y uses de forma efectiva diferentes componentes. Como con todo en el desarrollo de software, la gente usa diferentes términos para la misma idea. A continuación hay un desglose de cómo los términos son usados en esa descripción.\nTerminología  API: Interfaz de Programación de Aplicaciones. Es un conjunto de \u0026ldquo;comandos\u0026rdquo; que se utilizan para manipular el WebDriver. Library: Un módulo de código que contiene las APIs y el código necesario para implementarlos. Las librerías son específicas para cada lenguaje, por ejemplo ficheros .jar en Java, ficheros .dll para .NET, etc. Driver: El responsable de controlar el navegador actual. La mayoría de los drivers son creados por los vendors del navegador. Los Drivers son generalmente módulos ejecutables que corren en el sistema con el propio navegador, no en el sistema ejecutando la suite de test. (Aunque esos pueden ser el mismo sistema.) NOTE: Algunas personas se refieren a los drivers como proxies. Framework: Una librería adicional usada como un soporte para la suites de WebDriver. Estos frameworks pueden ser test frameworks como JUnit o NUnit. También pueden ser frameworks soportando lenguaje natural como Cucumber o Robotium. Los frameworks también pueden ser escritos y usados para cosas como la manipulación o configuración del sistema bajo la prueba, creación de datos, test oracles, etc  Las Partes y las Piezas Como mínimo, el WebDriver habla con un navegador a través del driver. La comunicación es bidireccional: el WebDriver pasa comandos al navegador a través del driver, y recive la información de vuelta por la misma ruta.\nEl driver es específico para el navegador, como es ChromeDriver para Chrome/Chromium de Google, GeckoDriver para Mozilla Firefox, etc. El driver corre en el mismo sistema que el browser. Esto puede, o no puede ser, el mismo sistema donde los tests se están ejecutando.\nEste simple ejemplo anterior es de comunicación directa. La comunicación con el navegador puede ser remota a través de Selenium Server o RemoteWebdriver. Éste último corre en el mismo sistema que el driver y el browser.\nLa comunicación remota puede también hacerse usando Selenium Server o Selenium Grid, ambos a su vez hablan con el driver en el sistema anfitrión.\nDónde encaja el Framework El WebDriver tiene un trabajo y solo un trabajo: comunicarse con el navegador a través de uno de los métodos nombrados. El WebDriver no tiene que saber nada sobre testing: no sabe cómo comparar cosas, asegurar un pass o fail, y ciertamente no sabe nada acerca de reportes o sobre la gramática Given/When/Then.\nAquí es donde varios frameworks entran en juego. Como mínimo neesitarás un framework de test que compare los enlaces de idiomas, por ejempolo NUnit para .NET, JUnit para Java, RSpec para Ruby, etc.\nEl framework de test es responsable de correr y ejecutar tu WebDriver y los pasos de tus tests. Como tal, puedes pensar que se parece a la siguiente imagen.\nLos frameworks o herramientas de lenguage natural como Cucumber pueden existir como parte de la caja de Test Framework de la figura de arriba, o envolver totalmente el Test Framework en su propia implementación.\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/getting_started/quick/",
	"title": "Guía rápida",
	"tags": [],
	"description": "",
	"content": " Selenium no es solo una herramienta o API, sino que compone muchas herramientas.\nWebDriver WebDriver también se conoce como Selenium 2. Si está comenzando con la automatización de pruebas de sitios web de escritorio, entonces va a utilizar las API de WebDriver. WebDriver utiliza las API de automatización del navegador proporcionadas por los desarrolladores de los navegadores para controlar el navegador y ejecutar pruebas. Esto es como si un usuario real estuviera manipulando el navegador. Dado que el WebDriver no requiere que su API se compile con el código de la aplicación que va a probar, no es de naturaleza intrusiva. Por lo tanto, está probando la misma aplicación que está en vivo.\nControl remoto Remote Control también se conoce como Selenium 1. Selenium RC fue la herramienta de Selenium más destacada antes del advenimiento de Selenium WebDriver. Selenium RC usaba un servidor proxy e inyectaba JavaScript en un navegador para poder controlarlo. Dada la naturaleza intrusiva que Selenium RC tenía en un navegador, nunca podría estar seguro de si lo que estaba probando era lo mismo que la aplicación que quería publicar (desplegar). Las API de Selenium 2 todavía contienen API de Selenium RC, pero Selenium 3 eliminará completamente las API de Selenium RC. Si todavía utiliza Selenium RC, debe migrar a Selenium WebDriver.\nIDE IDE es un complemento de Firefox que se puede utilizar para grabar los pasos de prueba en el propio Firefox. Selenium IDE se puede utilizar para generar código de prueba rápido y sucio (quick and dirty) en una variedad de lenguajes de programación (es decir, C #, Java, Python y Ruby). Dada la mantenibilidad del código generado a través de Selenium IDE, no se recomienda usarlo para nada más que familiarizarse con los localizadores (locators) de elementos o generar código descartable (throw away code). Estamos seguros de que una vez que se acostumbre a la API WebDriver, nunca usará Selenium IDE.\nGrid Poco después del desarrollo de las pruebas de WebDriver, es posible que deba ejecutar sus pruebas en múltiples combinaciones de navegador y sistema operativo. Aquí es donde Grid viene al rescate.\nHTML Runner Esta herramienta le permite ejecutar Test Suites desde la línea de comandos. Las suites de prueba son exportaciones HTML desde Selenium IDE o herramientas compatibles. HTML Runner\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/selenium_installation/installing_selenium_libraries/",
	"title": "Instalación de las librerías Selenium",
	"tags": [],
	"description": "",
	"content": " Primero debe instalar las librerías de Selenium para su proyecto de automatización. El proceso de instalación de las librerías depende del lenguaje que elija usar.\nJava La instalación de las bibliotecas Selenium para Java se puede hacer usando Maven. Agregue la dependencia selenium-java en el archivo pom.xml de su proyecto:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.X\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; La dependencia de selenium-java admite la ejecución de su proyecto de automatización con todos los navegadores compatibles con Selenium. Si desea ejecutar pruebas solo en un navegador específico, puede agregar la dependencia para ese navegador en su archivo pom.xml. Por ejemplo, debe agregar la siguiente dependencia en su archivo pom.xml para ejecutar sus pruebas solo en Firefox:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-firefox-driver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.X\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; De manera similar, si desea ejecutar pruebas solo en Chrome, debe agregar la siguiente dependencia:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-chrome-driver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.X\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Python La instalación de las librerías de Selenium en Python se puede hacer usando pip:\npip install selenium Alternativamente, puede descargar el archivo fuente PyPI (selenium-x.x.x.tar.gz) e instalarlo usando setup.py:\npython setup.py install C# La instalación de las librerías de Selenium para C# se puede hacer usando NuGet:\n# Using package manager Install-Package Selenium.WebDriver # or using .Net CLI dotnet add package Selenium.WebDriver Ruby La instalación de las librerías de Selenium para Ruby se puede hacer usando gem:\ngem install selenium-webdriver JavaScript La instalación de las librerías de Selenium para JavaScript se puede hacer usando npm:\nnpm install selenium-webdriver"
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/guidelines_and_recommendations/page_object_models/",
	"title": "Modelos de objetos de página",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Page Object is a Design Pattern which has become popular in test automation for enhancing test maintenance and reducing code duplication. A page object is an object-oriented class that serves as an interface to a page of your AUT. The tests then use the methods of this page object class whenever they need to interact with that page of the UI. The benefit is that if the UI changes for the page, the tests themselves don’t need to change; only the code within the page object needs to change. Subsequently, all changes to support that new UI are located in one place.\nThe Page Object Design Pattern provides the following advantage: there is clean separation between test code and page specific code such as locators (or their use if you’re using a UI map) and layout.\nPage object methods should return a value  If you submit a page and are redirected, it should return the new page object. If you click submit on login and you want to check to see if a user is logged in, it should return True or False in a method.  "
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/support_packages/browser_navigation/",
	"title": "Navegación",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n There are commands for various webpage loading actions:\nJava Python C# Ruby JavaScript // Navigate to a URL (both of the statements below are // functionally equivalent). driver.get(\u0026#34;https://www.google.com\u0026#34;); driver.navigate().to(\u0026#34;https://www.google.com\u0026#34;); // Go forward one page in the browser (if you\u0026#39;re not on the // last page that was viewed). driver.navigate().forward(); // Go back one page in the browser (if you\u0026#39;re not on the // first page that was viewed). driver.navigate().back(); // Refresh the current page. driver.navigate().refresh();   # Navigate to a URL. driver.get(\u0026#39;https://www.google.com\u0026#39;) # Go forward one page in the browser (if you\u0026#39;re not on the # last page that was viewed). driver.forward() # Go back one page in the browser (if you\u0026#39;re not on the # first page that was viewed). driver.back() # Refresh the current page. driver.refresh()   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    # Navigate to a URL (both of the statements below are # functionally equivalent). driver.get(\u0026#39;https://www.google.com\u0026#39;) driver.navigate.to(\u0026#39;https://www.google.com\u0026#39;) # Go forward one page in the browser (if you\u0026#39;re not on the # last page that was viewed). driver.navigate.forward # Go back one page in the browser (if you\u0026#39;re not on the # first page that was viewed). driver.navigate.back # Refresh the current page. driver.navigate.refresh   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR      "
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/getting_started_with_webdriver/browsers/",
	"title": "Navegadores",
	"tags": [],
	"description": "",
	"content": " Navegadores (Browsers) de consumidores El marco Selenium admite oficialmente los siguientes navegadores:\n   Navegador Desarrollador Versiones soportadas     Chromium Chromium Todas las versiones   Firefox Mozilla 54 y recientes   Internet Explorer Selenium 6 y recientes   Opera Opera Chromium / Presto 10.5 y recientes   Safari Apple 10 y recientes    Navegadores especializados También hay un conjunto de navegadores especializados que generalmente se usan en entornos de desarrollo. También podemos utilizar algunos de estos navegadores para fines de automatización, y Selenium se vincula con el soporte para los siguientes controladores especializados:\n   Nombre del controlador Propósito Desarrollador     HtmlUnitDriver Emulador de navegador sin cabeza (headless) por Rhino Selenium project    "
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/getting_started/",
	"title": "Primeros pasos",
	"tags": [],
	"description": "",
	"content": " Primeros pasos Si es nuevo en Selenium, tenemos algunos recursos que pueden ayudarlo a ponerse al día de inmediato.\n Guía rápida  WebDriver Control Remoto IDE Grid HTML Runner   "
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/grid/purposes_and_main_functionalities/",
	"title": "Propósitos y funcionalidades principales",
	"tags": [],
	"description": "",
	"content": " Punto de entrada central para todas las pruebas Gestión y control de los nodos / entorno donde se ejecutan los navegadores Ejecución de pruebas a gran escala Ejecución de pruebas en paralelo Pruebas de diferentes plataformas (Cross-platform and cross-browser) Balanceo de carga  "
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/remote_webdriver/remote_webdriver_server/",
	"title": "WebDriver remoto - servidor",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n The server will always run on the machine with the browser you want to test. The server can be used either from the command line or through code configuration.\nStarting the server from the command line Once you have downloaded selenium-server-standalone-{VERSION}.jar, place it on the computer with the browser you want to test. Then, from the directory with the jar, run the following:\njava -jar selenium-server-standalone-{VERSION}.jar Considerations for running the server The caller is expected to terminate each session properly, calling either Selenium#stop() or WebDriver#quit.\nThe selenium-server keeps in-memory logs for each ongoing session, which are cleared when Selenium#stop() or WebDriver#quit is called. If you forget to terminate these sessions, your server may leak memory. If you keep extremely long-running sessions, you will probably need to stop/quit every now and then (or increase memory with -Xmx jvm option).\nTimeouts (from version 2.21) The server has two different timeouts, which can be set as follows:\njava -jar selenium-server-standalone-{VERSION}.jar -timeout=20 -browserTimeout=60  browserTimeout  Controls how long the browser is allowed to hang (value in seconds).  timeout  Controls how long the client is allowed to be gone before the session is reclaimed (value in seconds).   The system property selenium.server.session.timeout is no longer supported as of 2.21.\nPlease note that the browserTimeout is intended as a backup timeout mechanism when the ordinary timeout mechanism fails, which should be used mostly in grid/server environments to ensure that crashed/lost processes do not stay around for too long, polluting the runtime environment.\nConfiguring the server programmatically In theory, the process is as simple as mapping the DriverServlet to a URL, but it\u0026rsquo;s also possible to host the page in a lightweight container, such as Jetty configured entirely in code. Steps to do this follow.\nDownload the selenium-server.zip and unpack. Put the JARs on the CLASSPATH. Create a new class called AppServer. Here, I\u0026rsquo;m using Jetty, so you\u0026rsquo;ll need to download that as well:\nimport org.mortbay.jetty.Connector; import org.mortbay.jetty.Server; import org.mortbay.jetty.nio.SelectChannelConnector; import org.mortbay.jetty.security.SslSocketConnector; import org.mortbay.jetty.webapp.WebAppContext; import javax.servlet.Servlet; import java.io.File; import org.openqa.selenium.remote.server.DriverServlet; public class AppServer { private Server server = new Server(); public AppServer() throws Exception { WebAppContext context = new WebAppContext(); context.setContextPath(\u0026#34;\u0026#34;); context.setWar(new File(\u0026#34;.\u0026#34;)); server.addHandler(context); context.addServlet(DriverServlet.class, \u0026#34;/wd/*\u0026#34;); SelectChannelConnector connector = new SelectChannelConnector(); connector.setPort(3001); server.addConnector(connector); server.start(); } }"
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/driver_idiosyncrasies/driver_specific_capabilities/",
	"title": "Capacidades especificas de los controladores",
	"tags": [],
	"description": "",
	"content": " Firefox Definir Capacidades (Capabilities) usando FirefoxOptions FirefoxOptions es la nueva forma de definir capacidades para el navegador Firefox y, por lo general, debe usarse con preferencia a las capacidades deseadas.\nJava Python C# Ruby JavaScript FirefoxOptions options = new FirefoxOptions(); options.addPreference(\u0026#34;network.proxy.type\u0026#34;, 0); driver = new RemoteWebDriver(options);   from selenium.webdriver.firefox.options import Options options = Options() options.headless = True driver = webdriver.Firefox(options=options)   // Todavía no tenemos una muestra de código C#: ayúdenos y genere un PR (_pull request_)    # Todavía no tenemos una muestra de código Ruby: ayúdenos y genere un PR (_pull request_)   // Todavía no tenemos una muestra de código JavaScript: ayúdenos y genere un PR (_pull request_)      Configuración de un perfil personalizado Es posible crear un perfil personalizado para Firefox como se muestra a continuación.\nJava Python C# Ruby JavaScript FirefoxProfile profile = new FirefoxProfile(); FirefoxOptions options = new FirefoxOptions(); options.setProfile(profile); driver = new RemoteWebDriver(options);   from selenium.webdriver.firefox.options import Options from selenium.webdriver.firefox.firefox_profile import FirefoxProfile options=Options() firefox_profile = FirefoxProfile() firefox_profile.set_preference(\u0026#34;javascript.enabled\u0026#34;, False) options.profile = firefox_profile   // Todavía no tenemos una muestra de código C#: ayúdenos y genere un PR (_pull request_)    # Todavía no tenemos una muestra de código Ruby: ayúdenos y genere un PR (_pull request_)   // Todavía no tenemos una muestra de código JavaScript: ayúdenos y genere un PR (_pull request_)      Internet Explorer fileUploadDialogTimeout En algunos entornos, Internet Explorer puede agotar el tiempo de espera al abrir el cuadro de diálogo Cargar archivo. IEDriver tiene un tiempo de espera predeterminado de 1000 ms, pero puede aumentar el tiempo de espera usando la capability fileUploadDialogTimeout.\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/grid/components_of_a_grid/",
	"title": "Componentes de un Grid",
	"tags": [],
	"description": "",
	"content": " Concentrador o Hub  Intermediario y administrador Acepta solicitudes para ejecutar pruebas Toma instrucciones del cliente y las ejecuta de forma remota en los nodos Administra hilos  Un hub es un punto central al que se envían todas sus pruebas. Cada Selenium Grid consta de un centro exactamente. El concentrador debe ser accesible desde los respectivos clientes (es decir, servidor CI (Continuos Integration), máquina del desarrollador, etc.) El concentrador conectará uno o más nodos a los que se delegarán las pruebas.\nNodos  Aquí es donde viven los navegadores Se registra en el centro y comunica sus capacidades Recibe solicitudes del hub y las ejecuta  Los \u0026ldquo;nodos\u0026rdquo; son instancias diferentes de Selenium que ejecutarán pruebas en sistemas informáticos individuales. Puede haber muchos nodos en una grid. Las máquinas que son nodos no necesitan ser de la misma plataforma o tener la misma selección de navegador que la del concentrador u otros nodos. Un nodo en Windows podría tener la capacidad de ofrecer Internet Explorer como una opción de navegador, mientras que esto no sería posible en Linux o Mac.\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/getting_started_with_webdriver/third_party_drivers_and_plugins/",
	"title": "Controladores de otros fabricantes y plugins",
	"tags": [],
	"description": "",
	"content": "El Selenium se puede ampliar o extender mediante el uso de complementos (plugins). Aquí hay una serie de complementos creados y mantenidos por terceros. Para obtener más información sobre cómo crear su propio complemento o tenerlo en la lista, consulte los documentos.\nTenga en cuenta que estos complementos no son compatibles, mantenidos, alojados o respaldados por el proyecto Selenium. Además, tenga en cuenta que los complementos que se enumeran a continuación no están necesariamente autorizados bajo la licencia Apache v.2.0. Algunos de los complementos están disponibles bajo otra licencia de software libre y de código abierto; otros solo están disponibles bajo una licencia patentada. Cualquier pregunta sobre los complementos y su licencia de distribución debe plantearse con sus respectivos desarrolladores.\n   Navegador Versión reciente Control de cambios Hallazgos Documentación     Google ChromeDriver 2.29 changelog issues wiki    "
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/front_matter/typographical_conventions/",
	"title": "Convenciones tipográficas",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Capitalisation of titles One should avoid title capitalisation, such as A Very Fine Heading, and instead go for A very fine heading. Gratutious capitalisation, or title case, often show a misunderstanding of – or a disregard for – orthographic conventions. We prefer what is known as sentence case, with a single initial capital to start headers.\nLine length When editing the documentation’s source, which is written in plain HTML, limit your line lengths to around 72 characters.\nSome of us take this one step further and use what is called semantic linefeeds, which is a technique whereby the HTML source lines, which are not read by the public, are split at ‘natural breaks’ in the prose. In other words, sentences are split at natural breaks between clauses. Instead of fussing with the lines of each paragraph so that they all end near the right margin, linefeeds can be added anywhere that there is a break between ideas.\nThis can make diffs very easy to read when collaborating through git, but it is not something we enforce contributors to use.\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/worst_practices/file_downloads/",
	"title": "Descarga de archivos",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Whilst it is possible to start a download by clicking a link with a browser under Selenium\u0026rsquo;s control, the API does not expose download progress, making it less than ideal for testing downloaded files. This is because downloading files is not considered an important aspect of emulating user interaction with the web platform. Instead, find the link using Selenium (and any required cookies) and pass it to a HTTP request library like libcurl.\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/getting_started/html-runner/",
	"title": "HTML runner",
	"tags": [],
	"description": "",
	"content": " Selenium HTML-runner le permite ejecutar Test Suites desde una línea de comandos. Las suites de prueba son exportaciones HTML desde Selenium IDE o herramientas compatibles.\nInformación común  La combinación de lanzamientos de geckodriver / firefox / selenium-html runner es importante. Puede haber una matriz de compatibilidad de software en alguna parte. selenium-html-runner solo ejecuta Test Suite (no Test Case, lo que es, por ejemplo, una exportación de Monitis Transaction Monitor). Asegúrese de cumplir con esto. Para usuarios de Linux sin PANTALLA: debe iniciar html-runner con pantalla virtual (busque xvfb).  Ejemplo de un entorno Linux Descargue e instale los siguientes paquetes de software:\n[user@localhost ~]$ cat /etc/redhat-release CentOS Linux release 7.4.1708 (Core) [user@localhost ~]$ rpm -qa | egrep -i \u0026#34;xvfb|java-1.8|firefox\u0026#34; xorg-x11-server-Xvfb-1.19.3-11.el7.x86_64 firefox-52.4.0-1.el7.centos.x86_64 java-1.8.0-openjdk-1.8.0.151-1.b12.el7_4.x86_64 java-1.8.0-openjdk-headless-1.8.0.151-1.b12.el7_4.x86_64 Ejemplo de la Test Suite:\n[user@localhost ~]$ cat testsuite.html \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE html PUBLIC \u0026#34;-//W3C//DTD XHTML 1.0 Strict//EN\u0026#34; \u0026#34;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\u0026#34;\u0026gt; \u0026lt;html xmlns=\u0026#34;http://www.w3.org/1999/xhtml\u0026#34; xml:lang=\u0026#34;es\u0026#34; lang=\u0026#34;es\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta content=\u0026#34;text/html; charset=UTF-8\u0026#34; http-equiv=\u0026#34;content-type\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Test Suite\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table id=\u0026#34;suiteTable\u0026#34; cellpadding=\u0026#34;1\u0026#34; cellspacing=\u0026#34;1\u0026#34; border=\u0026#34;1\u0026#34; class=\u0026#34;selenium\u0026#34;\u0026gt;\u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;b\u0026gt;Test Suite\u0026lt;/b\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;YOUR-TEST-SCENARIO.html\u0026#34;\u0026gt;SU-ESCENARIO-DE-PRUEBAS\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt;\u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Cómo ejecutar el elenium-html-runner sin cabeza (headless) Ahora, la parte más importante, ¡un ejemplo de cómo ejecutar selenium-html-runner! Su experiencia puede variar según las combinaciones de software: versiones geckodriver / Firefox / html-runner.\nxvfb-run java -Dwebdriver.gecko.driver=/home/mmasek/geckodriver.0.18.0 -jar selenium-html-runner-3.7.1.jar -htmlSuite \u0026#34;firefox\u0026#34; \u0026#34;https://YOUR-BASE-URL\u0026#34; \u0026#34;$(pwd)/testsuite.html\u0026#34; \u0026#34;results.html\u0026#34; ; grep result: -A1 results.html/firefox.results.html[user@localhost ~]$ xvfb-run java -Dwebdriver.gecko.driver=/home/mmasek/geckodriver.0.18.0 -jar selenium-html-runner-3.7.1.jar -htmlSuite \u0026#34;*firefox\u0026#34; \u0026#34;https://YOUR-BASE-URL\u0026#34; \u0026#34;$(pwd)/testsuite.html\u0026#34; \u0026#34;results.html\u0026#34; ; grep result: -A1 results.html/firefox.results.html Multi-window mode is longer used as an option and will be ignored. 1510061109691 geckodriver INFO geckodriver 0.18.0 1510061109708 geckodriver INFO Listening on 127.0.0.1:2885 1510061110162 geckodriver::marionette INFO Starting browser /usr/bin/firefox with args [\u0026#34;-marionette\u0026#34;] 1510061111084 Marionette INFO Listening on port 43229 1510061111187 Marionette WARN TLS certificate errors will be ignored for this session Nov 07, 2017 1:25:12 PM org.openqa.selenium.remote.ProtocolHandshake createSession INFO: Detected dialect: W3C 2017-11-07 13:25:12.714:INFO::main: Logging initialized @3915ms to org.seleniumhq.jetty9.util.log.StdErrLog 2017-11-07 13:25:12.804:INFO:osjs.Server:main: jetty-9.4.z-SNAPSHOT 2017-11-07 13:25:12.822:INFO:osjsh.ContextHandler:main: Started o.s.j.s.h.ContextHandler@87a85e1{/tests,null,AVAILABLE} 2017-11-07 13:25:12.843:INFO:osjs.AbstractConnector:main: Started ServerConnector@52102734{HTTP/1.1,[http/1.1]}{0.0.0.0:31892} 2017-11-07 13:25:12.843:INFO:osjs.Server:main: Started @4045ms Nov 07, 2017 1:25:13 PM org.openqa.selenium.server.htmlrunner.CoreTestCase run INFO: |open | /auth_mellon.php | | Nov 07, 2017 1:25:14 PM org.openqa.selenium.server.htmlrunner.CoreTestCase run INFO: |waitForPageToLoad | 3000 | | . . .etc \u0026lt;td\u0026gt;result:\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;PASS\u0026lt;/td\u0026gt;"
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/selenium_installation/installing_webdriver_binaries/",
	"title": "Instalación de las librerías WebDriver",
	"tags": [],
	"description": "",
	"content": "Para ejecutar su proyecto y controlar el navegador, debe tener instalados los binarios de WebDriver específicos del navegador.\nDescargue el binario del WebDriver compatible con su navegador y colóquelo en el RUTA o PATH del sistema.\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/introduction/",
	"title": "Introducción",
	"tags": [],
	"description": "",
	"content": " Introducción Selenium es un proyecto que cobija una gama de herramientas y bibliotecas que permiten y soportan la automatización de los navegadores web.\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/guidelines_and_recommendations/domain_specific_language/",
	"title": "Lenguage de dominio específico",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n A domain specific language (DSL) is a system which provides the user with an expressive means of solving a problem. It allows a user to interact with the system on their terms – not just programmer-speak.\nYour users, in general, don\u0026rsquo;t care how your site looks. They don\u0026rsquo;t care about the decoration, animations, or graphics. They want to use your system to push their new employees through the process with minimal difficulty. They want to book travel to Alaska. They want to configure and buy unicorns at a discount. Your job as the tester is to come as close as you can to “capturing” this mind-set. With that in mind, we set about “modeling” the application you\u0026rsquo;re working on, such that the test scripts (the user\u0026rsquo;s only pre-release proxy) “speak” for and represent the user.\nWith Selenium, DSL is usually represented by methods, written to make the API simple and readable – they enable a report between the developers and the stakeholders (users, product owners, business intelligence specialists, etc.).\nBenefits  Readable: Business stakeholders can understand it. Writable: Easy to write, avoids unnecessary duplication. Extensible: Functionality can (reasonably) be added without breaking contracts and existing functionality. Maintainable: By leaving the implementation details out of test cases, you are well-insulated against changes to the AUT (application under test).  Java Here is an example of a reasonable DSL method in Java. For brevity\u0026rsquo;s sake, it assumes the driver object is pre-defined and available to the method.\n/** * Takes a username and password, fills out the fields, and clicks \u0026#34;login\u0026#34;. * @return An instance of the AccountPage */ public AccountPage loginAsUser(String username, String password) { WebElement loginField = driver.findElement(By.id(\u0026#34;loginField\u0026#34;)); loginField.clear(); loginField.sendKeys(username); // Fill out the password field. The locator we\u0026#39;re using is \u0026#34;By.id\u0026#34;, and we should  // have it defined elsewhere in the class.  WebElement passwordField = driver.findElement(By.id(\u0026#34;password\u0026#34;)); passwordField.clear(); passwordField.sendKeys(password); // Click the login button, which happens to have the id \u0026#34;submit\u0026#34;.  driver.findElement(By.id(\u0026#34;submit\u0026#34;)).click(); // Create and return a new instance of the AccountPage (via the built-in Selenium  // PageFactory).  return PageFactory.newInstance(AccountPage.class); } This method completely abstracts the concepts of input fields, buttons, clicking, and even pages from your test code. Using this approach, all your tester has to do is call this method. This gives you a maintenance advantage: if the login fields ever changed, you would only ever have to change this method - not your tests.\npublic void loginTest() { loginAsUser(\u0026#34;cbrown\u0026#34;, \u0026#34;cl0wn3\u0026#34;); // Now that we\u0026#39;re logged in, do some other stuff--since we used a DSL to support  // our testers, it\u0026#39;s as easy as choosing from available methods.  do.something(); do.somethingElse(); Assert.assertTrue(\u0026#34;Something should have been done!\u0026#34;, something.wasDone()); // Note that we still haven\u0026#39;t referred to a button or web control anywhere in this  // script... } It bears repeating: one of your primary goals should be writing an API that allows your tests to address the problem at hand, and NOT the problem of the UI. The UI is a secondary concern for your users – they don\u0026rsquo;t care about the UI, they just want to get their job done. Your test scripts should read like a laundry list of things the user wants to DO, and the things they want to KNOW. The tests should not concern themselves with HOW the UI requires you to go about it.\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/webdriver/driver_requirements/",
	"title": "Requerimientos de los controladores",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Through WebDriver, Selenium supports all major browsers on the market such as Chrom(ium), Firefox, Internet Explorer, Opera, and Safari. Where possible, WebDriver drives the browser using the browser\u0026rsquo;s built-in support for automation, although not all browsers have official support for remote control.\nWebDriver\u0026rsquo;s aim is to emulate a real user\u0026rsquo;s interaction with the browser as closely as possible. This is possible at varying levels in different browsers. For more details on the different driver idiosyncracies, please see Driver Idiosyncracies.\nEven though all the drivers share a single user-facing interface for controlling the browser, they have slightly different ways of setting up browser sessions. Since many of the driver implementations are provided by third parties, they are not included in the standard Selenium distribution.\nDriver instantiation, profile management, and various browser specific settings are examples of parameters that have different requirements depending on the browser. This section explains the basic requirements for getting you started with the different browsers.\nAdding Executables to your PATH Most drivers require an extra executable for Selenium to communicate with the browser. You can manually specify where the executable lives before starting WebDriver, but this can make your tests less portable, as the executables will need to be in the same place on every machine, or included within your test code repository.\nBy adding a folder containing WebDriver\u0026rsquo;s binaries to your system\u0026rsquo;s path, Selenium will be able to locate the additional binaries without requiring your test code to locate the exact location of the driver.\n Create a directory to place the executables in, like C:\\WebDriver\\bin or /opt/WebDriver/bin Add the directory to your PATH:\n On Windows - Open a command prompt as administrator and the run the following command to permanently add the directory to your path for all users on your machine:\nsetx /m path \u0026#34;%path%;C:\\WebDriver\\bin\\\u0026#34; Bash users on macOS and Linux - In a terminal:\nexport PATH=$PATH:/opt/WebDriver/bin \u0026gt;\u0026gt; ~/.profile  You are now ready to test your changes. Close all open command prompts and open a new one. Type out the name of one of the binaries in the folder you created in the previous step, e.g:\nchromedriver If your PATH is configured correctly, you will see some some output relating to the startup of the driver:\nStarting ChromeDriver 2.25.426935 (820a95b0b81d33e42712f9198c215f703412e1a1) on port 9515 Only local connections are allowed.  You can regain control of your command prompt by pressing Ctrl + C\nQuick reference    Browser Supported OS Maintained by Download Issue Tracker     Chromium/Chrome Windows/macOS/Linux Google Downloads Issues   Firefox Windows/macOS/Linux Mozilla Downloads Issues   Edge Windows 10 Microsoft Downloads Issues   Internet Explorer Windows Selenium Project Downloads Issues   Safari macOS El Capitan and newer Apple Built in Issues   Opera Windows/macOS/Linux Opera Downloads Issues    Chromium/Chrome To drive Chrome or Chromium, you have to download chromedriver and put it in a folder that is on your system\u0026rsquo;s path.\nOn Linux or macOS, this means modifying the PATH environmental variable. You can see what directories, separated by a colon, make up your system\u0026rsquo;s path by executing the following command:\n$ echo $PATH /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin To include chromedriver on the path if it isn\u0026rsquo;t already, make sure you include the chromedriver binary\u0026rsquo;s parent directory. The following line will set the PATH environmental variable its current content, plus an additional path added after the colon:\n$ export PATH=\u0026#34;$PATH:/path/to/chromedriver\u0026#34; When chromedriver is available on your path, you should be able to execute the chromedriver executable from any directory.\nTo instantiate a Chrome/Chromium session, you can do the following:\nJava Python C# Ruby JavaScript import org.openqa.selenium.WebDriver; import org.openqa.selenium.chrome.ChromeDriver; WebDriver driver = new ChromeDriver();   #Simple assignment from selenium.webdriver import Chrome driver = Chrome() #Or use the context manager from selenium.webdriver import Chrome with Chrome() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; IWebDriver driver = new ChromeDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :chrome   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); const chrome = require(\u0026#39;selenium-webdriver/chrome\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); //your code inside this block })();     Remember that you have to set the path to the chromedriver executable. This is possible using the following line:\nJava Python C# Ruby JavaScript System.setProperty(\u0026#34;webdriver.chrome.driver\u0026#34;, \u0026#34;/path/to/chromedriver\u0026#34;);   Chrome(executable_path=\u0026#39;/path/to/chromedriver\u0026#39;)   new ChromeDriver(\u0026#34;/path/to/chromedriver\u0026#34;);   Selenium::WebDriver::Chrome.driver_path = \u0026#34;/path/to/chromedriver\u0026#34;   chrome.setDefaultService(new chrome.ServiceBuilder(\u0026#39;path/to/chromedriver\u0026#39;).build());     The chromedriver is implemented as a WebDriver remote server that by exposing Chrome\u0026rsquo;s internal automation proxy interface instructs the browser what to do.\nFirefox Starting with Selenium 3, Mozilla has taken over implementation of Firefox Driver, with geckodriver. The new driver for Firefox is called geckodriver and works with Firefox 48 and newer. Since the Firefox WebDriver is under development, the newer the Firefox version the better the support.\nAs geckodriver is the new default way of launching Firefox, you can instantiate Firefox in the same way as Selenium 2:\nJava Python C# Ruby JavaScript import org.openqa.selenium.WebDriver; import org.openqa.selenium.Firefox.FirefoxDriver; WebDriver driver = new FirefoxDriver();   #Simple assignment from selenium.webdriver import Firefox driver = Firefox() #Or use the context manager from selenium.webdriver import Firefox with Firefox() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.Firefox; IWebDriver driver = new FirefoxDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :firefox   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); //your code inside this block })();     If you prefer not to set geckodriver\u0026rsquo;s location using PATH, set the geckodriver binary location programmatically:\nJava Python C# Ruby JavaScript System.setProperty(\u0026#34;webdriver.gecko.driver\u0026#34;, \u0026#34;/path/to/geckodriver\u0026#34;);   Firefox(executable_path=\u0026#39;/path/to/geckodriver\u0026#39;)   new FirefoxDriver(\u0026#34;/path/to/geckodriver\u0026#34;);   Selenium::WebDriver::Firefox.driver_path = \u0026#34;/path/to/geckodriver\u0026#34;   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR      It is also possible to set the property at run time:\nmvn test -Dwebdriver.gecko.driver=/path/to/geckodriver It is currently possible to revert to the older, more feature complete Firefox driver, by installing Firefox 47.0.1 or 45 ESR and specifying a desired capability of marionette as false. Later releases of Firefox are no longer compatible.\nEdge Edge is Microsoft\u0026rsquo;s newest browser, included with Windows 10 and Server 2016. Updates to Edge are bundled with major Windows updates, so you\u0026rsquo;ll need to download a binary which matches the build number of your currently installed build of Windows. The Edge Developer site contains links to all the available binaries. Bugs against the EdgeDriver implementation can be raised with Microsoft. If you\u0026rsquo;d like to run tests against Edge, but aren\u0026rsquo;t running Windows 10, Microsoft offer free VMs for testers on the Edge Developer site.\nJava Python C# Ruby JavaScript import org.openqa.selenium.WebDriver; import org.openqa.selenium.edge.EdgeDriver; WebDriver driver = new EdgeDriver();   #Simple assignment from selenium.webdriver import Edge driver = Edge() #Or use the context manager from selenium.webdriver import Edge with Edge() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.Edge; IWebDriver driver = new EdgeDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :edge   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;MicrosoftEdge\u0026#39;).build(); //your code inside this block })();     If Edge driver is not present in your path, you can set the path using the following line:\nJava Python C# Ruby JavaScript System.setProperty(\u0026#34;webdriver.edge.driver\u0026#34;, \u0026#34;C:/path/to/MicrosoftWebDriver.exe\u0026#34;);   Edge(executable_path=\u0026#39;/path/to/MicrosoftWebDriver.exe\u0026#39;)   new EdgeDriver(\u0026#34;/path/to/MicrosoftWebDriver.exe\u0026#34;);   Selenium::WebDriver::Edge.driver_path = \u0026#34;C:/path/to/MicrosoftWebDriver.exe\u0026#34;   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR      Internet Explorer Internet Explorer was Microsoft\u0026rsquo;s default browser until Windows 10, although it is still included in Windows 10. Internet Explorer Driver is the only driver The Selenium project aims to support the same releases Microsoft considers current. Older releases may work, but will be unsupported.\nWhile the Selenium project provides binaries for both the 32-bit and 64-bit versions of Internet Explorer, there are some limitations with Internet Explorer 10 \u0026amp; 11 with the 64-bit driver, but using the 32-bit driver continues to work well. It should be noted that as Internet Explorer preferences are saved against the logged in user\u0026rsquo;s account, some additional setup is required.\nJava Python C# Ruby JavaScript import org.openqa.selenium.WebDriver; import org.openqa.selenium.ie.InternetExplorerDriver; WebDriver driver = new InternetExplorerDriver();   #Simple assignment from selenium.webdriver import Ie driver = Ie() #Or use the context manager from selenium.webdriver import Ie with Ie() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.IE; IWebDriver driver = new InternetExplorerDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :internet_explorer   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;internet explorer\u0026#39;).build(); //your code inside this block })();     If Internet Explorer driver is not present in your path, you can set the path using the following line:\nJava Python C# Ruby JavaScript System.setProperty(\u0026#34;webdriver.ie.driver\u0026#34;, \u0026#34;C:/path/to/IEDriver.exe\u0026#34;);   Ie(executable_path=\u0026#39;/path/to/IEDriverServer.exe\u0026#39;)   new InternetExplorerDriver(\u0026#34;C:/path/to/IEDriver.exe\u0026#34;);   Selenium::WebDriver::IE.driver_path = \u0026#34;C:/path/to/IEDriver.exe\u0026#34;   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR      Microsoft also offer a WebDriver binary for Internet Explorer 11 on Windows 7 \u0026amp; 8.1. It has not been updated since 2014 and is based of a draft version of the W3 specification. Jim Evans has an excellent writeup on Microsoft\u0026rsquo;s implementation.\nOpera Current releases of Opera are built on top of the Chromium engine, and WebDriver is now supported via the closed-source Opera Chromium Driver, which can be added to your PATH or as a system property.\nInstantiating a driver session is similar to Firefox and Chromium:\nJava Python C# Ruby JavaScript import org.openqa.selenium.WebDriver; import org.openqa.selenium.opera.OperaDriver; WebDriver driver = new OperaDriver();   #Simple assignment from selenium.webdriver import Opera driver = Opera() #Or use the context manager from selenium.webdriver import Opera with Opera() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.Opera; IWebDriver driver = new OperaDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :opera   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR      Safari Starting with Safari 10 on macOS El Capitan and Sierra, WebDriver support is included with each release of the browser. To enable support:\n Enable the Developer menu from Safari preferences Check the Allow Remote Automation option from with the Develop menu Run the following command from the terminal for the first time and type your password at the prompt to authorise WebDriver\n/usr/bin/safaridriver -p 1337\u0026lt;/  You can then start a driver session using:\nJava Python C# Ruby JavaScript import org.openqa.selenium.WebDriver; import org.openqa.selenium.safari.SafariDriver; WebDriver driver = new SafariDriver();   #Simple assignment from selenium.webdriver import Safari driver = Safari() #Or use the context manager from selenium.webdriver import Safari with Safari() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.Safari; IWebDriver driver = new SafariDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :safari   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;safari\u0026#39;).build(); //your code inside this block })();     Those looking to automate Safari on iOS should look to the Appium project. Whilst Safari was previously available for Windows, Apple has long since dropped support, making it a poor choice of test platform.\nMock browsers HtmlUnit HtmlUnit is a \u0026ldquo;GUI-Less browser for Java programs\u0026rdquo;. It models HTML documents and provides an API that allows you to invoke pages, fill out forms, click links, etc. It has JavaScript support and is able to work with AJAX libraries, simulating Chrome, Firefox or Internet Explorer depending on the configuration used. It has been moved to a new location. The source is maintained on svn.\nPhantomJS PhantomJS is a headless browser based on Webkit, albeit a version much older than that used by Google Chrome or Safari. Whilst historically a popular choice, it would now be wise to avoid PhantomJS. The project has been unmaintained since the 5th of August, so whilst the web will continue to change, PhantomJS will not be updated. This was after Google announced the ability to run Chrome headlessly, something also now offered by Mozilla\u0026rsquo;s Firefox.\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/introduction/on_test_automation/",
	"title": "Sobre automatización de pruebas",
	"tags": [],
	"description": "",
	"content": " Antes que nada, pregúntese si realmente necesita o no usar un navegador. Las probabilidades son buenas de que, en algún momento, si está trabajando en una aplicación web compleja, necesitará abrir un navegador y probarla.\nSin embargo, las pruebas funcionales de usuario final, como las pruebas de Selenium, son caras de ejecutar. Además, por lo general requieren una infraestructura sustancial para poder funcionar de manera efectiva. Es una buena regla preguntarse siempre si lo que desea probar se puede hacer utilizando enfoques de prueba más livianos, como pruebas unitarias o con un enfoque de nivel inferior.\nUna vez que haya tomado la determinación de que está en el negocio de las pruebas con un navegador web, y tenga su entorno Selenium listo para comenzar a escribir las pruebas, generalmente realizará una combinación de tres pasos:\n Configurar los datos Realizar un conjunto discreto de acciones Evaluar los resultados  Deberá mantener estos pasos lo más cortos posible; una o dos operaciones deberían ser suficientes la mayor parte del tiempo. La automatización del navegador tiene la reputación de ser \u0026ldquo;inestable\u0026rdquo;, pero en realidad eso se debe a que los usuarios suelen exigir demasiado. En capítulos posteriores, volveremos a las técnicas que puede usar para mitigar aparentes problemas intermitentes en las pruebas, en particular sobre cómo superar las condiciones de carrera entre el navegador y WebDriver.\nAl mantener sus pruebas cortas y usar el navegador web solo cuando no tiene absolutamente ninguna alternativa, puede realizar muchas pruebas con un minimo desgaste.\nUna ventaja distintiva de las pruebas de Selenium es su capacidad inherente para probar todos los componentes de la aplicación, desde el backend hasta el frontend, desde la perspectiva del usuario. En otras palabras, si bien las pruebas funcionales pueden ser costosas de ejecutar, también abarcan grandes porciones críticas para el negocio al mismo tiempo.\nRequisitos de prueba Como se mencionó anteriormente, las pruebas de Selenium pueden ser costosas de ejecutar. Incluso depende del navegador con el que esté ejecutando las pruebas, pero históricamente el comportamiento de los navegadores ha variado tanto que a menudo ha sido un objetivo declarado realizar pruebas con múltiples navegadores (cross browser).\nSelenium le permite ejecutar las mismas instrucciones en múltiples navegadores y en múltiples sistemas operativos, pero la enumeración de todos los navegadores posibles, sus diferentes versiones y los muchos sistemas operativos en los que se ejecutan se le convertirá rápidamente en una tarea compleja.\nComencemos con un ejemplo Larry ha escrito un sitio web que permite a los usuarios ordenar sus propios unicornios personalizados.\nEl flujo de trabajo general (lo que llamaremos el \u0026ldquo;camino feliz\u0026rdquo;) es algo como esto:\n Crea una cuenta Configurar tu unicornio Agrégalo al carrito de compras Echa un vistazo y paga Dar comentarios sobre tu unicornio  Sería tentador escribir un gran script Selenium para realizar todas estas operaciones, muchos lo intentarán. ¡Resista la tentación! Hacerlo dará como resultado una prueba que a) lleva mucho tiempo, b) estará sujeto a algunos problemas comunes relacionados con los problemas de tiempo de renderizado de la página, y c) es tal que si falla, no le dará un método conciso y \u0026ldquo;fácil de ver\u0026rdquo; para diagnosticar lo que salió mal.\nLa estrategia preferida para probar este escenario sería dividirlo en una serie de pruebas rápidas e independientes, cada una de las cuales tiene una \u0026ldquo;razón\u0026rdquo; para existir.\nSupongamos que quieres probar el segundo paso: Configurando tu unicornio. Deberá realizar las siguientes acciones:\n Crea una cuenta Configurar un unicornio  Tenga en cuenta que estamos omitiendo el resto de estos pasos, probaremos el resto del flujo de trabajo en otros casos de prueba pequeños y discretos, una vez que hayamos terminado con este.\nPara comenzar, debe crear una cuenta. Aquí tienes algunas opciones a resolver:\n ¿Quieres usar una cuenta existente? ¿Quieres crear una nueva cuenta? ¿Hay alguna propiedad especial de dicho usuario que deba tenerse en cuenta antes de que comience la configuración?  Independientemente de cómo responda estas preguntas, la solución es hacer que forme parte del flujo de \u0026ldquo;configurar los datos\u0026rdquo; de la prueba –si Larry ha expuesto una API que le permite a usted (o cualquier persona) crear y actualizar cuentas de usuario, asegúrese de usarla para responder esta situación– si es posible, lo deseable es iniciar el navegador solo después de tener un usuario disponible, cuyas credenciales le permitan iniciar sesión.\nSi cada prueba para cada flujo de trabajo comienza con la creación de una cuenta de usuario, se agregarán muchos segundos a la ejecución de cada prueba. Llamar a una API y hablar con una base de datos son operaciones rápidas y sin interfaz gráfica (headless) que no requieren el costoso proceso de abrir un navegador, navegar a las páginas correctas, hacer clic y esperar a que se envíen los formularios, etc.\nIdealmente, puede abordar esta fase de configuración en una línea de código, que se ejecutará antes de que se inicie cualquier navegador:\nJava Python C# Ruby JavaScript // Cree un usuario que tenga permisos de solo lectura: puede configurar un unicornio, // pero no tienen configurada la información de pago, ni tienen // privilegios administrativos. En el momento en que se cree el usuario, su correo electrónico // la dirección y la contraseña se generan aleatoriamente; ni siquiera necesita // conocerlos. User user = UserFactory.createCommonUser(); // Este método se define en otra parte.  // Inicie sesión como este usuario. // Iniciar sesión en este sitio lo lleva a su página personal \u0026#34;Mi cuenta\u0026#34;, por lo que // El método loginAs devuelve el objeto AccountPage, lo que le permite // realiza acciones desde AccountPage. AccountPage accountPage = loginAs(user.getEmail(), user.getPassword());   # Cree un usuario que tenga permisos de solo lectura: puede configurar un unicornio, # pero no tienen configurada la información de pago, ni tienen # Privilegios administrativos. En el momento en que se crea el usuario, su correo electrónico # la dirección y la contraseña se generan aleatoriamente; ni siquiera necesita # conocerlos. user = user_factory.create_common_user() #Este método se define en otra parte. # Inicie sesión como este usuario. # Iniciar sesión en este sitio lo lleva a su página personal \u0026#34;Mi cuenta\u0026#34;, por lo que # El objeto loginAs devuelve el objeto AccountPage, lo que le permite # realizar acciones desde la página de cuenta. account_page = login_as(user.get_email(), user.get_password())   // Todavía no tenemos una muestra de código C# - ayúdenos y genere un PR (pull request)    # Todavía no tenemos una muestra de código en Ruby - ayúdenos y genere un PR (pull request)   // Todavía no tenemos una muestra de código JavaScript - ayúdenos y genere un PR (pull request)      Como se puede imaginar, la UserFactory se puede ampliar para proporcionar métodos como createAdminUser() y createUserWithPayment(). El punto es que estas dos líneas de código no le distraigan del objetivo final de esta prueba: configurar un unicornio.\nLas complejidades del Modelo de objeto de página (Page Object Model) se analizarán en capítulos posteriores, pero presentaremos el concepto aquí:\nSus pruebas deben estar compuestas de acciones, realizadas desde el punto de vista del usuario, dentro del contexto de las páginas del sitio. Estas páginas se almacenan como objetos, que contendrán información específica sobre cómo se compone la página web y cómo se realizan las acciones, muy poco de lo que debería preocuparte como tester.\n¿Qué tipo de unicornio quieres? Es posible que desee rosa, pero no necesariamente. El morado ha sido muy popular últimamente. ¿El necesita gafas de sol? ¿Tatuajes de estrellas? Estas elecciones, si bien son difíciles, son su principal preocupación como probador: debe asegurarse de que su centro de cumplimiento de pedidos envíe el unicornio correcto a la persona adecuada, y eso comienza con estas elecciones.\nObserve que en ninguna parte de ese párrafo hablamos de botones, campos, menús desplegables, botones de opción o formularios web. ¡Tampoco debería hacerlo sus pruebas! Lo deseable es escribir el código como el usuario que intenta resolver su problema. Aquí hay una forma de hacerlo (continuando con el ejemplo anterior):\nJava Python C# Ruby JavaScript // El Unicornio es un Objeto de nivel superior: tiene atributos, que se establecen aquí. // Esto solo almacena los valores; no llena ningún formulario web ni interactúa // con el navegador de cualquier manera. Unicorn sparkles = new Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS); // Como ya estamos \u0026#34;en\u0026#34; la página de la cuenta, tenemos que usarla para acceder al // lugar real donde configuras unicornios. Llamando al método \u0026#34;addUnicorn\u0026#34; // nos lleva allí. AddUnicornPage addUnicornPage = accountPage.addUnicorn(); // Ahora que estamos en AddUnicornPage, pasaremos el objeto \u0026#34;sparkles\u0026#34; // al método createUnicorn(). Este método tomará los atributos de Sparkles, // llena el formulario y hace clic en el botón enviar. UnicornConfirmationPage unicornConfirmationPage = addUnicornPage.createUnicorn(sparkles);   # El Unicornio es un Objeto de nivel superior: tiene atributos, que se establecen aquí. # Esto solo almacena los valores; no llena ningún formulario web ni interactúa # con el navegador de cualquier manera. sparkles = Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS) # Como ya estamos \u0026#34;en\u0026#34; la página de la cuenta, tenemos que usarla para acceder a # lugar real donde se configuran los unicornios. Llamando al método \u0026#34;addUnicorn\u0026#34; # nos lleva allí. add_unicorn_page = account_page.add_unicorn() # Ahora que estamos en AddUnicornPage, pasaremos el objeto \u0026#34;sparkles\u0026#34; a # su método createUnicorn(). Este método tomará los atributos de Sparkles, # completará el formulario y haga clic en enviar. unicorn_confirmation_page = add_unicorn_page.create_unicorn(sparkles)   // Todavía no tenemos una muestra de código en C# - ayúdanos y genera un PR (pull request)    # Todavía no tenemos una muestra de código en Ruby - ayúdanos y genera un PR (pull request)   // Todavía no tenemos una muestra de código en JavaScript - ayúdanos y genera un PR (pull request)      Ahora que ha configurado su unicornio, debe continuar al paso 3: asegurarse de que realmente funcionó.\nJava Python C# Ruby JavaScript // El método exist() de UnicornConfirmationPage tomará Sparkles // objeto: una especificación de los atributos que desea ver y compararlos // con los campos en la página. Assert.assertTrue(\u0026#34;Deben haberse creado Sparkles, con todos los atributos intactos.\u0026#34;, unicornConfirmationPage.exists(sparkles));   # El método exist() de UnicornConfirmationPage tomará Sparkles # objeto: una especificación de los atributos que desea ver y compararlos # con los campos en la página. assert unicorn_confirmation_page.exists(sparkles), \u0026#34;Sparkles should have been created, with all attributes intact\u0026#34;   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    # Todavía no tenemos una muestra de código en Ruby - ayúdanos y genera un PR (pull request)   // Todavía no tenemos una muestra de código en JavaScript - ayúdanos y genera un PR (pull request)      Tenga en cuenta que el tester aún no ha hecho nada más que hablar de unicornios en este código, sin botones, sin localizadores, sin controles del navegador. Este método de \u0026ldquo;modelado\u0026rdquo; de la aplicación le permite mantener estos comandos de nivel de prueba en su lugar y sin cambios, incluso si Larry decide la próxima semana que ya no le gusta Ruby-on-Rails y decide volver a implementar todo el sitio con las librerías más recientes de Haskell y con un front-end en Fortran.\nLos objetos de su página requerirán un pequeño mantenimiento para cumplir con el rediseño del sitio, pero estas pruebas seguirán siendo las mismas. Tomando este diseño básico, querrá continuar con sus flujos de trabajo con la menor cantidad posible de pasos orientados hacia el navegador. Su próximo flujo de trabajo implicará agregar un unicornio al carrito de compras. Probablemente requeriá muchas iteraciones de esta prueba para asegurarse de que el carrito mantenga su estado correctamente: ¿Hay más de un unicornio en el carrito antes de comenzar? ¿Cuántos pueden caber en el carrito de compras? Si crea más de uno con el mismo nombre o características, ¿se romperá? ¿Conservará solo el existente o agregará otro?\nCada vez que se mueva por el flujo de trabajo, debe intentar evitar tener que crear una cuenta, iniciar sesión como usuario y configurar el unicornio. Idealmente, podrá crear una cuenta y preconfigurar un unicornio a través de la API o la base de datos. Luego, todo lo que tiene que hacer es iniciar sesión como usuario, localizar Sparkles y agregarla al carrito.\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/support_packages/working_with_colours/",
	"title": "Trabajando con colores",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n You will occasionally want to validate the colour of something as part of your tests; the problem is that colour definitions on the web are not constant. Wouldn\u0026rsquo;t it be nice if there was an easy way to compare a HEX representation of a colour with an RGB representation of a colour, or an RGBA representation of a colour with a HSLA representation of a colour?\nWorry not. There\u0026rsquo;s a solution: the Color class!\nFirst of all, you will need to import the class:\nJava Python C# Ruby JavaScript import org.openqa.selenium.support.Color;   from selenium.webdriver.support.color import Color   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    include Selenium::WebDriver::Support   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR      You can now start creating colour objects. Every colour object will need to be created from a string representation of your colour. Supported colour representations are:\nJava Python C# Ruby JavaScript private final Color HEX_COLOUR = Color.fromString(\u0026#34;#2F7ED8\u0026#34;); private final Color RGB_COLOUR = Color.fromString(\u0026#34;rgb(255, 255, 255)\u0026#34;); private final Color RGB_COLOUR = Color.fromString(\u0026#34;rgb(40%, 20%, 40%)\u0026#34;); private final Color RGBA_COLOUR = Color.fromString(\u0026#34;rgba(255, 255, 255, 0.5)\u0026#34;); private final Color RGBA_COLOUR = Color.fromString(\u0026#34;rgba(40%, 20%, 40%, 0.5)\u0026#34;); private final Color HSL_COLOUR = Color.fromString(\u0026#34;hsl(100, 0%, 50%)\u0026#34;); private final Color HSLA_COLOUR = Color.fromString(\u0026#34;hsla(100, 0%, 50%, 0.5)\u0026#34;);   HEX_COLOUR = Color.from_string(\u0026#39;#2F7ED8\u0026#39;) RGB_COLOUR = Color.from_string(\u0026#39;rgb(255, 255, 255)\u0026#39;) RGB_COLOUR = Color.from_string(\u0026#39;rgb(40%, 20%, 40%)\u0026#39;) RGBA_COLOUR = Color.from_string(\u0026#39;rgba(255, 255, 255, 0.5)\u0026#39;) RGBA_COLOUR = Color.from_string(\u0026#39;rgba(40%, 20%, 40%, 0.5)\u0026#39;) HSL_COLOUR = Color.from_string(\u0026#39;hsl(100, 0%, 50%)\u0026#39;) HSLA_COLOUR = Color.from_string(\u0026#39;hsla(100, 0%, 50%, 0.5)\u0026#39;)   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    HEX_COLOUR = Color.from_string(\u0026#39;#2F7ED8\u0026#39;) RGB_COLOUR = Color.from_string(\u0026#39;rgb(255, 255, 255)\u0026#39;) RGB_COLOUR = Color.from_string(\u0026#39;rgb(40%, 20%, 40%)\u0026#39;) RGBA_COLOUR = Color.from_string(\u0026#39;rgba(255, 255, 255, 0.5)\u0026#39;) RGBA_COLOUR = Color.from_string(\u0026#39;rgba(40%, 20%, 40%, 0.5)\u0026#39;) HSL_COLOUR = Color.from_string(\u0026#39;hsl(100, 0%, 50%)\u0026#39;) HSLA_COLOUR = Color.from_string(\u0026#39;hsla(100, 0%, 50%, 0.5)\u0026#39;)   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR      The Color class also supports all of the base colour definitions specified in http://www.w3.org/TR/css3-color/#html4.\nJava Python C# Ruby JavaScript private final Color BLACK = Color.fromString(\u0026#34;black\u0026#34;); private final Color CHOCOLATE = Color.fromString(\u0026#34;chocolate\u0026#34;); private final Color HOTPINK = Color.fromString(\u0026#34;hotpink\u0026#34;);   BLACK = Color.from_string(\u0026#39;black\u0026#39;) CHOCOLATE = Color.from_string(\u0026#39;chocolate\u0026#39;) HOTPINK = Color.from_string(\u0026#39;hotpink\u0026#39;)   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    BLACK = Color.from_string(\u0026#39;black\u0026#39;) CHOCOLATE = Color.from_string(\u0026#39;chocolate\u0026#39;) HOTPINK = Color.from_string(\u0026#39;hotpink\u0026#39;)   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR      Sometimes browsers will return a colour value of \u0026ldquo;transparent\u0026rdquo; if no colour has been set on an element. The Color class also supports this:\nJava Python C# Ruby JavaScript private final Color TRANSPARENT = Color.fromString(\u0026#34;transparent\u0026#34;);   TRANSPARENT = Color.from_string(\u0026#39;transparent\u0026#39;)   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    TRANSPARENT = Color.from_string(\u0026#39;transparent\u0026#39;)   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR      You can now safely query an element to get its colour/background colour knowing that any response will be correctly parsed and converted into a valid Color object:\nJava Python C# Ruby JavaScript Color loginButtonColour = driver.findElement(By.id(\u0026#34;login\u0026#34;)).getCssValue(\u0026#34;color\u0026#34;); Color loginButtonBackgroundColour = driver.findElement(By.id(\u0026#34;login\u0026#34;)).getCssValue(\u0026#34;background-color\u0026#34;);   login_button_colour = driver.find_element_by_id(\u0026#39;login\u0026#39;).value_of_css_property(\u0026#39;color\u0026#39;) login_button_background_colour = driver.find_element_by_id(\u0026#39;login\u0026#39;).value_of_css_property(\u0026#39;background-color\u0026#39;);   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    login_button_colour = driver.find_element(id: \u0026#39;login\u0026#39;).css_value(\u0026#39;color\u0026#39;) login_button_background_colour = driver.find_element(id: \u0026#39;login\u0026#39;).css_value(\u0026#39;background-color\u0026#39;);   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR      You can then directly compare colour objects:\nJava Python C# Ruby JavaScript assert loginButtonBackgroundColour.equals(HOTPINK);   assert login_button_background_colour == HOTPINK   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    assert(login_button_background_colour == HOTPINK)   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR      Or you can convert the colour into one of the following formats and perform a static validation:\nJava Python C# Ruby JavaScript assert loginButtonBackgroundColour.asHex().equals(\u0026#34;#ff69b4\u0026#34;); assert loginButtonBackgroundColour.asRgba().equals(\u0026#34;rgba(255, 105, 180, 1)\u0026#34;); assert loginButtonBackgroundColour.asRgb().equals(\u0026#34;rgb(255, 105, 180)\u0026#34;);   assert login_button_background_colour.hex == \u0026#39;#ff69b4\u0026#39; assert login_button_background_colour.rgba == \u0026#39;rgba(255, 105, 180, 1)\u0026#39; assert login_button_background_colour.rgb == \u0026#39;rgb(255, 105, 180)\u0026#39;   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    assert(login_button_background_colour.hex == \u0026#39;#ff69b4\u0026#39;) assert(login_button_background_colour.rgba == \u0026#39;rgba(255, 105, 180, 1)\u0026#39;) assert(login_button_background_colour.rgb == \u0026#39;rgb(255, 105, 180)\u0026#39;)   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR      Colours are no longer a problem.\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/remote_webdriver/remote_webdriver_client/",
	"title": "WebDriver remoto - cliente",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n First, we need to connect to the RemoteWebDriver. We do this by pointing the URL to the address of the server running our tests. In order to customize our configuration, we set desired capabilities. Below is an example of instantiating a remote WebDriver object pointing to our remote web server, www.example.com, running our tests on Firefox.\nJava Python C# Ruby JavaScript FirefoxOptions firefoxOptions = new FirefoxOptions(); WebDriver driver = new RemoteWebDriver(new URL(\u0026#34;http://www.example.com\u0026#34;), firefoxOptions); driver.get(\u0026#34;http://www.google.com\u0026#34;); driver.quit();   # We don\u0026#39;t have a Python code sample yet - Help us out and raise a PR    // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :remote, url: \u0026#34;http://www.example.com\u0026#34;, desired_capabilities: :firefox driver.get \u0026#34;http://www.google.com\u0026#34; driver.close   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR      To further customize our test configuration, we can add other desired capabilities.\nDesired capabilities Desired capabilities can be expanded further. All remote Webdriver capabilities are sent through JsonWireProtocol. For a list of configurable capabilities, and more information on JsonWireProtocol, please visit the documentation here.\nFor example, suppose you wanted to run Chrome on Windows XP, using Chrome version 67:\nJava Python C# Ruby JavaScript ChromeOptions chromeOptions = new ChromeOptions(); chromeOptions.setCapability(\u0026#34;browserVersion\u0026#34;, \u0026#34;67\u0026#34;); chromeOptions.setCapability(\u0026#34;platformName\u0026#34;, \u0026#34;Windows XP\u0026#34;); WebDriver driver = new RemoteWebDriver(new URL(\u0026#34;http://www.example.com\u0026#34;), chromeOptions); driver.get(\u0026#34;http://www.google.com\u0026#34;); driver.quit();   # We don\u0026#39;t have a Python code sample yet - Help us out and raise a PR    // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    caps = Selenium::WebDriver::Remote::Capabilities.chrome caps.platform = Windows XP caps.version = 67 driver = Selenium::WebDriver.for :remote, :url =\u0026gt; \u0026#34;http://www.example.com\u0026#34;, :desired_capabilities =\u0026gt; caps   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR      Local file detector The Local File Detector allows the transfer of files from the client machine to the remote server. For example, if a test needs to upload a file to a web application, a remote WebDriver can automatically transfer the file from the local machine to the remote web server during runtime. This allows the file to be uploaded from the remote machine running the test. It is not enabled by default and can be enabled in the following way:\nJava Python C# Ruby JavaScript driver.setFileDetector(new LocalFileDetector());   # We don\u0026#39;t have a Python code sample yet - Help us out and raise a PR    // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    @driver.file_detector = lambda do |args| # args =\u0026gt; [\u0026#34;/path/to/file\u0026#34;] str = args.first.to_s str if File.exist?(str) end   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR      Once the above code is defined, you can upload a file in your test in the following way:\nJava Python C# Ruby JavaScript driver.get(\u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34;); WebElement upload = driver.findElement(By.id(\u0026#34;myfile\u0026#34;)); upload.sendKeys(\u0026#34;/Users/sso/the/local/path/to/darkbulb.jpg\u0026#34;);   # We don\u0026#39;t have a Python code sample yet - Help us out and raise a PR    // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    @driver.navigate.to \u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34; element = @driver.find_element(:id, \u0026#39;myfile\u0026#39;) element.send_keys \u0026#34;/Users/sso/SauceLabs/sauce/hostess/maitred/maitred/public/images/darkbulb.jpg\u0026#34;   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR      "
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/grid/setting_up_your_own_grid/",
	"title": "Configurando tu propio Grid",
	"tags": [],
	"description": "",
	"content": " Para usar Selenium Grid, debe mantener su propia infraestructura para los nodos. Como esto puede ser un esfuerzo demandante e intenso, muchas organizaciones utilizan proveedores de IaaS como Amazon EC2 y Google Compute para proporcionar esta infraestructura.\nOtras opciones incluyen el uso de proveedores como Sauce Labs o Testing Bot que proporcionan un Selenium Grid como servicio en la nube. Ciertamente, también es posible ejecutar nodos en su infraestructura propia. Este capítulo entrará en detalles sobre la opción de ejecutar su propia grid, de manera completa con su propia infraestructura de nodos.\nInicio rápido Este ejemplo le mostrará cómo iniciar Selenium 2 Grid Hub y registrar un nodo WebDriver y un nodo heredado Selenium 1 RC. También le mostraremos cómo llamar a la grid desde Java. El concentrador (hub) y los nodos se muestran aquí ejecutándose en la misma máquina, pero, por supuesto, puede copiar el servidor independiente de Selenium (selenium-server-standalone) en varias máquinas.\nEl paquete selenium-server-standalone incluye el hub, WebDriver y el RC heredado necesario para ejecutar la Grid, ant ya no es necesario. Puede descargar el selenium-server-standalone-.jar desde http://www.seleniumhq.org/download/.\nPaso 1: Inicie el Hub El Hub es el punto central que recibirá las solicitudes de prueba y las distribuirá a los nodos correctos. La distribución se realiza en función de las capacidades, lo que significa que una prueba que requiere un conjunto de capacidades (capabilities) solo se distribuirá a los nodos que ofrecen ese conjunto o subconjunto de capacidades.\nDebido a que las capacidades deseadas de una prueba son exactamente lo que el nombre implica \u0026ldquo;deseadas\u0026rdquo;, el concentrador no puede garantizar que localizará un nodo que coincida completamente con el conjunto de capacidades deseadas solicitado.\nAbra una consola del sistema y navegue hasta el directorio donde copió el archivo selenium-server-standalone.jar. Inicie el concentrador pasando el indicador -role hub al servidor independiente:\njava -jar selenium-server-standalone.jar -role hub El Hub escuchará el puerto 4444 por defecto. Puede ver el estado del concentrador abriendo una ventana del navegador y navegando a http://localhost:4444/grid/console.\nPara cambiar el puerto predeterminado, puede agregar el indicador opcional -port con un número entero que representa el puerto para escuchar cuando ejecuta el comando. Además, todas las otras opciones que ve en el archivo de configuración JSON (que se ve a continuación) son posibles indicadores de línea de comandos.\nCiertamente puede hacerlo solo con el comando simple que se muestra arriba, pero si necesita una configuración más avanzada, también puede especificar un archivo de configuración de formato JSON para configurar el concentrador cuando lo inicie. Puede hacerlo así:\njava -jar selenium-server-standalone.jar -role hub -hubConfig hubConfig.json -debug A continuación verá un ejemplo de un archivo hubConfig.json. Entraremos en más detalles sobre cómo proporcionar archivos de configuración de nodos en el paso 2.\n{ \u0026#34;_comment\u0026#34; : \u0026#34;Configuration for Hub - hubConfig.json\u0026#34;, \u0026#34;host\u0026#34;: ip, \u0026#34;maxSession\u0026#34;: 5, \u0026#34;port\u0026#34;: 4444, \u0026#34;cleanupCycle\u0026#34;: 5000, \u0026#34;timeout\u0026#34;: 300000, \u0026#34;newSessionWaitTimeout\u0026#34;: -1, \u0026#34;servlets\u0026#34;: [], \u0026#34;prioritizer\u0026#34;: null, \u0026#34;capabilityMatcher\u0026#34;: \u0026#34;org.openqa.grid.internal.utils.DefaultCapabilityMatcher\u0026#34;, \u0026#34;throwOnCapabilityNotPresent\u0026#34;: true, \u0026#34;nodePolling\u0026#34;: 180000, \u0026#34;platform\u0026#34;: \u0026#34;WINDOWS\u0026#34;} Step 2: Start the Nodes Independientemente de si desea ejecutar una grid con la nueva funcionalidad WebDriver, o una grid con la funcionalidad Selenium 1 RC, o ambas al mismo tiempo, utilice el mismo archivo selenium-server-standalone.jar para iniciar los nodos:\njava -jar selenium-server-standalone.jar -role node -hub http://localhost:4444 Si no se especifica un puerto a través de la argumento -port, se elegirá un puerto libre. Puede ejecutar múltiples nodos en una máquina, pero si lo hace, debe conocer los recursos de memoria de su sistema y los problemas con las capturas de pantalla si sus pruebas los toman.\nConfiguración de Nodo con opciones Como se mencionó, para la compatibilidad con versiones anteriores, los roles \u0026ldquo;wd\u0026rdquo; y \u0026ldquo;rc\u0026rdquo; siguen siendo un subconjunto válido del rol \u0026ldquo;node\u0026rdquo;. Pero esos roles limitan los tipos de conexiones remotas a su API correspondiente, mientras que \u0026ldquo;node\u0026rdquo; permite conexiones remotas RC y WebDriver.\nAl pasar las propiedades de JVM (usando el indicador -D antes del argumento -jar) también en la línea de comando, estas serán recogidas y propagadas a los nodos:\n-Dwebdriver.chrome.driver=chromedriver.exe\nConfiguración de nodo con JSON También puede iniciar nodos de grid configurados con un archivo de configuración JSON\njava -Dwebdriver.chrome.driver=chromedriver.exe -jar selenium-server-standalone.jar -role node -nodeConfig node1Config.json Y este es un ejemplo del archivo nodeConfig.json:\n{ \u0026#34;capabilities\u0026#34;: [ { \u0026#34;browserName\u0026#34;: \u0026#34;firefox\u0026#34;, \u0026#34;acceptSslCerts\u0026#34;: true, \u0026#34;javascriptEnabled\u0026#34;: true, \u0026#34;takesScreenshot\u0026#34;: false, \u0026#34;firefox_profile\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;browser-version\u0026#34;: \u0026#34;27\u0026#34;, \u0026#34;platform\u0026#34;: \u0026#34;WINDOWS\u0026#34;, \u0026#34;maxInstances\u0026#34;: 5, \u0026#34;firefox_binary\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;cleanSession\u0026#34;: true }, { \u0026#34;browserName\u0026#34;: \u0026#34;chrome\u0026#34;, \u0026#34;maxInstances\u0026#34;: 5, \u0026#34;platform\u0026#34;: \u0026#34;WINDOWS\u0026#34;, \u0026#34;webdriver.chrome.driver\u0026#34;: \u0026#34;C:/Program Files (x86)/Google/Chrome/Application/chrome.exe\u0026#34; }, { \u0026#34;browserName\u0026#34;: \u0026#34;internet explorer\u0026#34;, \u0026#34;maxInstances\u0026#34;: 1, \u0026#34;platform\u0026#34;: \u0026#34;WINDOWS\u0026#34;, \u0026#34;webdriver.ie.driver\u0026#34;: \u0026#34;C:/Program Files (x86)/Internet Explorer/iexplore.exe\u0026#34; } ], \u0026#34;configuration\u0026#34;: { \u0026#34;_comment\u0026#34; : \u0026#34;Configuration for Node\u0026#34;, \u0026#34;cleanUpCycle\u0026#34;: 2000, \u0026#34;timeout\u0026#34;: 30000, \u0026#34;proxy\u0026#34;: \u0026#34;org.openqa.grid.selenium.proxy.WebDriverRemoteProxy\u0026#34;, \u0026#34;port\u0026#34;: 5555, \u0026#34;host\u0026#34;: ip, \u0026#34;register\u0026#34;: true, \u0026#34;hubPort\u0026#34;: 4444, \u0026#34;maxSession\u0026#34;: 5 } } Una nota sobre la argumento -host\nTanto para el concentrador como para el nodo, si no se especifica el indicador -host, se usará0.0.0.0 por defecto. Esto se unirá a todas las interfaces IPv4 públicas (sin loopback) de la máquina. Si tiene una configuración de red especial o algún componente que cree interfaces de red adicionales, se recomienda establecer el indicador -host con un valor que permita que se pueda acceder al concentrador / nodo desde una máquina diferente.\nEspecificando el puerto El puerto TCP / IP predeterminado utilizado por el concentrador es 4444. Si necesita cambiar el puerto, utilice las configuraciones mencionadas anteriormente.\nSolución de problemas Uso del archivo de registro Para la resolución de problemas avanzada, puede especificar el archivo de registro para almacenar los mensajes del sistema. Para eso, inicie Selenium GRID hub o nodo con el argumento -log. Por favor vea el siguiente ejemplo:\njava -jar selenium-server-standalone.jar -role hub -log log.txt Use su editor de texto favorito para abrir el archivo de registro (log.txt en el ejemplo anterior) para encontrar registros de \u0026ldquo;ERROR\u0026rdquo; si tiene problemas.\nUsando el argumento -debug También puede usar el argumento -debug para imprimir registros de depuración en la consola. Para eso, inicie Selenium Grid Hub o Node con el argumento -debug. Por favor vea el siguiente ejemplo\njava -jar selenium-server-standalone.jar -role hub -debug Advertencia Selenium Grid debe protegerse del acceso externo mediante los permisos de firewall adecuados. Si no protege su Grid, podría ocurrir uno o más de los siguientes casos: * Usted proporciona acceso abierto a su infraestructura Grid * Permitir que terceros accedan a aplicaciones y archivos web internos * Permites que terceros ejecuten binarios personalizados\nConsulte esta publicación de blog en Detectify que ofrece una buena visión general de cómo se puede utilizar incorrectamente una grid expuesta públicamente: Inglés: No deje la grid abierta.\nDocker Selenium Docker proporciona una forma conveniente de aprovisionar y escalar la infraestructura de Selenium Grid en una unidad conocida como contenedor. Los contenedores son unidades de software estandarizadas que contienen todo lo necesario para ejecutar la aplicación deseada, incluidas todas las dependencias de manera confiable y repetible en diferentes máquinas.\nEl proyecto Selenium mantiene un conjunto de imágenes de Docker que puede descargar y ejecutar para que una grid de trabajo funcione rápidamente. Los nodos están disponibles para Firefox y Chrome. Los detalles completos sobre cómo aprovisionar una grid se pueden encontrar en el repositorio Docker Selenium.\nRequisito previo El único requisito para ejecutar un Grid es tener Docker instalado y funcionando. Instalar Docker.\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/worst_practices/http_response_codes/",
	"title": "Códigos de respuesta HTTP",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n For some browser configurations in Selenium RC, Selenium acted as a proxy between the browser and the site being automated. This meant that all browser traffic passed through Selenium could be captured or manipulated. The captureNetworkTraffic() method purported to capture all of the network traffic between the browser and the site being automated, including HTTP response codes.\nSelenium WebDriver is a completely different approach to browser automation, preferring to act more like a user and this is represented in the way you write tests with WebDriver. In automated functional testing, checking the status code is not a particularly important detail of a test\u0026rsquo;s failure; the steps that preceded it are more important.\nThe browser will always represent the HTTP status code, imagine for example a 404 or a 500 error page. A simple way to “fail fast” when you encounter one of these error pages is to check the page title or content of a reliable point (e.g. the \u0026lt;h1\u0026gt; tag) after every page load. If you are using the page object model, you can include this check in your class constructor or similar point where the page load is expected. Occasionally, the HTTP code may even be represented in the browser\u0026rsquo;s error page and you could use WebDriver to read this and improve your debugging output.\nChecking the webpage itself is in line with WebDriver\u0026rsquo;s ideal practice of representing and asserting upon the user’s view of the website.\nIf you insist, an advanced solution to capturing HTTP status codes is to replicate the behaviour of Selenium RC by using a proxy. WebDriver API provides the ability to set a proxy for the browser, and there are a number of proxies that will programmatically allow you to manipulate the contents of requests sent to and received from the web server. Using a proxy lets you decide how you want to respond to redirection response codes. Additionally, not every browser makes the response codes available to WebDriver, so opting to use a proxy allows you to have a solution that works for every browser.\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/guidelines_and_recommendations/generating_application_state/",
	"title": "Generar el estado de la aplicación",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Selenium should not be used to prepare a test case. All repetitive actions, and preparation for a test case, should be done through other methods. For example, most web UIs have authentication (e.g. a login form). Eliminating logging in via web browser before every test will improve both the speed and stability of the test. A method should be created to gain access to the AUT (e.g. using an API to login and set a cookie). Also, creating methods to pre-load data for testing should not be done using Selenium. As mentioned previously, existing APIs should be leveraged to create data for the AUT.\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/selenium_installation/",
	"title": "Instalación de Selenium",
	"tags": [],
	"description": "",
	"content": " Instalación de Selenium La configuración de Selenium es bastante diferente de la configuración de otras herramientas comerciales. Para usar Selenium en su proyecto de automatización, necesita instalar las librerías para el lenguaje de programación de su elección. Además, necesitará los binarios del WebDriver para los navegadores en los que desea automatizar y ejecutar la prueba.\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/selenium_installation/installing_standalone_server/",
	"title": "Instalación del servidor Standalone",
	"tags": [],
	"description": "",
	"content": "Si planeas usar Grid debes descargar el fichero selenium-server-standalone JAR. El jar selenium-server-standalone nunca se carga, pero todos los componentes están disponibles a través de selenium-server. El standalone JAR contiene todo, incluso el servidor remoto de Selenium y los enlaces del lado del cliente. Ésto quiere decir que si usas el selenium-server-standalone jar en tu proyecto, no tienes que añadir selenium-java o un jar de navegador específico.\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-server\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.X\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;"
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/getting_started_with_webdriver/locating_elements/",
	"title": "Localizando elementos",
	"tags": [],
	"description": "",
	"content": " Localizando un elemento Una de las técnicas más fundamentales por aprender al usar WebDriver es cómo encontrar elementos en la página. WebDriver ofrece varios tipos de selectores integrados, entre ellos encontrar un elemento por su atributo ID:\nJava Python C# Ruby JavaScript WebElement cheese = driver.findElement(By.id(\u0026#34;cheese\u0026#34;));   driver.find_element_by_id(\u0026#34;cheese\u0026#34;)   IWebElement element = driver.FindElement(By.Id(\u0026#34;cheese\u0026#34;));   driver.find_element(id: \u0026#34;cheese\u0026#34;)   const cheese = await driver.findElement(By.id(\u0026#39;cheese\u0026#39;));     Como se ve en el ejemplo, la localización de elementos en WebDriver se realiza en el objeto de instancia WebDriver. El método findElement(By) devuelve otro tipo de objeto fundamental, el WebElement.\n WebDriver representa al navegador. WebElement representa a un nodo DOM particular (un control, por ejemplo, un enlace o campo de entrada, etc.).  Una vez que tenga la referencia a un elemento web que se ha \u0026ldquo;encontrado\u0026rdquo;, puede reducir el alcance de su búsqueda utilizando la misma llamada en esa instancia de objeto:\nJava Python C# Ruby JavaScript WebElement cheese = driver.findElement(By.id(\u0026#34;cheese\u0026#34;)); WebElement cheddar = cheese.findElement(By.id(\u0026#34;cheddar\u0026#34;));   cheese = driver.find_element_by_id(\u0026#34;cheese\u0026#34;) cheddar = cheese.find_elements_by_id(\u0026#34;cheddar\u0026#34;)   IWebElement cheese = driver.FindElement(By.Id(\u0026#34;cheese\u0026#34;)); IWebElement cheddar = cheese.FindElement(By.Id(\u0026#34;cheddar\u0026#34;));   cheese = driver.find_element(id: \u0026#34;cheese\u0026#34;) cheddar = cheese.find_elements(id: \u0026#34;cheddar\u0026#34;)   const cheese = await driver.findElement(By.id(\u0026#39;cheese\u0026#39;)); const cheddar = await cheese.findElement(By.id(\u0026#39;cheddar\u0026#39;));     Usted puede hacer esto porque los tipos WebDriver y WebElement implementan la interfaz SearchContext. En WebDriver, esto se conoce como interfaz basada en roles. Las interfaces basadas en roles le permiten determinar si una implementación de controlador particular admite una característica determinada. Estas interfaces están claramente definidas y tratan de cumplir con tener un solo rol de responsabilidad. Puede leer más sobre el diseño de WebDriver y qué roles se admiten en qué controladores en Alguna otra sección que debe nombrarse. En consecuencia, la interfaz By utilizada anteriormente también admite una serie de estrategias de localización adicionales. Una búsqueda anidada podría no ser la estrategia de ubicación más efectiva, ya que requiere que se envíen dos comandos separados al navegador; primero buscando en el DOM un elemento con ID \u0026ldquo;cheese\u0026rdquo;, luego una búsqueda de \u0026ldquo;cheddar\u0026rdquo; en un contexto restringido.\nPara mejorar ligeramente el rendimiento, deberíamos tratar de usar un localizador más específico: WebDriver admite la búsqueda de elementos mediante localizadores CSS, lo que nos permite combinar los dos localizadores anteriores en una sola búsqueda:\nJava Python C# Ruby JavaScript driver.findElement(By.cssSelector(\u0026#34;#cheese #cheddar\u0026#34;));   cheddar = driver.find_element_by_css_selector(\u0026#34;#cheese #cheddar\u0026#34;)   driver.FindElement(By.CssSelector(\u0026#34;#cheese #cheddar\u0026#34;));   mucho_cheese = driver.find_elements(css: \u0026#34;#cheese #cheddar\u0026#34;)   const cheddar = await driver.findElement(By.css(\u0026#39;#cheese #cheddar\u0026#39;));     Localizando múltiples elementos Es posible que el documento con el que estamos trabajando tenga una lista ordenada de quesos que más nos gustan:\n\u0026lt;ol id=cheese\u0026gt; \u0026lt;li id=cheddar\u0026gt;… \u0026lt;li id=brie\u0026gt;… \u0026lt;li id=rochefort\u0026gt;… \u0026lt;li id=camembert\u0026gt;… \u0026lt;/ul\u0026gt; Dado que más queso es indiscutiblemente mejor, y sería engorroso tener que recuperar cada uno de los elementos individualmente, una técnica superior para recuperar queso es utilizar la versión pluralizada findElements(By). Este método devuelve una colección de elementos web. Si solo se encuentra un elemento, aún devolverá una colección (de un elemento). Si ningún elemento coincide con el localizador, se devolverá una lista vacía.\nJava Python C# Ruby JavaScript List\u0026lt;WebElement\u0026gt; muchoCheese = driver.findElements(By.cssSelector(\u0026#34;#cheese li\u0026#34;));   mucho_cheese = driver.find_elements_by_css_selector(\u0026#34;#cheese li\u0026#34;)   IReadOnlyList\u0026lt;IWebElement\u0026gt; muchoCheese = driver.FindElements(By.CssSelector(“#cheese li”));   mucho_cheese = driver.find_elements(css: \u0026#34;#cheese li\u0026#34;)   const muchoCheese = await driver.findElements(By.css(\u0026#39;#cheese li\u0026#39;));     Estrategias de localización de elementos Hay ocho estrategias diferentes de ubicación de elementos integrados en WebDriver:\n   Localizador Descripción     class name Localiza elementos cuyo nombre de clase contiene el valor de búsqueda (no se permiten nombres de clase compuestos)   css selector Localiza elementos que coinciden con un selector CSS   id Localiza elementos cuyo atributo ID coincide con el valor de búsqueda   name Localiza elementos cuyo atributo NAME coincide con el valor de búsqueda   link text Localiza elementos de hipervínculo cuyo texto visible coincide con el valor de búsqueda   partial link text Localiza elementos de vínculo o enlace cuyo texto visible coincide con el valor de búsqueda   tag name Localiza elementos cuyo nombre de etiqueta coincide con el valor de búsqueda   xpath Localiza elementos que coinciden con una expresión XPath    Consejos para usar selectores En general, si las ID de HTML están disponibles, son únicas y predecibles de manera consistente, son el método preferido para ubicar un elemento en una página. Tienden a funcionar muy rápidamente y renuncian a mucho procesamiento que viene con recorridos DOM complicados.\nSi las ID únicas no están disponibles, un selector CSS bien escrito es el método preferido para localizar un elemento. XPath funciona tan bien como los selectores CSS, pero la sintaxis es complicada y con frecuencia difícil de depurar. Aunque los selectores XPath son muy flexibles, generalmente no son probados por los proveedores de navegadores y tienden a ser bastante lentos.\nLas estrategias de selección basadas en texto de enlace y texto parcial de enlace tienen inconvenientes en el sentido de que solo funcionan en elementos de enlace. Además, llaman a los selectores XPath internamente en WebDriver.\nLa etiqueta nombre (name) puede ser una forma peligrosa de localizar elementos. Con frecuencia hay varios elementos de la misma etiqueta presentes en la página. Esto es principalmente útil cuando se llama al método findElements(By) que devuelve una colección de elementos.\nLa recomendación es mantener sus localizadores lo más compactos y legibles posible. Pedirle al WebDriver que atraviese la estructura DOM es una operación costosa, y cuanto más pueda reducir el alcance de su búsqueda, mejor.\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/webdriver/browser_manipulation/",
	"title": "Manipulación de Navegadores",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Ruby Ruby is not installed by default on Windows. Download the latest version and run the installer. You can leave all settings at default values, except at the Installation Destination and Optional Tasks screen check Add Ruby executables to your PATH checkbox. To drive any browser, you have to install selenium-webdriver Ruby gem. To install it, open command prompt and type this:\ngem install selenium-webdriver Or, if you use Bundler, add this line to your application\u0026rsquo;s Gemfile:\ngem \u0026#34;selenium-webdriver\u0026#34; And then execute the following command in prompt:\nbundle install Internet Explorer Internet Explorer is installed by default on Windows, so no installation is needed. To drive Internet Explorer on Windows, you have to download the latest Internet Explorer Driver and put the file into a folder that is in PATH. To find out which directories are in PATH, type echo %PATH% in command prompt.\n$ echo %PATH% C:\\Ruby200\\bin;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem C:\\Ruby200\\bin looks like a good place. Unzip IEDriverServer file and move IEDriverServer.exe there.\nThis should open a new Internet Explorer window:\nrequire \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :internet_explorer Browser navigation Navigate to The first thing you will want to do after launching a browser is to open your website. This can be achieved in a single line:\nJava Python C# Ruby JavaScript //Convenient driver.get(\u0026#34;https://www.seleniumhq.org\u0026#34;); //Longer way driver.navigate().to(\u0026#34;https://seleniumhq.github.io/docs/\u0026#34;);   driver.get(\u0026#34;https://www.seleniumhq.org\u0026#34;)   driver.Navigate().GoToUrl(@\u0026#34;http://google.com\u0026#34;);   # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR   await driver.get(\u0026#39;https://seleniumhq.github.io/docs/\u0026#39;);     Get current URL You can read the current URL from the browser\u0026rsquo;s address bar using:\nJava Python C# Ruby JavaScript driver.getCurrentUrl();  driver.current_url  driver.Url;   driver.current_url  await driver.getCurrentUrl();     Back Pressing the browser\u0026rsquo;s back button:\nJava Python C# Ruby JavaScript driver.navigate().back();  driver.back()  driver.Navigate().Back();   driver.navigate.back  await driver.navigate().back();     Forward Pressing the browser\u0026rsquo;s forward button:\nJava Python C# Ruby JavaScript driver.navigate().forward();  driver.forward()  driver.Navigate().Forward();   driver.navigate.forward  await driver.navigate().forward();     Refresh Refresh the current page:\nJava Python C# Ruby JavaScript driver.navigate().refresh();  driver.refresh()  driver.Navigate().Refresh();   driver.navigate.refresh  await driver.navigate().refresh();     Get title You can read the current page title from the browser:\nJava Python C# Ruby JavaScript driver.getTitle();  driver.title  driver.Title;   driver.title  await driver.getTitle();     Windows and tabs WebDriver doesn\u0026rsquo;t make the distinction between windows and tabs. If your site opens a new tab or window, Selenium will let you work with it using a window handle. Each window has a unique identifier which remains persistent in a single session. You can get the window handle of the current window by using:\nJava Python C# Ruby JavaScript driver.getWindowHandle();  driver.current_window_handle  driver.CurrentWindowHandle;   driver.window_handle  await driver.getWindowHandle();     Switching windows or tabs Clicking a link which opens in a new window will focus the new window or tab on screen, but WebDriver will not know which window the Operating System considers active. To work with the new window you will need to switch to it. If you have only two tabs or windows open, and you know which window you start with, by the process of elimination you can loop over both windows or tabs that WebDriver can see, and switch to the one which is not the original.\nJava Python C# Ruby JavaScript //Store the ID of the original window String originalWindow = driver.getWindowHandle(); //Check we don\u0026#39;t have other windows open already assert driver.getWindowHandles().size() == 1; //Click the link which opens in a new window driver.findElement(By.linkText(\u0026#34;new window\u0026#34;)).click(); //Wait for the new window or tab wait.until(numberOfWindowsToBe(2)); //Loop through until we find a new window handle for (String windowHandle : driver.getWindowHandles()) { if(!originalWindow.contentEquals(windowHandle)) { driver.switchTo().window(windowHandle); break; } } //Wait for the new tab to finish loading content wait.until(titleIs(\u0026#34;Selenium documentation\u0026#34;));   from selenium import webdriver from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC # Start the driver with webdriver.Firefox() as driver: # Open URL driver.get(\u0026#34;https://seleniumhq.github.io/docs/wd.html\u0026#34;) # Setup wait for later wait = WebDriverWait(driver, 10) # Store the ID of the original window original_window = driver.current_window_handle # Check we don\u0026#39;t have other windows open already assert len(driver.window_handles) == 1 # Click the link which opens in a new window driver.find_element_by_link_text(\u0026#34;new window\u0026#34;).click() # Wait for the new window or tab wait.until(EC.number_of_windows_to_be(2)) # Loop through until we find a new window handle for window_handle in driver.window_handles: if window_handle != original_window: driver.switch_to.window(window_handle) break # Wait for the new tab to finish loading content wait.until(EC.title_is(\u0026#34;Selenium documentation\u0026#34;))   //Store the ID of the original window string originalWindow = driver.CurrentWindowHandle; //Check we don\u0026#39;t have other windows open already Assert.AreEqual(driver.WindowHandles.Count, 1); //Click the link which opens in a new window driver.FindElement(By.LinkText(\u0026#34;new window\u0026#34;)).Click(); //Wait for the new window or tab wait.Until(wd =\u0026gt; wd.WindowHandles.Count == 2); //Loop through until we find a new window handle foreach(string window in driver.WindowHandles) { if(originalWindow != window) { driver.SwitchTo().Window(window); break; } } //Wait for the new tab to finish loading content wait.Until(wd =\u0026gt; wd.Title == \u0026#34;Selenium documentation\u0026#34;);   #Store the ID of the original window original_window = driver.window_handle #Check we don\u0026#39;t have other windows open already assert(driver.window_handles.length == 1, \u0026#39;Expected one window\u0026#39;) #Click the link which opens in a new window driver.find_element(link: \u0026#39;new window\u0026#39;).click #Wait for the new window or tab wait.until { driver.window_handles.length == 2 } #Loop through until we find a new window handle driver.window_handles.each do |handle| if handle != original_window driver.switch_to.window handle break end end #Wait for the new tab to finish loading content wait.until { driver.title == \u0026#39;Selenium documentation\u0026#39;}   //Store the ID of the original window const originalWindow = await driver.getWindowHandle(); //Check we don\u0026#39;t have other windows open already assert((await driver.getAllWindowHandles()).length === 1); //Click the link which opens in a new window await driver.findElement(By.linkText(\u0026#39;new window\u0026#39;)).click(); //Wait for the new window or tab await driver.wait( async () =\u0026gt; (await driver.getAllWindowHandles()).length === 2, 10000 ); //Loop through until we find a new window handle const windows = await driver.getAllWindowHandles(); windows.forEach(async handle =\u0026gt; { if (handle !== originalWindow) { await driver.switchTo().window(handle); } }); //Wait for the new tab to finish loading content await driver.wait(until.titleIs(\u0026#39;Selenium documentation\u0026#39;), 10000);     Closing a window or tab When you are finished with a window or tab and it is not the last window or tab open in your browser, you should close it and switch back to the window you were using previously. Assuming you followed the code sample in the previous section you will have the previous window handle stored in a variable. Put this together and you will get:\nJava Python C# Ruby JavaScript //Close the tab or window driver.close(); //Switch back to the old tab or window driver.switchTo().window(originalWindow);   #Close the tab or window driver.close() #Switch back to the old tab or window driver.switch_to.window(original_window)   //Close the tab or window driver.Close(); //Switch back to the old tab or window driver.SwitchTo().Window(originalWindow);   #Close the tab or window driver.close #Switch back to the old tab or window driver.switch_to.window original_window   //Close the tab or window await driver.close(); //Switch back to the old tab or window await driver.switchTo().window(originalWindow);     Forgetting to switch back to another window handle after closing a window will leave WebDriver executing on the now closed page, and will trigger a No Such Window Exception. You must switch back to a valid window handle in order to continue execution.\nQuitting the browser at the end of a session When you are finished with the browser session you should call quit, instead of close:\nJava Python C# Ruby JavaScript driver.quit();  driver.quit()  driver.Quit();   driver.quit  await driver.quit();      Quit will:  Close all the windows and tabs associated with that WebDriver session The browser process The background driver process Notify Selenium Grid that the browser is no longer in use so it can be used by another session (if you are using Selenium Grid)   Failure to call quit will leave extra background processes and ports running on your machine which could cause you problems later.\nSome test frameworks offer methods and annotations which you can hook into to tear down at the end of a test.\nJava Python C# Ruby JavaScript /** * Example using JUnit * https://junit.org/junit5/docs/current/api/org/junit/jupiter/api/AfterAll.html */ @AfterAll public static void tearDown() { driver.quit(); }   # We don\u0026#39;t have a Python code sample yet - Help us out and raise a PR    /* Example using Visual Studio\u0026#39;s UnitTesting https://msdn.microsoft.com/en-us/library/microsoft.visualstudio.testtools.unittesting.aspx */ [TestCleanup] public void TearDown() { driver.Quit(); }   # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    /** * Example using Mocha * https://mochajs.org/#hooks */ after(\u0026#39;Tear down\u0026#39;, async function () { await driver.quit(); });     If not running WebDriver in a test context, you may consider using try / finally which is offered by most languages so that an exception will still clean up the WebDriver session.\nJava Python C# Ruby JavaScript try { //WebDriver code here... } finally { driver.quit(); }   try: #WebDriver code here... finally: driver.quit()   try { #WebDriver code here... } finally { driver.Quit(); }   begin #WebDriver code here... ensure driver.quit end   try { //WebDriver code here... } finally { await driver.quit(); }     Python\u0026rsquo;s WebDriver now supports the python context manager, which when using the with keyword can automatically quit the driver at the end of execution.\nwith webdriver.Firefox() as driver: # WebDriver code here... # WebDriver will automatically quit after indentation Frames and Iframes Frames are a now deprecated means of building a site layout from multiple documents on the same domain. You are unlikely to work with them unless you are working with an pre HTML5 webapp. Iframes allow the insertion of a document from an entirely different domain, and are still commonly used.\nIf you need to work with frames or iframes, Webdriver allows you to work with them in the same way. Consider a button within an iframe. If we inspect the element using the browser development tools, we might see the following:\n\u0026lt;div id=\u0026#34;modal\u0026#34;\u0026gt; \u0026lt;iframe id=\u0026#34;buttonframe\u0026#34; name=\u0026#34;myframe\u0026#34; src=\u0026#34;https://seleniumhq.github.io/docs/iframe.html\u0026#34;\u0026gt; \u0026lt;button\u0026gt;Click here\u0026lt;/button\u0026gt; \u0026lt;/iframe\u0026gt; \u0026lt;/div\u0026gt; If it wasn\u0026rsquo;t for the iframe we would expect to click on the button using something like:\nJava Python C# Ruby JavaScript //This won\u0026#39;t work driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click();   # We don\u0026#39;t have a Python code sample yet - Help us out and raise a PR    //This won\u0026#39;t work driver.FindElement(By.TagName(\u0026#34;button\u0026#34;)).Click();   # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    // This won\u0026#39;t work await driver.findElement(By.css(\u0026#39;button\u0026#39;)).click();     However, if there are no buttons outside of the iframe, you might instead get a no such element error. This happens because Selenium is only aware of the elements in the top level document. To interact with the button, we will need to first switch to the frame, in a similar way to how we switch windows. WebDriver offers three ways of switching to a frame.\nUsing a WebElement Switching using a WebElement is the most flexible option. You can find the frame using your preferred selector and switch to it.\nJava Python C# Ruby JavaScript //Store the web element WebElement iframe = driver.findElement(By.cssSelector(\u0026#34;#modal\u0026gt;iframe\u0026#34;)); //Switch to the frame driver.switchTo().frame(iframe); //Now we can click the button driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click();   # We don\u0026#39;t have a Python code sample yet - Help us out and raise a PR    //Store the web element IWebElement iframe = driver.FindElement(By.CssSelector(\u0026#34;#modal\u0026gt;iframe\u0026#34;)); //Switch to the frame driver.SwitchTo().Frame(iframe); //Now we can click the button driver.FindElement(By.TagName(\u0026#34;button\u0026#34;)).Click();   # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    // Store the web element const iframe = await driver.findElement(By.css(\u0026#39;#modal \u0026gt; iframe\u0026#39;)); // Switch to the frame await driver.switchTo().frame(iframe); // Now we can click the button await driver.findElement(By.css(\u0026#39;button\u0026#39;)).click();     Using a name or ID If your frame or iframe has an id or name attribute, this can be used instead. If the name or ID is not unique on the page, then the first one found will be switched to.\nJava Python C# Ruby JavaScript //Using the ID driver.switchTo().frame(\u0026#34;buttonframe\u0026#34;); //Or using the name instead driver.switchTo().frame(\u0026#34;myframe\u0026#34;); //Now we can click the button driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click();   # We don\u0026#39;t have a Python code sample yet - Help us out and raise a PR    //Using the ID driver.SwitchTo().Frame(\u0026#34;buttonframe\u0026#34;); //Or using the name instead driver.SwitchTo().Frame(\u0026#34;myframe\u0026#34;); //Now we can click the button driver.FindElement(By.TagName(\u0026#34;button\u0026#34;)).Click();   # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    // Using the ID await driver.switchTo().frame(\u0026#39;buttonframe\u0026#39;); // Or using the name instead await driver.switchTo().frame(\u0026#39;myframe\u0026#39;); // Now we can click the button await driver.findElement(By.css(\u0026#39;button\u0026#39;)).click();     Using an index It is also possible to use the index of the frame, such as can be queried using window.frames in JavaScript.\nJava Python C# Ruby JavaScript // Switches to the second frame driver.switchTo().frame(1);   # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    // Switches to the second frame driver.SwitchTo().Frame(1);   # We don\u0026#39;t have a Python code sample yet - Help us out and raise a PR    // Switches to the second frame await driver.switchTo().frame(1);     Leaving a frame To leave an iframe or frameset, switch back to the default content like so:\nJava Python C# Ruby JavaScript // Return to the top level driver.switchTo().defaultContent();   # We don\u0026#39;t have a Python code sample yet - Help us out and raise a PR    // Return to the top level driver.SwitchTo().DefaultContent();   # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    // Return to the top level await driver.switchTo().defaultContent();     Window management Screen resolution can impact how your web application renders, so WebDriver provides mechanisms for moving and resizing the browser window.\nGet window size Fetches the size of the browser window in pixels.\nJava Python C# Ruby JavaScript //Access each dimension individually int width = driver.manage().window().getSize().getWidth(); int height = driver.manage().window().getSize().getHeight(); //Or store the dimensions and query them later Dimension size = driver.manage().window().getSize(); int width1 = size.getWidth(); int height1 = size.getHeight();   //Access each dimension individually width = driver.get_window_size().get(\u0026#34;width\u0026#34;) height = driver.get_window_size().get(\u0026#34;height\u0026#34;) //Or store the dimensions and query them later size = driver.get_window_size() width1 = size.get(\u0026#34;width\u0026#34;) height1 = size.get(\u0026#34;height\u0026#34;)   //Access each dimension individually int width = driver.Manage().Window.Size.Width; int height = driver.Manage().Window.Size.Height; //Or store the dimensions and query them later System.Drawing.Size size = driver.Manage().Window.Size; int width1 = size.Width; int height1 = size.Height;   # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    // Access each dimension individually const { width, height } = await driver.manage().window().getRect(); // Or store the dimensions and query them later const rect = await driver.manage().window().getRect(); const width1 = rect.width; const height1 = rect.height;     Set window size Restores the window and sets the window size. Java Python C# Ruby JavaScript driver.manage().window().setSize(new Dimension(1024, 768));  driver.set_window_size(1024, 768)  driver.Manage().Window.Size = new Size(1024, 768);   driver.set_window_size(1024,768)  await driver.manage().window().setRect({ width: 1024, height: 768 });    \nGet window position Fetches the coordinates of the top left coordinate of the browser window.\nJava Python C# Ruby JavaScript // Access each dimension individually int x = driver.manage().window().getPosition().getX(); int y = driver.manage().window().getPosition().getY(); // Or store the dimensions and query them later Point position = driver.manage().window().getPosition(); int x1 = position.getX(); int y1 = position.getY();   // Access each dimension individually x = driver.get_window_position().get(\u0026#39;x\u0026#39;) y = driver.get_window_position().get(\u0026#39;y\u0026#39;) // Or store the dimensions and query them later position = driver.get_window_position() x1 = position.get(\u0026#39;x\u0026#39;) y1 = position.get(\u0026#39;y\u0026#39;)   //Access each dimension individually int x = driver.Manage().Window.Position.X; int y = driver.Manage().Window.Position.Y; //Or store the dimensions and query them later Point position = driver.Manage().Window.Position; int x1 = position.X; int y1 = position.Y;   # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    // Access each dimension individually const { x, y } = await driver.manage().window().getRect(); // Or store the dimensions and query them later const rect = await driver.manage().window().getRect(); const x1 = rect.x; const y1 = rect.y;     Set window position Moves the window to the chosen position.\nJava Python C# Ruby JavaScript // Move the window to the top left of the primary monitor driver.manage().window().setPosition(new Point(0, 0));   // Move the window to the top left of the primary monitor driver.set_window_position(0, 0)   // Move the window to the top left of the primary monitor driver.Manage().Window.Position = new Point(0, 0);   # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    // Move the window to the top left of the primary monitor await driver.manage().window().setRect({ x: 0, y: 0 });     Maximise window Enlarges the window. For most operating systems, the window will fill the screen, without blocking the operating system\u0026rsquo;s own menus and toolbars.\nJava Python C# Ruby JavaScript driver.manage().window().maximize();  driver.maximize_window()  driver.Manage().Window.Maximize();   # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    await driver.manage().window().maximize();     Fullscreen window Fills the entire screen, similar to pressing F11 in most browsers.\nJava Python C# Ruby JavaScript driver.manage().window().fullscreen();  driver.fullscreen_window()  driver.Manage().Window.FullScreen();   # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    await driver.manage().window().fullscreen();     "
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/introduction/types_of_testing/",
	"title": "Tipos de pruebas",
	"tags": [],
	"description": "",
	"content": " Prueba de aceptación Este tipo de prueba se realiza para determinar si la característica de un producto cumple con sus requisitos. Esto generalmente implica la retroalimentación o especificación del cliente.\nPara aplicaciones web, la automatización de este tipo de prueba se puede hacer directamente con Selenium simulando el comportamiento esperado del usuario. Esta simulación se puede realizar mediante grabación / reproducción o mediante los diferentes lenguajes de programación admitidos, tal como se explica en esta documentación. Nota: Las pruebas de aceptación son un subtipo de pruebas funcionales, a las que algunas personas también pueden referirse.\nPrueba funcional Este tipo de prueba se realiza para determinar si la característica de un producto funciona correctamente, sin problemas. Esto generalmente incluye: que las pruebas funcionen sin errores (páginas 404, excepciones \u0026hellip;), de manera utilizable (redirecciones correctas), de manera accesible y con sus especificaciones (ver pruebas de aceptación más arriba).\nPara aplicaciones web, la automatización de estas pruebas se puede hacer directamente con Selenium simulando los retornos esperados. Esta simulación podría realizarse mediante grabación / reproducción o mediante los diferentes lenguajes admitidos, tal como se explica en esta documentación.\nPruebas de rendimiento o desempeño Como su nombre lo indica, se realizan pruebas de rendimiento para medir el rendimiento de una aplicación.\nHay dos subtipos principales para las pruebas de rendimiento:\nPrueba de carga La prueba de carga se realiza para verificar qué tan bien funciona la aplicación bajo diferentes cargas definidas (generalmente un número particular de usuarios conectados a la vez).\nPruebas de estrés o esfuerzo La prueba de esfuerzo se realiza para verificar qué tan bien funciona la aplicación bajo estrés (o por encima de la carga máxima soportada).\nEn general, las pruebas de rendimiento se realizan mediante la ejecución de una serie de pruebas escritas de Selenium que simulan a diferentes usuarios que acceden a una función particular en la aplicación web y recuperan algunas mediciones significativas.\nEn general, esto lo hacen otras herramientas que recuperan las métricas. Una de esas herramientas es JMeter.\nPara una aplicación web, los detalles a medir incluyen: rendimiento (throughput), latencia, pérdida de datos, tiempos de carga de componentes individuales \u0026hellip;\nNota: Todos los navegadores tienen una pestaña de rendimiento en la sección de herramientas de desarrolladores (accesible presionando F12).\nNota 2: es un subtipo de pruebas no funcionales ya que generalmente se mide por sistema y no por función / característica.\nPruebas de regresión Esta prueba generalmente se realiza después de un cambio, corrección o adición de características.\nPara garantizar que el cambio no haya roto ninguna de las funciones existentes, algunas pruebas ya ejecutadas se ejecutan nuevamente. El conjunto de pruebas ejecutadas de nuevo puede ser completo o parcial y puede incluir varios tipos diferentes, según la aplicación y el equipo de desarrollo.\nDesarrollo guiado por pruebas (TDD) En lugar de un tipo de prueba per se, TDD es una metodología de desarrollo iterativa en la que las pruebas guían el diseño de una característica. Cada ciclo comienza creando un conjunto de pruebas unitarias que la característica debe pasar (que debe fallar la primera vez que se ejecuta).Después de esto, se lleva a cabo el desarrollo para que las pruebas pasen. Las pruebas se ejecutan nuevamente comenzando otro ciclo y este proceso continúa hasta que todas las pruebas hayan pasado.\nEl objetivo es acelerar el desarrollo de una aplicación basada en el hecho de que los defectos son menos costosos cuanto antes se encuentran.\nDesarrollo impulsado por el comportamiento (BDD) BDD es también una metodología de desarrollo iterativa basada en el anterior (TDD) en la que el objetivo es involucrar a todas las partes en el desarrollo de una aplicación.\nCada ciclo comienza creando alguna especificación (que debería fallar). Luego se crean las pruebas unitarias fallidas (que también deberían fallar) y luego se crea el desarrollo. Este ciclo se repite hasta que pase todo tipo de pruebas.\nPara hacerlo, se utiliza un lenguaje de especificación. Debe ser entendible por todas las partes y simple, estándar y explícito. La mayoría de las herramientas usan Gherkin como este lenguaje.\nEl objetivo es ser capaz de detectar incluso más errores que TDD al enfocarse también en posibles errores de aceptación y hacer que la comunicación entre las partes sea más fluida.\nActualmente hay un conjunto de herramientas disponibles para escribir las especificaciones y combinarlas con funciones de código, como Cucumber o SpecFlow.\nSe ha creado un conjunto de herramientas sobre Selenium para que este proceso sea aún más rápido al transformar directamente las especificaciones de BDD en código ejecutable. Algunos de estos son: JBehave, Capybara y Robot Framework.\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/support_packages/working_with_select_elements/",
	"title": "Trabajando con elementos select",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Select elements can require quite a bit of boiler plate code to automate. To reduce this and make your tests cleaner, there is a Select class in the Selenium support package. To use it, you will need the following import statement:\nJava Python C# Ruby JavaScript import org.openqa.selenium.support.ui.Select;   from selenium.webdriver.support.select import Select   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    include Selenium::WebDriver::Support   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR      You are then able to create a Select object using a WebElement that references a \u0026lt;select\u0026gt; element.\nJava Python C# Ruby JavaScript WebElement selectElement = driver.findElement(By.id(\u0026#34;selectElementID\u0026#34;)); Select selectObject = new Select(selectElement);   select_element = driver.find_element_by_id(\u0026#39;selectElementID\u0026#39;) select_object = Select(select_element)   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    select_element = driver.find_element(id: \u0026#39;selectElementID\u0026#39;) select_object = Select(select_element)   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR      The Select object will now give you a series of commands that allow you to interact with a \u0026lt;select\u0026gt; element. First of all, there are different ways of selecting an option from the \u0026lt;select\u0026gt; element.\n\u0026lt;select\u0026gt; \u0026lt;option value=value1\u0026gt;Bread\u0026lt;/option\u0026gt; \u0026lt;option value=value2 selected\u0026gt;Milk\u0026lt;/option\u0026gt; \u0026lt;option value=value3\u0026gt;Cheese\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; There are three ways to select the first option from the above element:\nJava Python C# Ruby JavaScript // Select an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index selectObject.selectByIndex(1); // Select an \u0026lt;option\u0026gt; based upon its value attribute selectObject.selectByValue(\u0026#34;value1\u0026#34;); // Select an \u0026lt;option\u0026gt; based upon its text selectObject.selectByVisibleText(\u0026#34;Bread\u0026#34;);   # Select an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index select_object.select_by_index(1) # Select an \u0026lt;option\u0026gt; based upon its value attribute select_object.select_by_value(\u0026#39;value1\u0026#39;) # Select an \u0026lt;option\u0026gt; based upon its text select_object.select_by_visible_text(\u0026#39;Bread\u0026#39;)   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    # Select an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index select_object.select_by(:index, 1) # Select an \u0026lt;option\u0026gt; based upon its value attribute select_object.select_by(:value, \u0026#39;value1\u0026#39;) # Select an \u0026lt;option\u0026gt; based upon its text select_object.select_by(:text, \u0026#39;Bread\u0026#39;)   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR      You can then check which options are selected by using:\nJava Python C# Ruby JavaScript // Return a List\u0026lt;WebElement\u0026gt; of options that have been selected List\u0026lt;WebElement\u0026gt; allSelectedOptions = selectObject.getAllSelectedOptions(); // Return a WebElement referencing the first selection option found by walking down the DOM WebElement firstSelectedOption = selectObject.getFirstSelectedOption();   # Return a list[WebElement] of options that have been selected all_selected_options = select_object.all_selected_options # Return a WebElement referencing the first selection option found by walking down the DOM first_selected_option = select_object.first_selected_option   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    # Return an Array[Element] of options that have been selected all_selected_options = select_object.selected_options # Return a WebElement referencing the first selection option found by walking down the DOM first_selected_option = select_object.first_selected_option   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR      Or you may just be interested in what \u0026lt;option\u0026gt; elements the \u0026lt;select\u0026gt; element contains:\nJava Python C# Ruby JavaScript // Return a List\u0026lt;WebElement\u0026gt; of options that the \u0026lt;select\u0026gt; element contains List\u0026lt;WebElement\u0026gt; allAvailableOptions = selectObject.getOptions();   # Return a list[WebElement] of options that the \u0026amp;lt;select\u0026amp;gt; element contains all_available_options = select_object.options   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    # Return an Array[Element] of options that the \u0026amp;lt;select\u0026amp;gt; element contains all_available_options = select_object.options   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR      If you want to deselect any elements, you now have four options:\nJava Python C# Ruby JavaScript // Deselect an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index selectObject.deselectByIndex(1); // Deselect an \u0026lt;option\u0026gt; based upon its value attribute selectObject.deselectByValue(\u0026#34;value1\u0026#34;); // Deselect an \u0026lt;option\u0026gt; based upon its text selectObject.deselectByVisibleText(\u0026#34;Bread\u0026#34;); // Deselect all selected \u0026lt;option\u0026gt; elements selectObject.deselectAll();   # Deselect an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index select_object.deselect_by_index(1) # Deselect an \u0026lt;option\u0026gt; based upon its value attribute select_object.deselect_by_value(\u0026#39;value1\u0026#39;) # Deselect an \u0026lt;option\u0026gt; based upon its text select_object.deselect_by_visible_text(\u0026#39;Bread\u0026#39;) # Deselect all selected \u0026lt;option\u0026gt; elements select_object.deselect_all()   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    # Deselect an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index select_object.deselect_by(:index, 1) # Deselect an \u0026lt;option\u0026gt; based upon its value attribute select_object.deselect_by(:value, \u0026#39;value1\u0026#39;) # Deselect an \u0026lt;option\u0026gt; based upon its text select_object.deselect_by(:text, \u0026#39;Bread\u0026#39;) # Deselect all selected \u0026lt;option\u0026gt; elements select_object.deselect_all   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR      Finally, some \u0026lt;select\u0026gt; elements allow you to select more than one option. You can find out if your \u0026lt;select\u0026gt; element is one of these by using:\nJava Python C# Ruby JavaScript Boolean doesThisAllowMultipleSelections = selectObject.isMultiple();   does_this_allow_multiple_selections = select_object.is_multiple   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    does_this_allow_multiple_selections = select_object.multiple?   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR      "
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/support_packages/mouse_and_keyboard_actions_in_detail/",
	"title": "Acciones en detalle del mouse y teclado",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Suppose you have an arbitrary web element e:\nJava Python C# Ruby JavaScript WebElement e = driver.findElement(By.id(\u0026#34;testElement\u0026#34;));   e = driver.find_element_by_id(\u0026#34;testElement\u0026#34;)   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR      You can simulate mouse clicking on e if it\u0026rsquo;s visible and has a height and width that are greater than 0:\nJava Python C# Ruby JavaScript e.click();   e.click()   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR      Moreover, it\u0026rsquo;s possible to mimic hovering of the cursor over e. In order to do so, you\u0026rsquo;ll need the following import statement:\nJava Python C# Ruby JavaScript import org.openqa.selenium.interactions.Actions;   from selenium.webdriver import ActionChains   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR      With this statement in place, you can now move over the element in question:\nJava Python C# Ruby JavaScript Actions actions = new Actions(driver); actions.moveToElement(e); actions.perform();   actions = ActionChains(driver) actions.move_to_element(e) actions.perform()   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR      If e is an input or textarea element, the following keyboard actions can be carried out:\n Enter a sequence of characters in e:  Java Python C# Ruby JavaScript e.sendKeys(\u0026#34;Test\u0026#34;);   e.send_keys(\u0026#34;Test\u0026#34;)   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR      2. Delete the text that\u0026rsquo;s in e (if there is any):\nJava Python C# Ruby JavaScript e.clear();   e.clear()   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR      "
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/introduction/about_this_documentation/",
	"title": "Acerca de esta documentación",
	"tags": [],
	"description": "",
	"content": "Estos documentos, como el código en sí, son mantenidos al 100% por voluntarios dentro de la comunidad de Selenium. Muchos lo han estado usando desde su inicio, pero muchos más lo han estado usando desde hace poco y han dado su tiempo para ayudar a mejorar la experiencia de iniciación para los nuevos usuarios.\nSi hay un problema con la documentación, ¡queremos saberlo! La mejor manera de comunicar un problema es visitar https://github.com/seleniumhq/docs/issues y buscar para ver si el problema ya se ha archivado o no. Si no, ¡no dudes en abrir uno!\nMuchos miembros de la comunidad frecuentan el canal IRC #selenium en irc.freenode.net. ¡No dude en venir y hacer preguntas y si obtiene ayuda que cree que podría ser útil en estos documentos, asegúrese de agregar su contribución! Podemos actualizar estos documentos, pero es mucho más fácil para todos cuando recibimos contribuciones de fuera de los encargados normales.\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/getting_started_with_webdriver/performing_actions_on_the_aut/",
	"title": "Ejecutando acciones en la AUT*",
	"tags": [],
	"description": "",
	"content": " Puede establecer el texto de un elemento utilizando el método sendKeys de la siguiente manera:\nJava Python C# Ruby JavaScript String name = \u0026#34;Charles\u0026#34;; driver.findElement(By.name(\u0026#34;name\u0026#34;)).sendKeys(name);   name = \u0026#34;Charles\u0026#34; driver.find_element_by_name(\u0026#34;name\u0026#34;).send_keys(name)   string name = \u0026#34;Charles\u0026#34;; driver.FindElement(By.Name(\u0026#34;name\u0026#34;)).SendKeys(name);   name = \u0026#34;Charles\u0026#34; driver.find_element(name: \u0026#34;name\u0026#34;).send_keys(name)   const name = \u0026#34;Charles\u0026#34;; await driver.findElement(By.name(\u0026#39;name\u0026#39;)).sendKeys(name);     Algunas aplicaciones web usan bibliotecas JavaScript para agregar la funcionalidad de arrastrar y soltar. El siguiente es un ejemplo básico de arrastrar un elemento a otro elemento:\nJava Python C# Ruby JavaScript WebElement source = driver.findElement(By.id(\u0026#34;source\u0026#34;)); WebElement target = driver.findElement(By.id(\u0026#34;target\u0026#34;)); new Actions(driver).dragAndDrop(source, target).build().perform();   source = driver.find_element_by_id(\u0026#34;source\u0026#34;) target = driver.find_element_by_id(\u0026#34;target\u0026#34;) ActionChains(driver).drag_and_drop(source, target).perform()   IWebElement source = driver.FindElement(By.Id(\u0026#34;source\u0026#34;)); IWebElement target = driver.FindElement(By.Id(\u0026#34;target\u0026#34;)); new Actions(driver).DragAndDrop(source, target).Build().Perform();   source = driver.find_element(id: \u0026#34;source\u0026#34;) target = driver.find_element(id: \u0026#34;target\u0026#34;) driver.action.drag_and_drop(source, target).perform   const actions = driver.actions({bridge: true}); const source = await driver.findElement(By.id(\u0026#39;source\u0026#39;)); const target = await driver.findElement(By.id(\u0026#39;target\u0026#39;)); await actions.dragAndDrop(source, target).perform();     Al hacer clic en un elemento Puede hacer clic en un elemento utilizando el método de clic:\nJava Python C# Ruby JavaScript driver.findElement(By.cssSelector(\u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;)).click();   driver.find_element_by_css_selector(\u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;).click()   driver.FindElement(By.CssSelector(\u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;)).Click();   driver.find_element(css: \u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;).click   await driver.findElement(By.css(\u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;)).click();     *AUT: Aplicación bajo pruebas (Application under test en inglés)\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/webdriver/waits/",
	"title": "Esperas",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n WebDriver can generally be said to have a blocking API. Because it is an out-of-process library that instructs the browser what to do, and because the web platform has an intrinsically asynchronous nature, WebDriver doesn\u0026rsquo;t track the active, real-time state of the DOM. This comes with some challenges that we will discuss here.\nFrom experience, most intermittents that arise from use of Selenium and WebDriver are connected to race conditions that occur between the browser and the user\u0026rsquo;s instructions. An example could be that the user instructs the browser to navigate to a page, then gets a no such element error when trying to find an element.\nConsider the following document:\n\u0026lt;!doctype html\u0026gt; \u0026lt;meta charset=utf-8\u0026gt; \u0026lt;title\u0026gt;Race Condition Example\u0026lt;/title\u0026gt; \u0026lt;script\u0026gt; var initialised = false; window.addEventListener(\u0026#34;load\u0026#34;, function() { var newElement = document.createElement(\u0026#34;p\u0026#34;); newElement.textContent = \u0026#34;Hello from JavaScript!\u0026#34;; document.body.appendChild(newElement); initialised = true; }); \u0026lt;/script\u0026gt; The WebDriver instructions might look innocent enough:\nJava Python C# Ruby JavaScript driver.get(\u0026#34;file:///race_condition.html\u0026#34;); WebElement element = driver.findElement(By.tagName(\u0026#34;p\u0026#34;)); assertEquals(element.getText(), \u0026#34;Hello from JavaScript!\u0026#34;);   driver.navigate(\u0026#34;file:///race_condition.html\u0026#34;) el = driver.find_element_by_tag_name(\u0026#34;p\u0026#34;) assert el.text == \u0026#34;Hello from JavaScript!\u0026#34;   driver.Navigate().GoToUrl(\u0026#34;file:///race_condition.html\u0026#34;); IWebElement element = driver.FindElement(By.TagName(\u0026#34;p\u0026#34;)); assertEquals(element.Text, \u0026#34;Hello from JavaScript!\u0026#34;);   # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    await driver.get(\u0026#39;file:///race_condition.html\u0026#39;); const element = await driver.findElement(By.css(\u0026#39;p\u0026#39;)); assert.strictEqual(await element.getText(), \u0026#39;Hello from JavaScript!\u0026#39;);     The issue here is that the default page load strategy used in WebDriver listens for the document.readyState to change to \u0026quot;complete\u0026quot; before returning from the call to navigate. Because the p element is added after the document has completed loading, this WebDriver script might be intermittent. It “might” be intermittent because no guarantees can be made about elements or events that trigger asynchronously without explicitly waiting—or blocking—on those events.\nFortunately, using the normal instruction set available on the WebElement interface—such as WebElement.click and _WebElement.sendKeys_—are guaranteed to be synchronous, in that the function calls won\u0026rsquo;t return (or the callback won\u0026rsquo;t trigger in callback-style languages) until the command has been completed in the browser. The advanced user interaction APIs, Keyboard and Mouse, are exceptions as they are explicitly intended as “do what I say” asynchronous commands.\nWaiting is having the automated task execution elapse a certain amount of time before continuing with the next step.\nTo overcome the problem of race conditions between the browser and your WebDriver script, most Selenium clients ship with a wait package. When employing a wait, you are using what is commonly referred to as an explicit wait.\nExplicit wait Explicit waits are available to Selenium clients for imperative, procedural languages. They allow your code to halt program execution, or freeze the thread, until the condition you pass it resolves. The condition is called with a certain frequency until the timeout of the wait is elapsed. This means that for as long as the condition returns a falsy value, it will keep trying and waiting.\nSince explicit waits allow you to wait for a condition to occur, they make a good fit for synchronising the state between the browser and its DOM, and your WebDriver script.\nTo remedy our buggy instruction set from earlier, we could employ a wait to have the findElement call wait until the dynamically added element from the script has been added to the DOM:\nJava Python C# Ruby JavaScript WebDriver driver = new ChromeDriver(); driver.get(\u0026#34;https://google.com/ncr\u0026#34;); driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;cheese\u0026#34; + Keys.ENTER); // Initialize and wait till element(link) became clickable - timeout in 10 seconds WebElement firstResult = new WebDriverWait(driver, 10) .until(ExpectedConditions.elementToBeClickable(By.xpath(\u0026#34;//a/h3\u0026#34;))); // Print the first result System.out.println(firstResult.getText());   from selenium.webdriver.support.ui import WebDriverWait def document_initialised(driver): return driver.execute_script(\u0026#34;return initialised\u0026#34;) driver.navigate(\u0026#34;file:///race_condition.html\u0026#34;) WebDriverWait(driver).until(document_initialised) el = driver.find_element_by_tag_name(\u0026#34;p\u0026#34;) assert el.text == \u0026#34;Hello from JavaScript!\u0026#34;   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    const documentInitialised = () =\u0026gt; driver.executeScript(\u0026#39;return initialised\u0026#39;); await driver.get(\u0026#39;file:///race_condition.html\u0026#39;); await driver.wait(() =\u0026gt; documentInitialised(), 10000); const element = await driver.findElement(By.css(\u0026#39;p\u0026#39;)); assert.strictEqual(await element.getText(), \u0026#39;Hello from JavaScript!\u0026#39;);     We pass in the condition as a function reference that the wait will run repeatedly until its return value is truthy. A “truthful” return value is anything that evaluates to boolean true in the language at hand, such as a string, number, a boolean, an object (including a WebElement), or a populated (non-empty) sequence or list. That means an empty list evaluates to false. When the condition is truthful and the blocking wait is aborted, the return value from the condition becomes the return value of the wait.\nWith this knowledge, and because the wait utility ignores no such element errors by default, we can refactor our instructions to be more concise:\nJava Python C# Ruby JavaScript // We don\u0026#39;t have a Java code sample yet - Help us out and raise a PR    from selenium.webdriver.support.ui import WebDriverWait driver.navigate(\u0026#34;file:///race_condition.html\u0026#34;) el = WebDriverWait(driver).until(lambda d: return d.find_element_by_tag_name(\u0026#34;p\u0026#34;)) assert el.text == \u0026#34;Hello from JavaScript!\u0026#34;   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR      In that example, we pass in an anonymous function (but we could also define it explicitly as we did earlier so it may be reused). The first and only argument that is passed to our condition is always a reference to our driver object, WebDriver (called d in the example). In a multi-threaded environment, you should be careful to operate on the driver reference passed in to the condition rather than the reference to the driver in the outer scope.\nBecause the wait will swallow no such element errors that are raised when the element isn\u0026rsquo;t found, the condition will retry until the element is found. Then it will take the return value, a WebElement, and pass it back through to our script.\nIf the condition fails, e.g. a truthful return value from the condition is never reached, the wait will throw/raise an error/exception called a timeout error.\nOptions The wait condition can be customised to match your needs. Sometimes it\u0026rsquo;s unnecessary to wait the full extent of the default timeout, as the penalty for not hitting a successful condition can be expensive.\nThe wait lets you pass in an argument to override the timeout:\nJava Python C# Ruby JavaScript //new WebDriverWait(driver,3).until(some_condition(WebElement)) new WebDriverWait(driver, 3).until(ExpectedConditions.elementToBeClickable(By.xpath(\u0026#34;//a/h3\u0026#34;)));   WebDriverWait(driver, timeout=3).until(some_condition)   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR      Expected conditions Because it\u0026rsquo;s quite a common occurrence to have to synchronise the DOM and your instructions, most clients also come with a set of predefined expected conditions. As might be obvious by the name, they are conditions that are predefined for frequent wait operations.\nThe conditions available in the different language bindings vary, but this is a non-exhaustive list of a few:\n alert is present element exists element is visible title contains title is element staleness visible text  You can refer to the API documentation for each client binding to find an exhaustive list of expected conditions:\n Java\u0026rsquo;s org.openqa.selenium.support.ui.ExpectedConditions class Python\u0026rsquo;s selenium.webdriver.support.expected_conditions class .NET\u0026rsquo;s OpenQA.Selenium.Support.UI.ExpectedConditions type  Implicit wait There is a second type of wait that is distinct from explicit wait called implicit wait. By implicitly waiting, WebDriver polls the DOM for a certain duration when trying to find any element. This can be useful when certain elements on the webpage are not available immediately and need some time to load.\nImplicit waiting for elements to appear is disabled by default and will need to be manually enabled on a per-session basis. Mixing explicit waits and implicit waits will cause unintended consequences, namely waits sleeping for the maximum time even if the element is available or condition is true.\nWarning: Do not mix implicit and explicit waits. Doing so can cause unpredictable wait times. For example, setting an implicit wait of 10 seconds and an explicit wait of 15 seconds could cause a timeout to occur after 20 seconds.\nAn implicit wait is to tell WebDriver to poll the DOM for a certain amount of time when trying to find an element or elements if they are not immediately available. The default setting is 0, meaning disabled. Once set, the implicit wait is set for the life of the session.\nJava Python C# Ruby JavaScript WebDriver driver = new FirefoxDriver(); driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS); driver.get(\u0026#34;http://somedomain/url_that_delays_loading\u0026#34;); WebElement myDynamicElement = driver.findElement(By.id(\u0026#34;myDynamicElement\u0026#34;));   driver = Firefox() driver.implicitly_wait(10) driver.get(\u0026#34;http://somedomain/url_that_delays_loading\u0026#34;) my_dynamic_element = driver.find_element_by_id(\u0026#34;myDynamicElement\u0026#34;)   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    (async function(){ // Apply timeout for 10 seconds await driver.manage().setTimeouts( { implicit: 10000 } ); // Navigate to url await driver.get(\u0026#39;http://somedomain/url_that_delays_loading\u0026#39;); let webElement = await driver.findElement(By.id(\u0026#34;myDynamicElement\u0026#34;)); }());     FluentWait FluentWait instance defines the maximum amount of time to wait for a condition, as well as the frequency with which to check the condition.\nUsers may configure the wait to ignore specific types of exceptions whilst waiting, such as NoSuchElementException when searching for an element on the page.\nJava Python C# Ruby JavaScript // Waiting 30 seconds for an element to be present on the page, checking // for its presence once every 5 seconds. Wait\u0026lt;WebDriver\u0026gt; wait = new FluentWait\u0026lt;WebDriver\u0026gt;(driver) .withTimeout(30, SECONDS) .pollingEvery(5, SECONDS) .ignoring(NoSuchElementException.class); WebElement foo = wait.until(new Function\u0026lt;WebDriver, WebElement\u0026gt;() { public WebElement apply(WebDriver driver) { return driver.findElement(By.id(\u0026#34;foo\u0026#34;)); } });   driver = Firefox() driver.get(\u0026#34;http://somedomain/url_that_delays_loading\u0026#34;) wait = WebDriverWait(driver, 10, poll_frequency=1, ignored_exceptions=[ElementNotVisibleException, ElementNotSelectableException]) element = wait.until(EC.element_to_be_clickable((By.XPATH, \u0026#34;//div\u0026#34;)))   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR      "
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/worst_practices/gmail_email_and_facebook_logins/",
	"title": "Gmail, email y Facebook logins",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n For multiple reasons, logging into sites like Gmail and Facebook using WebDriver is not recommended. Aside from being against the usage terms for these sites (where you risk having the account shut down), it is slow and unreliable.\nThe ideal practice is to use the APIs that email providers offer, or in the case of Facebook the developer tools service which exposes an API for creating test accounts, friends and so forth. Although using an API might seem like a bit of extra hard work, you will be paid back in speed, reliability, and stability. The API is also unlikely to change whereas webpages and HTML locators change often and require you to update your test framework.\nLogging in to third party sites using WebDriver at any point of your test increases the risk of your test failing because it makes your test longer. A general rule of thumb is that longer tests are more fragile and unreliable.\nWebDriver implementations that are W3C conformant also annotate the navigator object with a webdriver property so that Denial of Service attacks can be mitigated.\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/guidelines_and_recommendations/mock_external_services/",
	"title": "Mock de servicios externos",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Eliminating the dependencies on external services will greatly improve the speed and stability of your tests.\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/getting_started_with_webdriver/",
	"title": "Primeros pasos con WebDriver",
	"tags": [],
	"description": "",
	"content": " Primeros pasos con WebDriver Selenium admite la automatización de todos los principales navegadores del mercado mediante el uso del WebDriver. WebDriver es una API y un protocolo que define una interfaz de lenguaje neutral para controlar el comportamiento de los navegadores web. Cada navegador está respaldado por una implementación específica de WebDriver, llamada controlador (o driver). El controlador es el componente responsable de manipular el navegador, y maneja la comunicación hacia y desde Selenium y el navegador.\nEsta separación es parte de un esfuerzo consciente para que los proveedores de navegadores se hagan responsables de la implementación de sus navegadores. Selenium hace uso de estos controladores de terceros cuando es posible, pero también proporciona sus propios controladores mantenidos por el proyecto para los casos en que esto no pueda ser realizado.\nEl marco Selenium une todas estas piezas a través de una interfaz orientada al usuario que permite que los diferentes backends del navegador se utilicen de forma transparente, lo que permite la automatización entre navegadores (cross-browser) y plataformas cruzadas (cross-platform).\nSe pueden encontrar más detalles sobre los controladores en Driver Idiosyncrasies.\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/webdriver/support_classes/",
	"title": "Clases de apoyo",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n "
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/worst_practices/test_dependency/",
	"title": "Dependencia entre pruebas",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n A common idea and misconception about automated testing is regarding a specific test order. Your tests should be able to run in any order, and not rely on other tests to complete in order to be successful.\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/guidelines_and_recommendations/improved_reporting/",
	"title": "Mejores reportes",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Selenium is not designed to report on the status of test cases run. Taking advantage of the built-in reporting capabilities of unit test frameworks is a good start. Most unit test frameworks have reports that can generate xUnit or HTML formatted reports. xUnit reports are popular for importing results to a Continuous Integration (CI) server like Jenkins, Travis, Bamboo, etc. Here are some links for more information regarding report outputs for several languages. "
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/support_packages/working_with_web_elements/",
	"title": "Trabajando con elementos web",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n "
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/webdriver/",
	"title": "WebDriver",
	"tags": [],
	"description": "",
	"content": " WebDriver El cambio más grande en Selenium, recientemente, ha sido la inclusión de la API WebDriver. Manejar un navegador de forma nativa como lo haría un usuario localmente o en una máquina remota usando el servidor Selenium, marca un salto adelante en términos de automatización del navegador.\nSelenium WebDriver encaja en el mismo rol que RC, y ha incorporado los enlaces 1.x originales. Se refiere tanto a los enlaces de lenguaje como a las implementaciones del código de control del navegador individual. Esto se conoce comúnmente como WebDriver o, a veces, como Selenium 2.\nSelenium 1.0 + WebDriver = Selenium 2.0\n El WebDriver está diseñado en una interfaz de programación más simple y concisa junto con algunas limitaciones en la API Selenium-RC.\n El WebDriver es una API compacta orientada a objetos en comparación con Selenium 1.0.\n Este, comtrola al navegador de manera mucho más efectiva y supera las limitaciones de Selenium 1 que afectaron nuestra cobertura de prueba funcional, como la carga o descarga de archivos, ventanas emergentes y barreras de diálogo.\n  WebDriver supera la limitación de la política del mismo origen de host único de Selenium RC.\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/webdriver/js_alerts_prompts_and_confirmations/",
	"title": "Alertas, avisos y confirmaciones de JavaScript",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n WebDriver provides an API for working with the three types of native popup message offered by JavaScript. These popups are styled by the browser and offer limited customisation.\nAlerts The simplest of these is referred to as an alert, which shows a custom message, and a single button which dismisses the alert, labelled in most browsers as OK. It can also be dismissed in most browsers by pressing the close button, but this will always do the same thing as the OK button. See an example alert.\nWebDriver can get the text from the popup and accept or dismiss these alerts.\nJava Python C# Ruby JavaScript //Click the link to activate the alert driver.findElement(By.linkText(\u0026#34;See an example alert\u0026#34;)).click(); //Wait for the alert to be displayed and store it in a variable Alert alert = wait.until(ExpectedConditions.alertIsPresent()); //Store the alert text in a variable String text = alert.getText(); //Press the OK button alert.accept();   # Click the link to activate the alert driver.find_element_by_link_text(\u0026#34;See an example alert\u0026#34;).click() # Wait for the alert to be displayed and store it in a variable alert = wait.until(expected_conditions.alert_is_present()) # Store the alert text in a variable text = alert.text # Press the OK button alert.accept()   //Click the link to activate the alert driver.FindElement(By.LinkText(\u0026#34;See an example alert\u0026#34;)).Click(); //Wait for the alert to be displayed and store it in a variable IAlert alert = wait.Until(ExpectedConditions.AlertIsPresent()); //Store the alert text in a variable string text = alert.Text; //Press the OK button alert.Accept();   # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    //Click the link to activate the alert await driver.findElement(By.linkText(\u0026#39;See an example alert\u0026#39;)).click(); // Wait for the alert to be displayed await driver.wait(until.alertIsPresent()); // Store the alert in a variable let alert = await driver.switchTo().alert(); //Store the alert text in a variable let alertText = await alert.getText(); //Press the OK button await alert.accept(); // Note: To use await, the above code should be inside an async function      Confirm A confirm box is similar to an alert, except the user can also choose to cancel the message. See a sample confirm.\nThis example also shows a different approach to storing an alert:\nJava Python C# Ruby JavaScript //Click the link to activate the alert driver.findElement(By.linkText(\u0026#34;See a sample confirm\u0026#34;)).click(); //Wait for the alert to be displayed wait.until(ExpectedConditions.alertIsPresent()); //Store the alert in a variable Alert alert = driver.switchTo().alert(); //Store the alert in a variable for reuse String text = alert.getText(); //Press the Cancel button alert.dismiss();   # Click the link to activate the alert driver.find_element_by_link_text(\u0026#34;See a sample confirm\u0026#34;).click() # Wait for the alert to be displayed wait.until(expected_conditions.alert_is_present()) # Store the alert in a variable for reuse alert = driver.switch_to.alert # Store the alert text in a variable text = alert.text # Press the Cancel button alert.dismiss()   //Click the link to activate the alert driver.FindElement(By.LinkText(\u0026#34;See a sample confirm\u0026#34;)).Click(); //Wait for the alert to be displayed wait.Until(ExpectedConditions.AlertIsPresent()); //Store the alert in a variable IAlert alert = driver.SwitchTo().Alert(); //Store the alert in a variable for reuse string text = alert.Text; //Press the Cancel button alert.Dismiss();   # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    //Click the link to activate the alert await driver.findElement(By.linkText(\u0026#39;See an example alert\u0026#39;)).click(); // Wait for the alert to be displayed await driver.wait(until.alertIsPresent()); // Store the alert in a variable let alert = await driver.switchTo().alert(); //Store the alert text in a variable let alertText = await alert.getText(); //Press the Cancel button await alert.dismiss(); // Note: To use await, the above code should be inside an async function      Prompt Prompts are similar to confirm boxes, except they also include a text input. Similar to working with form elements, you can use WebDriver\u0026rsquo;s send keys to fill in a response. This will completely replace the placeholder text. Pressing the cancel button will not submit any text. See a sample prompt.\nJava Python C# Ruby JavaScript //Click the link to activate the alert driver.findElement(By.linkText(\u0026#34;See a sample prompt\u0026#34;)).click(); //Wait for the alert to be displayed and store it in a variable Alert alert = wait.until(ExpectedConditions.alertIsPresent()); //Type your message alert.sendKeys(\u0026#34;Selenium\u0026#34;); //Press the OK button alert.accept();   # Click the link to activate the alert driver.find_element_by_link_text(\u0026#34;See a sample prompt\u0026#34;).click() # Wait for the alert to be displayed wait.until(expected_conditions.alert_is_present()) # Store the alert in a variable for reuse alert = Alert(driver) # Type your message alert.send_keys(\u0026#34;Selenium\u0026#34;) # Press the OK button alert.accept()   //Click the link to activate the alert driver.FindElement(By.LinkText(\u0026#34;See a sample prompt\u0026#34;)).Click(); //Wait for the alert to be displayed and store it in a variable IAlert alert = wait.Until(ExpectedConditions.AlertIsPresent()); //Type your message alert.SendKeys(\u0026#34;Selenium\u0026#34;); //Press the OK button alert.Accept();   # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    //Click the link to activate the alert await driver.findElement(By.linkText(\u0026#39;See an example alert\u0026#39;)).click(); // Wait for the alert to be displayed await driver.wait(until.alertIsPresent()); // Store the alert in a variable let alert = await driver.switchTo().alert(); //Type your message await alert.sendKeys(\u0026#34;Selenium\u0026#34;); //Press the OK button await alert.accept(); //Note: To use await, the above code should be inside an async function      "
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/guidelines_and_recommendations/avoid_sharing_state/",
	"title": "Evitar compartir estados",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Although mentioned in several places it is worth mentioning again. Ensure tests are isolated from one another.\nDon\u0026rsquo;t share test data. Imagine several tests that each query the database for valid orders before picking one to perform an action on. Should two tests pick up the same order you are likely to get unexpected behaviour.\nClean up stale data in the application that might be picked up by another test e.g. invalid order records.\nCreate a new WebDriver instance per test. This helps ensure test isolation and makes parallelisation simpler.\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/worst_practices/performance_testing/",
	"title": "Pruebas de desempeño",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Performance testing using Selenium and WebDriver is generally not advised. Not because it is incapable but because it is not optimised for the job and you are unlikely to get good results.\nIt may seem ideal to performance test in the context of the user but a suite of WebDriver tests are subjected to many points of external and internal fragility which are beyond your control; for example browser startup speed, speed of HTTP servers, response of third party servers that host JavaScript or CSS, and the instrumentation penalty of the WebDriver implementation itself. Variation at these points will cause variation in your results. It is difficult to separate the difference between the performance of your website and the performance of external resources, and it is also hard to tell what the performance penalty is for using WebDriver in the browser, especially if you are injecting scripts.\nThe other potential attraction is \u0026ldquo;saving time\u0026rdquo; — carrying out functional and performance tests at the same time. However, functional and performance tests have opposing objectives. To test functionality, a tester may need to be patient and wait for loading, but this will cloud the performance testing results and vice versa.\nTo improve the performance of your website, you will need to be able to analyse overall performance independent of environment differences, identify poor code practices, breakdown of performance of individual resources (i.e. CSS or JavaScript) in order to know what to improve. There are performance testing tools available that can do this job already, and which provide reporting and analysis which can even make improvement suggestions.\nExample (open source) packages to use are: JMeter ?\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/remote_webdriver/",
	"title": "WebDriver remoto",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n WebDriver remoto You can use WebDriver remotely the same way you would use it locally. The primary difference is that a remote WebDriver needs to be configured so that it can run your tests on a separate machine.\nA remote WebDriver is composed of two pieces: a client and a server. The client is your WebDriver test and the server is simply a Java servlet, which can be hosted in any modern JEE app server.\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/guidelines_and_recommendations/",
	"title": "Guías y recomendaciones",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Guías y recomendaciones A note on \u0026ldquo;Best Practices\u0026rdquo;: We\u0026rsquo;ve intentionally avoided the phrase \u0026ldquo;Best Practices\u0026rdquo; in this documentation. No one approach works for all situations. We prefer the idea of \u0026ldquo;Guidelines and Recommendations.\u0026rdquo; We encourage you to read through these and thoughtfully decide what approaches will work for you in your particular environment.\nFunctional testing is difficult to get right for many reasons. As if application state, complexity, and dependencies don\u0026rsquo;t make testing difficult enough, dealing with browsers (especially with cross-browser incompatibilities) makes writing good tests a challenge.\nSelenium provides tools to make functional user interaction easier, but doesn\u0026rsquo;t help you write well-architected test suites. In this chapter we offer advice, guidelines, and recommendations. on how to approach functional web page automation.\nThis chapter records software design patterns popular amongst many of the users of Selenium that have proven successful over the years.\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/guidelines_and_recommendations/test_independency/",
	"title": "Independencia en las pruebas",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Write each test as its own unit. Write the tests in a way that won\u0026rsquo;t be reliant on other tests to complete:\nLet\u0026rsquo;s say there is a content management system with which you can create some custom content which then appears on your website as a module after publishing, and it may take some time to sync between the CMS and the application.\nA wrong way of testing your module is that the content is created and published in one test, and then checking the module in another test. This is not feasible as the content may not be available immediately for the other test after publishing.\nInstead, you can create a stub content which can be turned on and off within the affected test, and use that for validating the module. However, for content creation, you can still have a separate test.\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/webdriver/http_proxies/",
	"title": "Proxies Http",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n "
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/worst_practices/link_spidering/",
	"title": "Rastreo de enlaces",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Using WebDriver to spider through links is not a recommended practice not because it cannot be done, but because it’s definitely not the most ideal tool. WebDriver needs time to start up, and can take several seconds up to a minute depending on how your test is written, just to get to the page and traverse through the DOM.\nInstead of using WebDriver for this, you could save a ton of time by executing a curl command, or using a library such as BeautifulSoup since these methods don’t rely on creating a browser and navigating to a page. You are saving tonnes of time by not using WebDriver for this task.\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/guidelines_and_recommendations/consider_using_a_fluent_api/",
	"title": "Considerar el uso de un API fluída",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Martin Fowler coined the term \u0026ldquo;Fluent API\u0026rdquo;. Selenium already implements something like this in their FluentWait class which is meant as an alternative to the standard Wait class. You could enable the Fluent API design pattern in your page object and then query the Google search page with a code snippet like this one:\ndriver.get( \u0026#34;http://www.google.com/webhp?hl=en\u0026amp;amp;tab=ww\u0026#34; ); GoogleSearchPage gsp = new GoogleSearchPage(); gsp.withFluent().setSearchString().clickSearchButton(); The Google page object class with this fluent behavior might look like this:\npublic class GoogleSearchPage extends LoadableComponent\u0026lt;GoogleSearchPage\u0026gt; { private final WebDriver driver; private GSPFluentInterface gspfi; public class GSPFluentInterface { private GoogleSearchPage gsp; public GSPFluentInterface(GoogleSearchPage googleSearchPage) { gsp = googleSearchPage; } public GSPFluentInterface clickSearchButton() { gsp.searchButton.click(); return this; } public GSPFluentInterface setSearchString( String sstr ) { clearAndType( gsp.searchField, sstr ); return this; } } @FindBy(id = \u0026#34;gbqfq\u0026#34;) private WebElement searchField; @FindBy(id = \u0026#34;gbqfb\u0026#34;) private WebElement searchButton; public GoogleSearchPage(WebDriver driver) { gspfi = new GSPFluentInterface( this ); this.get(); // If load() fails, calls isLoaded() until page is finished loading  PageFactory.initElements(driver, this); // Initialize WebElements on page  } public GSPFluentInterface withFluent() { return gspfi; } public void clickSearchButton() { searchButton.click(); } public void setSearchString( String sstr ) { clearAndType( searchField, sstr ); } @Override protected void isLoaded() throws Error { Assert.assertTrue(\u0026#34;Google search page is not yet loaded.\u0026#34;, isSearchFieldVisible() ); } @Override protected void load() { if ( isSFieldPresent ) { Wait\u0026lt;WebDriver\u0026gt; wait = new WebDriverWait( driver, 3 ); wait.until( visibilityOfElementLocated( By.id(\u0026#34;gbqfq\u0026#34;) ) ).click(); } } }"
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/webdriver/page_loading_strategy/",
	"title": "Estrategia de carga de página",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n "
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/worst_practices/",
	"title": "Peores prácticas",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Peores prácticas "
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/webdriver/web_element/",
	"title": "Elemento web",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Represents a DOM element. WebElements can be found by searching from the document root using a WebDriver instance, or by searching under another WebElement:\nJava Python C# Ruby JavaScript WebDriver driver = new FirefoxDriver(); driver.get(\u0026#34;http://www.google.com\u0026#34;); WebElement searchForm = driver.findElement(By.tagName(\u0026#34;form\u0026#34;)); WebElement searchbox = driver.findElement(By.name(\u0026#34;q\u0026#34;)); searchbox.sendKeys(\u0026#34;webdriver\u0026#34;);   driver = Firefox() driver.get(\u0026#34;http://www.google.com\u0026#34;) search_form = driver.find_element_by_tag_name(\u0026#34;form\u0026#34;) search_box = search_form.find_element_by_name(\u0026#34;q\u0026#34;) search_box.send_keys(\u0026#34;webdriver\u0026#34;)   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    let {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); driver = new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); (async function test(){ //Navigate to url await driver.get(\u0026#39;http://www.google.com\u0026#39;); //Get and store DOM element \u0026#39;\u0026lt;form\u0026gt;\u0026#39; let searchForm = await driver.findElement(By.name(\u0026#39;f\u0026#39;)); //Get search box element from webElement \u0026#39;form\u0026#39; let searchBar = await searchForm.findElement(By.name(\u0026#39;q\u0026#39;)); //Perform action using WebElement await searchBar.sendKeys(\u0026#39;Webdriver\u0026#39;); })();     "
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/grid/",
	"title": "Grid",
	"tags": [],
	"description": "",
	"content": " Grid Selenium Grid es un servidor proxy inteligente que permite que las pruebas de Selenium enruten comandos a instancias remotas del navegador web. Su objetivo es proporcionar una manera fácil de ejecutar pruebas en paralelo en múltiples máquinas.\nCon Selenium Grid, un servidor actúa como el centro que enruta los comandos de prueba con formato JSON a uno o más nodos de Grid registrados. Las pruebas se ponen en contacto con el concentrador (o hub) para obtener acceso a instancias de explorador remoto. El concentrador tiene una lista de servidores registrados a los que proporciona acceso y nos permite controlar estas instancias.\nSelenium Grid nos permite ejecutar pruebas en paralelo en múltiples máquinas, y administrar diferentes versiones y configuraciones de navegador de forma centralizada (en lugar de en cada prueba individual).\nSelenium Grid no es una solución mágica para todas las situaciones. Resuelve un subconjunto de problemas comunes de delegación y distribución, pero, por ejemplo, no administrará su infraestructura y podría no satisfacer algunas de sus necesidades específicas.\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/guidelines_and_recommendations/fresh_browser_per_test/",
	"title": "Nueva instancia del navegador por prueba",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Start each test from a clean known state. Ideally, spin up a new virtual machine for each test. If spinning up a new virtual machine is not practical, at least start a new WebDriver for each test. For Firefox, start a WebDriver with your known profile.\nFirefoxProfile profile = new FirefoxProfile(new File(\u0026#34;pathToFirefoxProfile\u0026#34;)); WebDriver driver = new FirefoxDriver(profile);"
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/driver_idiosyncrasies/",
	"title": "Carácter de los controladores",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Carácter de los controladores "
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/webdriver/keyboard/",
	"title": "Teclado",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Represents a KeyBoard event. KeyBoard actions are performed by using low-level interface which allows us to provide virtualized device input to the web browser.\nsendKeys The sendKeys types a key sequence in DOM element even if modifier key sequence is encountered.\nJava Python C# Ruby JavaScript import org.openqa.selenium.By; import org.openqa.selenium.Keys; import org.openqa.selenium.WebDriver; import org.openqa.selenium.chrome.ChromeDriver; public class HelloSelenium { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); // Enter text \u0026#34;q\u0026#34; and perform keyboard action \u0026#34;Enter\u0026#34;  driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;q\u0026#34; + Keys.ENTER); } finally { driver.quit(); } } }   // We don\u0026#39;t have a Python code sample yet - Help us out and raise a PR   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    // We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR   const {Builder, By, Key} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Enter text \u0026#34;webdriver\u0026#34; and perform keyboard action \u0026#34;Enter\u0026#34;  await driver.findElement(By.name(\u0026#39;q\u0026#39;)).sendKeys(\u0026#39;webdriver\u0026#39;, Key.ENTER); } finally { await driver.quit(); } })();     "
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/webdriver/mouse/",
	"title": "Mouse",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n "
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/support_packages/",
	"title": "Paquetes de soporte",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Paquetes de soporte "
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/front_matter/",
	"title": "Texto preliminar",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Texto preliminar "
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/contributing/",
	"title": "Contribuyendo a la documentación de Selenium",
	"tags": [],
	"description": "",
	"content": " Selenium es un gran proyecto de software y la documentación es clave para comprender cómo funcionan las cosas y aprender formas efectivas de explotar su potencial.\nParte de la documentación de Selenium todavía se sirve de nuestro repositorio ** www.seleniumhq.org ** . Sin embargo, estamos eliminando gradualmente esta documentación que se centra demasiado en Selenium RC y otras piezas anticuadas, a favor de esta reescritura.\nLa nueva documentación es un proyecto que comenzó a reescribir la documentación de Selenium desde cero. Este es un esfuerzo continuo (no dirigido a ninguna versión específica) para proporcionar un manual actualizado sobre cómo usar Selenium de manera efectiva. Esperamos traer las piezas de la documentación antigua que aún tienen sentido.\nLos aportes a los nuevos documentos siguen el proceso descrito en la sección a continuación sobre las contribuciones. Debería pasar un tiempo familiarizándose con la documentación leyendo más sobre ella.\nEl proyecto Selenium agradece las contribuciones de todos. Hay varias formas de colaborar:\nReportar un problema Al informar un nuevo problema o al comentar problemas existentes, asegúrese de que las discusiones estén relacionadas con temas técnicos concretos con el software Selenium o su documentación.\nTodos los componentes de Selenium cambian bastante rápido en el tiempo, por lo que esto puede hacer que la documentación esté desactualizada. Si considera que este es el caso, como se mencionó, no dude en reportar un problema. También es posible que sepa cómo actualizar la documentación, así que envíenos una solicitud (pull request) con los cambios relacionados.\nSi no está seguro de si lo que encontró es un problema o no, consulte primero a la lista de correo de selenium-users@, o únase a nosotros en el canal #selenium en irc.freenode.org o Slack.\nContribuciones El proyecto Selenium da la bienvenida a nuevos contribuyentes. Las personas que hacen contribuciones significativas y valiosas a lo largo del tiempo se hacen Committers y se les da acceso para realizar commit al proyecto.\nEste documento lo guiará a través del proceso de contribución.\nStep 1: Bifurcar (Fork) Haga fork al proyecto en Github y verifique su copia localmente.\n% git clone git@github.com:username/docs.git % cd docs % git remote add upstream git://github.com/seleniumhq/docs.git Dependencias: Hugo La documentación usa Hugo para construir y renderizar el sitio. Por favor, verifique todo localmente incluso antes de hacer commit a cualquier cambio instale Hugo y corra el servidor local para renderizar el sitio localmente.\nStep 2: Ramificación (Branch) Cree una rama nueva (feature branch) y comience a hackear:\n% git checkout -b my-feature-branch Practicamos el desarrollo basado en HEAD (HEAD-based development), lo que significa que todos los cambios se aplican directamente sobre la rama maestra (master).\nStep 3: Confirmar (Commit) Primero asegúrese de que git sepa su nombre y dirección de correo electrónico:\n% git config --global user.name \u0026#39;Santa Claus\u0026#39; % git config --global user.email \u0026#39;santa@example.com\u0026#39; Escribir buenos mensajes de confirmación (commit) es importante. Un mensaje de confirmación debe describir qué cambió, por qué y los problemas de referencia corregidos (si los hay). Siga estas pautas al escribir uno:\n Procure que el texto sea en inglés. Se colocan los ejemplos en Español para aumentar la comprensión. La primera línea debe tener alrededor de 50 caracteres o menos y contener una breve descripción del cambio. Mantenga la segunda línea en blanco. Envuelva todas las demás líneas en 72 columnas. Incluya Fixes # N, donde N es el número de problema (issue) que corrige la confirmación, si corresponde.  Un buen mensaje de confirmación puede verse así:\nexplicar cometer normativamente en una línea El cuerpo del mensaje de confirmación es unas pocas líneas de texto, que explican las cosas con más detalle, posiblemente brindando algunos antecedentes sobre la resolución del problema, etc. El cuerpo del mensaje de confirmación puede tener varios párrafos y, por favor, ajuste correctamente las palabras y mantenga las columnas con menos de 72 caracteres aproximadamente. De esa manera, \u0026#39;git log\u0026#39; mostrará las cosas muy bien incluso cuando está sangrado. Fixes # 141 La primera línea debe ser significativa, ya que es lo que las personas ven cuando ejecutan git shortlog ogit log --oneline.\nStep 4: Rebase Use git rebase (not git merge) para sincronizar tu trabajo de vez en cuando.\n% git fetch upstream % git rebase upstream/master Paso 5: Prueba Recuerde siempre ejecutar el servidor local, con esto puede estar seguro de que sus cambios no han roto nada.\nPaso 6: Traducciones Si está actualizando los documentos, agregando nuevos o eliminando los obsoletos, recuerde actualizar las traducciones. Por supuesto, es posible que no hables todos los idiomas traducidos en los documentos. Para eso, cree un hallazgo issue donde describa claramente que algo en los documentos ha cambiado y su traducción debe actualizarse. Con eso, alguien que habla ese idioma necesario puede intervenir y ayudarnos a mantenerlo actualizado.\nPaso 7: Firme el CLA Antes de que podamos aceptar, primero le pedimos a las personas que firmen un Acuerdo de licencia de colaborador (o CLA). Pedimos esto para que sepamos que los contribuyentes tienen el derecho de donar el código.\nCuando abre su solicitud (pull request), le pedimos que indique que ha firmado el CLA. Esto reducirá el tiempo que nos lleva integrarlo.\nPaso 8: Empuje (Push) % git push origin my-feature-branch Vaya a https://github.com/yourusername/docs.git y presione Pull Request y complete el formulario. Indique que ha firmado el CLA (consulte el Paso 7).\nLas solicitudes generalmente se revisan en unos pocos días. Si hay comentarios que abordar, aplique sus cambios en los nuevos commits (preferiblemente arreglos o fixups) y avance a la misma rama (branch).\nPaso 9: Integración Cuando se completa la revisión del código, un committer tomará su PR (pull request) y lo integrará en la rama (branch) gh-pages de los documentos. Como nos gusta mantener un historial lineal en la rama maestra, normalmente resumiremos los cambios (squash and rebase) del historial de su rama.\nComunicación Los contribuyentes de Selenium frecuentan el canal #selenium en irc.freenode.org o en Slack. También puede unirse a la lista de correo selenium-developers@.\n"
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/",
	"title": "El Proyecto para Automatización de Navegadores Selenium",
	"tags": [],
	"description": "",
	"content": " El Proyecto para Automatización de Navegadores Selenium Selenium es un proyecto padre que cobija a una gama de herramientas y bibliotecas que permiten y soportan la automatización de los navegadores web.\nProporciona extensiones para emular la interacción del usuario con los navegadores, un servidor de distribución para escalar la asignación del navegador y la infraestructura para implementaciones de la Especificación W3C del WebDriver que le permite escribir código intercambiable para todos los principales navegadores web.\nEste proyecto es posible gracias a los colaboradores voluntarios que han dedicado miles de horas de su propio tiempo y han hecho que el código fuente esté disponible gratuitamente para que cualquiera pueda usarlo, disfrutarlo y mejorarlo.\nSelenium reúne a proveedores de navegadores, ingenieros y entusiastas para promover una discusión abierta sobre la automatización de la plataforma web. El proyecto organiza una conferencia anual para enseñar y nutrir a la comunidad.\nEn el núcleo de Selenium se encuentra el WebDriver, una interfaz para escribir conjuntos de instrucciones que se pueden ejecutar indistintamente en muchos navegadores. Aquí está una de las instrucciones más simples que puede hacer:\nJava Python C# Ruby JavaScript import org.openqa.selenium.By; import org.openqa.selenium.Keys; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.firefox.FirefoxDriver; import org.openqa.selenium.support.ui.WebDriverWait; import static org.openqa.selenium.support.ui.ExpectedConditions.presenceOfElementLocated; public class HelloSelenium { public static void main(String[] args) { WebDriver driver = new FirefoxDriver(); WebDriverWait wait = new WebDriverWait(driver, 10); try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;); driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;cheese\u0026#34; + Keys.ENTER); WebElement firstResult = wait.until(presenceOfElementLocated(By.cssSelector(\u0026#34;h3\u0026gt;div\u0026#34;))); System.out.println(firstResult.getAttribute(\u0026#34;textContent\u0026#34;)); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.common.keys import Keys from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support.expected_conditions import presence_of_element_located #Este ejemplo requiere Selenium WebDriver 3.13 o posterior with webdriver.Firefox() as driver: wait = WebDriverWait(driver, 10) driver.get(\u0026#34;https://google.com/ncr\u0026#34;) driver.find_element_by_name(\u0026#34;q\u0026#34;).send_keys(\u0026#34;cheese\u0026#34; + Keys.RETURN) first_result = wait.until(presence_of_element_located((By.CSS_SELECTOR, \u0026#34;h3\u0026gt;div\u0026#34;))) print(first_result.get_attribute(\u0026#34;textContent\u0026#34;))   using System; using OpenQA.Selenium; using OpenQA.Selenium.Firefox; using OpenQA.Selenium.Support.UI; using SeleniumExtras.WaitHelpers; class HelloSelenium { static void Main() { using (IWebDriver driver = new FirefoxDriver()) { WebDriverWait wait = new WebDriverWait(driver, TimeSpan.FromSeconds(10)); driver.Navigate().GoToUrl(\u0026#34;https://www.google.com/ncr\u0026#34;); driver.FindElement(By.Name(\u0026#34;q\u0026#34;)).SendKeys(\u0026#34;cheese\u0026#34; + Keys.Enter); IWebElement firstResult = wait.Until(ExpectedConditions.ElementExists(By.CssSelector(\u0026#34;h3\u0026gt;div\u0026#34;))); Console.WriteLine(firstResult.GetAttribute(\u0026#34;textContent\u0026#34;)); } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox wait = Selenium::WebDriver::Wait.new(timeout: 10) begin driver.get \u0026#39;https://google.com/ncr\u0026#39; driver.find_element(name: \u0026#39;q\u0026#39;).send_keys \u0026#39;cheese\u0026#39;, :return first_result = wait.until { driver.find_element(css: \u0026#39;h3\u0026gt;div\u0026#39;) } puts first_result.attribute(\u0026#39;textContent\u0026#39;) ensure driver.quit end   const {Builder, By, Key, until} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Enter text \u0026#34;cheese\u0026#34; and perform keyboard action \u0026#34;Enter\u0026#34;  await driver.findElement(By.name(\u0026#39;q\u0026#39;)).sendKeys(\u0026#39;cheese\u0026#39;, Key.ENTER); let firstResult = await driver.wait(until.elementLocated(By.css(\u0026#39;h3\u0026gt;div\u0026#39;)), 10000); console.log(await firstResult.getAttribute(\u0026#39;textContent\u0026#39;)); } finally{ driver.quit(); } })();     Consulte la Guía rápida para obtener una explicación completa de lo que sucede detrás de escena cuando ejecuta este código. Debe continuar con la documentación narrativa para comprender cómo puede instalar y utilizar con éxito Selenium como herramienta de automatización de pruebas, y escalar pruebas simples como esta para ejecutar en entornos grandes y distribuidos en múltiples navegadores, en varios sistemas operativos diferentes.\nEmpezando Si es nuevo en Selenium, tenemos algunos recursos que pueden ayudarlo a ponerse al día de inmediato.\n Guía rápida  El WebDriver Control remoto IDE Grid HTML Runner   "
},
{
	"uri": "https://seleniumhq.github.io/docs/site/es/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]